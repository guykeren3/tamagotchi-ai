<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Tamagotchi AI - Virtual Pet</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;touch-action:manipulation;user-select:none;-webkit-user-select:none;background:#0a0a1a;}
canvas#game{position:fixed;top:0;left:0;width:100%;height:100%;display:block;}

/* ---- Top HUD ---- */
#hud{position:fixed;top:0;left:0;right:0;padding:12px 16px;display:flex;align-items:center;gap:10px;z-index:10;pointer-events:none;}
#mood-badge{background:rgba(255,255,255,0.15);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.1);border-radius:20px;padding:4px 14px;font-size:13px;color:#fff;letter-spacing:0.5px;text-transform:uppercase;pointer-events:auto;}
#stage-badge{margin-left:auto;background:rgba(255,255,255,0.12);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.08);border-radius:20px;padding:4px 14px;font-size:13px;color:rgba(255,255,255,0.8);pointer-events:auto;}
#age-badge{background:rgba(255,255,255,0.08);border-radius:20px;padding:4px 10px;font-size:11px;color:rgba(255,255,255,0.5);}

/* ---- Stat bars ---- */
#stats-bar{position:fixed;top:52px;left:0;right:0;padding:0 16px;display:flex;gap:6px;z-index:10;pointer-events:none;}
.stat{flex:1;display:flex;flex-direction:column;gap:2px;}
.stat-label{font-size:9px;color:rgba(255,255,255,0.5);text-transform:uppercase;letter-spacing:0.5px;text-align:center;}
.stat-track{height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;}
.stat-fill{height:100%;border-radius:2px;transition:width 0.5s ease;}
.stat-fill.hunger{background:linear-gradient(90deg,#ff6b6b,#ffa502);}
.stat-fill.happy{background:linear-gradient(90deg,#ffd93d,#ff9ff3);}
.stat-fill.energy{background:linear-gradient(90deg,#48dbfb,#0abde3);}
.stat-fill.hygiene{background:linear-gradient(90deg,#55efc4,#00b894);}
.stat-fill.health{background:linear-gradient(90deg,#fd79a8,#e84393);}

/* ---- Bottom action bar ---- */
#actions{position:fixed;bottom:0;left:0;right:0;padding:12px 8px;padding-bottom:max(12px,env(safe-area-inset-bottom));display:flex;justify-content:center;gap:6px;z-index:10;}
.action-btn{display:flex;flex-direction:column;align-items:center;gap:4px;background:rgba(255,255,255,0.1);backdrop-filter:blur(16px);-webkit-backdrop-filter:blur(16px);border:1px solid rgba(255,255,255,0.08);border-radius:16px;padding:10px 10px 8px;cursor:pointer;transition:all 0.2s;min-width:46px;-webkit-tap-highlight-color:transparent;}
.action-btn:hover{background:rgba(255,255,255,0.18);transform:translateY(-2px);}
.action-btn:active{transform:scale(0.92);background:rgba(255,255,255,0.25);}
.action-btn .icon{font-size:22px;line-height:1;}
.action-btn .label{font-size:9px;color:rgba(255,255,255,0.6);text-transform:uppercase;letter-spacing:0.5px;}
.action-btn.disabled{opacity:0.35;pointer-events:none;}

/* ---- Notification toast ---- */
#notif{position:fixed;top:85px;left:50%;transform:translateX(-50%) translateY(-20px);background:rgba(0,0,0,0.75);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 20px;border-radius:24px;font-size:13px;opacity:0;transition:all 0.35s cubic-bezier(0.4,0,0.2,1);pointer-events:none;z-index:20;white-space:nowrap;}
#notif.show{opacity:1;transform:translateX(-50%) translateY(0);}

/* ---- Overlay panels ---- */
.panel{position:fixed;inset:0;z-index:30;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(10,10,26,0.92);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);opacity:0;pointer-events:none;transition:opacity 0.3s;}
.panel.open{opacity:1;pointer-events:auto;}
.panel-title{font-size:18px;font-weight:700;color:#fff;margin-bottom:20px;letter-spacing:1px;}
.panel-close{position:absolute;top:16px;right:16px;width:36px;height:36px;background:rgba(255,255,255,0.1);border:none;border-radius:50%;color:#fff;font-size:20px;cursor:pointer;display:flex;align-items:center;justify-content:center;}
.panel-close:hover{background:rgba(255,255,255,0.2);}

/* Feed panel */
#feed-panel .food-grid{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;padding:0 20px;}
.food-card{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:16px 14px 12px;cursor:pointer;transition:all 0.2s;text-align:center;width:100px;}
.food-card:hover{background:rgba(255,255,255,0.15);transform:translateY(-3px);border-color:rgba(255,255,255,0.25);}
.food-card:active{transform:scale(0.95);}
.food-card .food-icon{font-size:32px;margin-bottom:6px;}
.food-card .food-name{font-size:12px;color:#fff;font-weight:600;margin-bottom:4px;}
.food-card .food-stat{font-size:9px;color:rgba(255,255,255,0.5);line-height:1.5;}
.food-card .food-stat span.pos{color:#55efc4;}
.food-card .food-stat span.neg{color:#ff6b6b;}

/* Play panel */
#play-panel .game-list{display:flex;flex-direction:column;gap:10px;width:280px;}
.game-card{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:16px 20px;cursor:pointer;transition:all 0.2s;display:flex;align-items:center;gap:14px;}
.game-card:hover{background:rgba(255,255,255,0.15);transform:translateX(4px);border-color:rgba(255,255,255,0.25);}
.game-card:active{transform:scale(0.97);}
.game-card .game-icon{font-size:28px;}
.game-card .game-info{display:flex;flex-direction:column;gap:2px;}
.game-card .game-name{font-size:14px;color:#fff;font-weight:600;}
.game-card .game-desc{font-size:11px;color:rgba(255,255,255,0.5);}

/* Dress panel */
#dress-panel .acc-grid{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;padding:0 20px;}
.acc-card{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:14px;padding:12px 16px;cursor:pointer;transition:all 0.2s;text-align:center;min-width:70px;}
.acc-card:hover{background:rgba(255,255,255,0.15);}
.acc-card:active{transform:scale(0.95);}
.acc-card.active-acc{border-color:rgba(255,220,100,0.6);background:rgba(255,220,100,0.1);}
.acc-card.locked{opacity:0.3;pointer-events:none;}
.acc-card.math-locked{opacity:0.85;border-color:rgba(255,200,100,0.4);background:rgba(255,200,100,0.08);cursor:pointer;}
.acc-card.math-locked:hover{background:rgba(255,200,100,0.15);transform:translateY(-2px);}
.acc-card .acc-icon{font-size:24px;margin-bottom:4px;}
.acc-card .acc-name{font-size:10px;color:rgba(255,255,255,0.7);}
.acc-card .acc-level{font-size:8px;color:rgba(255,200,100,0.7);margin-top:2px;}

/* House panel */
#home-panel .home-tabs{display:flex;gap:0;margin-bottom:16px;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,0.1);}
.home-tab{flex:1;padding:10px 16px;background:rgba(255,255,255,0.05);color:rgba(255,255,255,0.5);border:none;font-size:13px;font-weight:600;cursor:pointer;transition:all 0.2s;text-align:center;}
.home-tab.active{background:rgba(255,255,255,0.15);color:#fff;}
.home-tab:hover{background:rgba(255,255,255,0.1);}
#home-panel .home-section{display:none;width:100%;}
#home-panel .home-section.active{display:block;}
#home-panel .house-grid,#home-panel .land-grid{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;padding:0 20px;max-width:380px;}
.house-card,.land-card{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:14px;padding:12px 14px;cursor:pointer;transition:all 0.2s;text-align:center;min-width:70px;width:80px;}
.house-card:hover,.land-card:hover{background:rgba(255,255,255,0.15);transform:translateY(-2px);}
.house-card:active,.land-card:active{transform:scale(0.95);}
.house-card.active-house,.land-card.active-land{border-color:rgba(100,200,255,0.6);background:rgba(100,200,255,0.1);}
.house-card.math-locked{opacity:0.85;border-color:rgba(255,200,100,0.4);background:rgba(255,200,100,0.08);cursor:pointer;}
.house-card.math-locked:hover{background:rgba(255,200,100,0.15);transform:translateY(-2px);}
.house-card .house-icon,.land-card .land-icon{font-size:24px;margin-bottom:4px;}
.house-card .house-name,.land-card .land-name{font-size:10px;color:rgba(255,255,255,0.7);}
.house-card .house-level{font-size:8px;color:rgba(255,200,100,0.7);margin-top:2px;}

/* Friends section */
#friends-section{padding:0 20px;max-width:380px;width:100%;}
.friend-code-box{display:flex;align-items:center;gap:8px;margin-bottom:16px;}
.friend-code-box .code-display{flex:1;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);border-radius:10px;padding:10px 14px;font-size:18px;font-weight:700;color:#fff;font-family:monospace;letter-spacing:2px;text-align:center;}
.friend-code-box .copy-btn{background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.15);border-radius:10px;padding:10px 14px;color:#fff;font-size:13px;cursor:pointer;transition:all 0.2s;white-space:nowrap;}
.friend-code-box .copy-btn:hover{background:rgba(255,255,255,0.2);}
.friend-code-box .copy-btn:active{transform:scale(0.95);}
.friend-invite{display:flex;gap:8px;margin-bottom:16px;}
.friend-invite input{flex:1;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);border-radius:10px;padding:10px 14px;color:#fff;font-size:14px;font-family:monospace;outline:none;}
.friend-invite input::placeholder{color:rgba(255,255,255,0.3);}
.friend-invite .add-btn{background:rgba(100,200,255,0.15);border:1px solid rgba(100,200,255,0.3);border-radius:10px;padding:10px 14px;color:#fff;font-size:13px;cursor:pointer;transition:all 0.2s;white-space:nowrap;}
.friend-invite .add-btn:hover{background:rgba(100,200,255,0.25);}
.friend-invite .add-btn:active{transform:scale(0.95);}
.visitor-card{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:14px;padding:14px;display:flex;align-items:center;gap:12px;}
.visitor-card .visitor-info{flex:1;color:rgba(255,255,255,0.7);font-size:13px;}
.visitor-card .visitor-info strong{color:#fff;font-size:14px;}
.visitor-card .dismiss-btn{background:rgba(255,107,107,0.15);border:1px solid rgba(255,107,107,0.3);border-radius:10px;padding:8px 12px;color:#ff6b6b;font-size:12px;cursor:pointer;transition:all 0.2s;}
.visitor-card .dismiss-btn:hover{background:rgba(255,107,107,0.25);}
.friend-label{font-size:12px;color:rgba(255,255,255,0.4);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;}

/* Math riddle modal */
#math-modal{position:fixed;inset:0;z-index:50;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(10,10,26,0.95);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);opacity:0;pointer-events:none;transition:opacity 0.3s;}
#math-modal.open{opacity:1;pointer-events:auto;}
#math-modal .modal-content{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:24px;padding:30px;text-align:center;max-width:340px;width:90%;}
#math-modal .prize-emoji{font-size:48px;margin-bottom:10px;}
#math-modal .prize-name{font-size:18px;font-weight:700;color:#fff;margin-bottom:4px;}
#math-modal .difficulty-label{font-size:11px;color:rgba(255,200,100,0.8);text-transform:uppercase;letter-spacing:1px;margin-bottom:20px;}
#math-modal .question{font-size:28px;font-weight:700;color:#fff;margin-bottom:24px;font-family:monospace;}
#math-modal .choices{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:16px;}
#math-modal .choice-btn{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.15);border-radius:12px;padding:14px;font-size:20px;font-weight:600;color:#fff;cursor:pointer;transition:all 0.2s;}
#math-modal .choice-btn:hover{background:rgba(255,255,255,0.2);border-color:rgba(255,255,255,0.3);transform:scale(1.03);}
#math-modal .choice-btn:active{transform:scale(0.97);}
#math-modal .choice-btn.correct{background:rgba(85,239,196,0.3);border-color:#55efc4;color:#55efc4;}
#math-modal .choice-btn.wrong{background:rgba(255,107,107,0.3);border-color:#ff6b6b;color:#ff6b6b;}
#math-modal .choice-btn:disabled{pointer-events:none;}
#math-modal .feedback{font-size:14px;color:rgba(255,255,255,0.6);min-height:20px;margin-bottom:12px;}
#math-modal .feedback.success{color:#55efc4;}
#math-modal .feedback.error{color:#ff6b6b;}
#math-modal .modal-close{background:rgba(255,255,255,0.1);border:none;border-radius:20px;padding:10px 24px;color:#fff;font-size:13px;cursor:pointer;transition:all 0.2s;}
#math-modal .modal-close:hover{background:rgba(255,255,255,0.2);}

/* Stats panel */
#stats-panel .stats-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;padding:0 20px;width:320px;max-width:90vw;}
.stat-card{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:12px;text-align:center;}
.stat-card .stat-val{font-size:22px;font-weight:700;color:#fff;}
.stat-card .stat-lbl{font-size:10px;color:rgba(255,255,255,0.4);text-transform:uppercase;margin-top:2px;}
.stat-card.wide{grid-column:span 2;}
.evo-bar{width:100%;height:6px;background:rgba(255,255,255,0.1);border-radius:3px;margin-top:8px;overflow:hidden;}
.evo-fill{height:100%;background:linear-gradient(90deg,#a29bfe,#6c5ce7);border-radius:3px;transition:width 0.5s;}

/* Minigame overlay */
#minigame-overlay{position:fixed;inset:0;z-index:40;display:none;flex-direction:column;align-items:center;justify-content:center;}
#minigame-overlay.open{display:flex;}
#mg-canvas{border-radius:16px;max-width:90vw;max-height:70vh;image-rendering:pixelated;image-rendering:crisp-edges;}
#mg-hud{position:fixed;top:16px;left:50%;transform:translateX(-50%);display:flex;gap:12px;align-items:center;}
#mg-score{background:rgba(0,0,0,0.6);backdrop-filter:blur(8px);border-radius:20px;padding:6px 16px;color:#fff;font-size:14px;font-weight:600;}
#mg-quit{position:fixed;top:16px;right:16px;width:36px;height:36px;background:rgba(255,255,255,0.15);border:none;border-radius:50%;color:#fff;font-size:18px;cursor:pointer;}

/* Pet interaction hint */
#pet-hint{position:fixed;bottom:120px;left:50%;transform:translateX(-50%);color:rgba(255,255,255,0.25);font-size:11px;pointer-events:none;z-index:5;transition:opacity 0.5s;letter-spacing:0.5px;}

/* Floating hearts/particles */
.float-particle{position:fixed;pointer-events:none;z-index:15;font-size:18px;animation:floatUp 1.2s ease-out forwards;}
@keyframes floatUp{0%{opacity:1;transform:translateY(0) scale(1);}100%{opacity:0;transform:translateY(-60px) scale(0.5);}}

/* ---- Chat UI - Speech Bubble ---- */
#chat-toggle{position:fixed;left:calc(50% + 140px);top:calc(55vh - 26px);width:52px;height:52px;border-radius:50%;background:linear-gradient(135deg,#667eea,#764ba2);border:none;color:#fff;font-size:24px;cursor:pointer;z-index:25;box-shadow:0 4px 15px rgba(102,126,234,0.4);transition:all 0.3s;display:flex;align-items:center;justify-content:center;}
#chat-toggle:hover{transform:scale(1.1);box-shadow:0 6px 20px rgba(102,126,234,0.5);}
#chat-toggle:active{transform:scale(0.95);}
#chat-toggle.has-unread::after{content:'';position:absolute;top:2px;right:2px;width:12px;height:12px;background:#ff6b6b;border-radius:50%;border:2px solid #0a0a1a;}
#chat-toggle.disabled{opacity:0.4;pointer-events:none;}

#tts-toggle{position:fixed;left:calc(50% + 140px);top:calc(55vh + 35px);width:44px;height:44px;border-radius:50%;background:linear-gradient(135deg,#4ade80,#22c55e);border:none;color:#fff;font-size:20px;cursor:pointer;z-index:25;box-shadow:0 4px 15px rgba(74,222,128,0.4);transition:all 0.3s;display:flex;align-items:center;justify-content:center;}
#tts-toggle:hover{background:rgba(255,255,255,0.25);transform:scale(1.1);}
#tts-toggle:active{transform:scale(0.95);}
#tts-toggle.muted{opacity:0.5;}

/* Speech bubble container - positioned above pet */
#speech-bubble-container{position:fixed;left:50%;transform:translateX(-50%);top:18%;z-index:25;pointer-events:none;opacity:0;transition:opacity 0.3s ease;}
#speech-bubble-container.visible{opacity:1;pointer-events:auto;}

/* The cute speech bubble */
#speech-bubble{position:relative;background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border-radius:20px;padding:14px 18px;max-width:280px;min-width:120px;box-shadow:0 8px 32px rgba(0,0,0,0.3);animation:bubblePop 0.3s ease-out;}
#speech-bubble::after{content:'';position:absolute;bottom:-12px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-top:14px solid rgba(255,255,255,0.95);}
@keyframes bubblePop{0%{transform:scale(0.8);opacity:0;}50%{transform:scale(1.05);}100%{transform:scale(1);opacity:1;}}

#speech-bubble .bubble-text{color:#1a1a2e;font-size:14px;line-height:1.5;text-align:center;word-wrap:break-word;}
#speech-bubble .bubble-text.typing{color:#666;}
#speech-bubble .bubble-text.typing::after{content:'...';animation:dots 1.5s infinite;}
@keyframes dots{0%,20%{content:'.';}40%{content:'..';}60%,100%{content:'...';}}

/* Close bubble button */
#bubble-close{position:absolute;top:-8px;right:-8px;width:24px;height:24px;border-radius:50%;background:#ff6b6b;border:2px solid #fff;color:#fff;font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(0,0,0,0.2);transition:transform 0.2s;}
#bubble-close:hover{transform:scale(1.1);}

/* Chat input bar at bottom */
#chat-input-bar{position:fixed;bottom:85px;left:50%;transform:translateX(-50%);width:90%;max-width:360px;z-index:25;display:flex;gap:8px;opacity:0;pointer-events:none;transition:all 0.3s ease;}
#chat-input-bar.visible{opacity:1;pointer-events:auto;}

#chat-input{flex:1;background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border:none;border-radius:25px;padding:12px 20px;color:#1a1a2e;font-size:14px;outline:none;box-shadow:0 4px 20px rgba(0,0,0,0.2);transition:all 0.2s;}
#chat-input::placeholder{color:#888;}
#chat-input:focus{box-shadow:0 4px 25px rgba(102,126,234,0.4);}

#chat-send{width:46px;height:46px;border-radius:50%;background:linear-gradient(135deg,#667eea,#764ba2);border:none;color:#fff;font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 15px rgba(102,126,234,0.4);transition:all 0.2s;}
#chat-send:hover{transform:scale(1.08);}
#chat-send:active{transform:scale(0.95);}
#chat-send:disabled{opacity:0.5;pointer-events:none;}

/* Emoji reactions floating up */
.bubble-emoji{position:absolute;font-size:20px;animation:emojiFloat 2s ease-out forwards;pointer-events:none;}
@keyframes emojiFloat{0%{opacity:1;transform:translateY(0) scale(1);}100%{opacity:0;transform:translateY(-50px) scale(0.5);}}
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud">
  <div id="mood-badge">...</div>
  <div id="age-badge">0m</div>
  <div id="stage-badge">EGG</div>
</div>
<div id="stats-bar">
  <div class="stat"><div class="stat-label">Hunger</div><div class="stat-track"><div class="stat-fill hunger" id="bar-hunger"></div></div></div>
  <div class="stat"><div class="stat-label">Happy</div><div class="stat-track"><div class="stat-fill happy" id="bar-happy"></div></div></div>
  <div class="stat"><div class="stat-label">Energy</div><div class="stat-track"><div class="stat-fill energy" id="bar-energy"></div></div></div>
  <div class="stat"><div class="stat-label">Hygiene</div><div class="stat-track"><div class="stat-fill hygiene" id="bar-hygiene"></div></div></div>
  <div class="stat"><div class="stat-label">Health</div><div class="stat-track"><div class="stat-fill health" id="bar-health"></div></div></div>
</div>

<!-- Action bar -->
<div id="actions">
  <div class="action-btn" data-action="feed"><span class="icon">üçé</span><span class="label">Feed</span></div>
  <div class="action-btn" data-action="play"><span class="icon">üéÆ</span><span class="label">Play</span></div>
  <div class="action-btn" data-action="clean"><span class="icon">üßπ</span><span class="label">Clean</span></div>
  <div class="action-btn" data-action="dress"><span class="icon">üëí</span><span class="label">Dress</span></div>
  <div class="action-btn" data-action="home"><span class="icon">üè†</span><span class="label">Home</span></div>
  <div class="action-btn" data-action="sleep"><span class="icon">üí§</span><span class="label">Sleep</span></div>
  <div class="action-btn" data-action="stats"><span class="icon">üìä</span><span class="label">Stats</span></div>
</div>

<!-- Pet hint -->
<div id="pet-hint">Tap your pet to show love</div>

<!-- Notification -->
<div id="notif"></div>

<!-- FEED PANEL -->
<div class="panel" id="feed-panel">
  <button class="panel-close" onclick="closePanel('feed')">&times;</button>
  <div class="panel-title">Choose Food</div>
  <div class="food-grid" id="food-grid"></div>
</div>

<!-- PLAY PANEL -->
<div class="panel" id="play-panel">
  <button class="panel-close" onclick="closePanel('play')">&times;</button>
  <div class="panel-title">Mini-Games</div>
  <div class="game-list">
    <div class="game-card" onclick="startGame('guess')"><span class="game-icon">üß≠</span><div class="game-info"><div class="game-name">Guess Direction</div><div class="game-desc">Remember which way the arrow points</div></div></div>
    <div class="game-card" onclick="startGame('memory')"><span class="game-icon">üÉè</span><div class="game-info"><div class="game-name">Memory Match</div><div class="game-desc">Find all matching pairs</div></div></div>
    <div class="game-card" onclick="startGame('dodge')"><span class="game-icon">üí®</span><div class="game-info"><div class="game-name">Dodge</div><div class="game-desc">Avoid falling obstacles</div></div></div>
  </div>
</div>

<!-- DRESS PANEL -->
<div class="panel" id="dress-panel">
  <button class="panel-close" onclick="closePanel('dress')">&times;</button>
  <div class="panel-title">Accessories</div>
  <div class="acc-grid" id="acc-grid"></div>
</div>

<!-- HOME PANEL -->
<div class="panel" id="home-panel">
  <button class="panel-close" onclick="closePanel('home')">&times;</button>
  <div class="panel-title">My Home</div>
  <div class="home-tabs">
    <button class="home-tab active" onclick="switchHomeTab('houses')">üè† Houses</button>
    <button class="home-tab" onclick="switchHomeTab('landscape')">üåÑ Landscape</button>
    <button class="home-tab" onclick="switchHomeTab('friends')">üë´ Friends</button>
  </div>
  <div class="home-section active" id="houses-section">
    <div class="house-grid" id="house-grid"></div>
  </div>
  <div class="home-section" id="landscape-section">
    <div class="land-grid" id="land-grid"></div>
  </div>
  <div class="home-section" id="friends-section">
    <div class="friend-label">Your Code</div>
    <div class="friend-code-box">
      <div class="code-display" id="my-pet-code">---</div>
      <button class="copy-btn" onclick="copyPetCode()">üìã Copy</button>
    </div>
    <div class="friend-label">Invite Friend</div>
    <div class="friend-invite">
      <input type="text" id="friend-code-input" placeholder="PET-XXXX" maxlength="8">
      <button class="add-btn" onclick="addVisitorFromCode()">Add</button>
    </div>
    <div id="visitor-card-container"></div>
  </div>
</div>

<!-- STATS PANEL -->
<div class="panel" id="stats-panel">
  <button class="panel-close" onclick="closePanel('stats')">&times;</button>
  <div class="panel-title">Pet Stats</div>
  <div class="stats-grid" id="stats-grid"></div>
</div>

<!-- MATH RIDDLE MODAL -->
<div id="math-modal">
  <div class="modal-content">
    <div class="prize-emoji" id="math-prize-emoji">üéÅ</div>
    <div class="prize-name" id="math-prize-name">Prize</div>
    <div class="difficulty-label" id="math-difficulty">Level 1</div>
    <div class="question" id="math-question">5 + 3 = ?</div>
    <div class="choices" id="math-choices"></div>
    <div class="feedback" id="math-feedback"></div>
    <button class="modal-close" onclick="closeMathModal()">Close</button>
  </div>
</div>

<!-- MINIGAME OVERLAY -->
<div id="minigame-overlay">
  <div id="mg-hud"><div id="mg-score">Score: 0</div></div>
  <button id="mg-quit" onclick="quitMiniGame()">&times;</button>
  <canvas id="mg-canvas" width="240" height="200"></canvas>
</div>

<!-- CHAT UI - Speech Bubble -->
<button id="chat-toggle" class="disabled" title="Chat with your pet">üí¨</button>
<button id="tts-toggle" title="Toggle voice" onclick="toggleTTS()">üîä</button>

<!-- Speech bubble above pet -->
<div id="speech-bubble-container">
  <div id="speech-bubble">
    <button id="bubble-close">&times;</button>
    <div class="bubble-text">Hi there! üíï</div>
  </div>
</div>

<!-- Chat input bar -->
<div id="chat-input-bar">
  <input type="text" id="chat-input" placeholder="Say something to your pet..." disabled>
  <button id="chat-send" disabled>üí¨</button>
</div>

<script>
(function(){
"use strict";

// ============================================================
// CONSTANTS
// ============================================================
const SAVE_KEY = 'tamagotchi_ai_save_v2';
const AUTO_SAVE_MS = 30000;
const MAX_OFFLINE_MS = 8 * 3600 * 1000;

const STAGES = {
  EGG:   { dur: 5 },  // 5 seconds for testing
  BABY:  { dur: 1800 },  // 30 minutes
  CHILD: { dur: 3600 },  // 60 minutes
  TEEN:  { dur: 5400 },  // 90 minutes
  ADULT: { dur: Infinity }
};

const DECAY = { hunger:0.08, happiness:0.05, energy:0.04, hygiene:0.06, health:0.02 };

const FOODS = [
  { name:'Apple',  emoji:'üçé', hunger:25, happiness:5,  health:5,  energy:5 },
  { name:'Cake',   emoji:'üç∞', hunger:15, happiness:25, health:-5, energy:10 },
  { name:'Soup',   emoji:'üçú', hunger:35, happiness:5,  health:10, energy:5 },
  { name:'Vitamin',emoji:'üíä', hunger:5,  happiness:-5, health:30, energy:5 },
  { name:'Candy',  emoji:'üç¨', hunger:10, happiness:30, health:-10,energy:15 }
];

const ACCESSORIES = [
  // Stage-locked accessories
  { name:'None',    emoji:'‚ùå', stage:0, id:0 },
  { name:'Bow',     emoji:'üéÄ', stage:1, id:1 },
  { name:'Flower',  emoji:'üå∏', stage:1, id:5 },
  { name:'Top Hat', emoji:'üé©', stage:2, id:2 },
  { name:'Bandana', emoji:'üß£', stage:2, id:4 },
  { name:'Crown',   emoji:'üëë', stage:3, id:3 },
  { name:'Glasses', emoji:'üëì', stage:3, id:6 },
  { name:'Halo',    emoji:'üòá', stage:4, id:7 },
  // Math-locked accessories (K-4 grade levels)
  { name:'Sunglasses', emoji:'üòé', mathLevel:1, id:8 },
  { name:'Party Hat',  emoji:'ü•≥', mathLevel:1, id:9 },
  { name:'Headphones', emoji:'üéß', mathLevel:1, id:10 },
  { name:'Star',       emoji:'‚≠ê', mathLevel:2, id:11 },
  { name:'Rainbow',    emoji:'üåà', mathLevel:2, id:12 },
  { name:'Rocket',     emoji:'üöÄ', mathLevel:2, id:13 },
  { name:'Diamond',    emoji:'üíé', mathLevel:3, id:14 },
  { name:'Fire',       emoji:'üî•', mathLevel:3, id:15 },
  { name:'Lightning',  emoji:'‚ö°', mathLevel:3, id:16 },
  { name:'Unicorn',    emoji:'ü¶Ñ', mathLevel:4, id:17 },
  { name:'Dragon',     emoji:'üêâ', mathLevel:4, id:18 },
  { name:'Alien',      emoji:'üëΩ', mathLevel:4, id:19 }
];

const HOUSES = [
  { name:'None',         emoji:'‚ùå', id:0 },
  { name:'Tent',         emoji:'‚õ∫', mathLevel:1, id:1 },
  { name:'Cottage',      emoji:'üè°', mathLevel:1, id:2 },
  { name:'Cabin',        emoji:'üõñ', mathLevel:1, id:3 },
  { name:'Treehouse',    emoji:'üå≥', mathLevel:2, id:4 },
  { name:'Castle',       emoji:'üè∞', mathLevel:2, id:5 },
  { name:'Igloo',        emoji:'üßä', mathLevel:2, id:6 },
  { name:'Spaceship',    emoji:'üõ∏', mathLevel:3, id:7 },
  { name:'Mushroom',     emoji:'üçÑ', mathLevel:3, id:8 },
  { name:'Cloud Palace', emoji:'‚òÅÔ∏è', mathLevel:4, id:9 },
  { name:'Crystal',      emoji:'üíé', mathLevel:4, id:10 }
];

const LANDSCAPES = [
  { name:'Night Sky',    emoji:'üåô', id:0 },
  { name:'Green Meadow', emoji:'üåø', id:1 },
  { name:'Desert',       emoji:'üèúÔ∏è', id:2 },
  { name:'Clouds',       emoji:'‚òÅÔ∏è', id:3 },
  { name:'Snow',         emoji:'‚ùÑÔ∏è', id:4 },
  { name:'Beach',        emoji:'üèñÔ∏è', id:5 },
  { name:'Forest',       emoji:'üå≤', id:6 },
  { name:'Space',        emoji:'üöÄ', id:7 }
];

// Color themes per mood
const THEMES = {
  ecstatic: { bg1:'#0f0c29', bg2:'#302b63', bg3:'#24243e', ground:'#1a1a3e', stars:true },
  happy:    { bg1:'#141e30', bg2:'#243b55', bg3:'#1a2a44', ground:'#152238', stars:true },
  neutral:  { bg1:'#0f0c29', bg2:'#1a1a3e', bg3:'#16163a', ground:'#111133', stars:true },
  sad:      { bg1:'#0d0d2b', bg2:'#1b1b3a', bg3:'#151535', ground:'#0e0e28', stars:false },
  hungry:   { bg1:'#1a0a0a', bg2:'#2d1515', bg3:'#251010', ground:'#1a0a0a', stars:false },
  sleepy:   { bg1:'#050510', bg2:'#0a0a20', bg3:'#080818', ground:'#05050f', stars:true },
  dirty:    { bg1:'#1a1a0a', bg2:'#25250f', bg3:'#20200d', ground:'#15150a', stars:false },
  sick:     { bg1:'#1a0a1a', bg2:'#2d152d', bg3:'#251025', ground:'#1a0a1a', stars:false },
  dead:     { bg1:'#0a0a0a', bg2:'#151515', bg3:'#101010', ground:'#0a0a0a', stars:false }
};

// ============================================================
// CANVAS
// ============================================================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let cw, ch;

function resize() {
  cw = canvas.width = window.innerWidth * devicePixelRatio;
  ch = canvas.height = window.innerHeight * devicePixelRatio;
  ctx.scale(devicePixelRatio, devicePixelRatio);
}
window.addEventListener('resize', resize);
resize();

const vw = () => window.innerWidth;
const vh = () => window.innerHeight;

// ============================================================
// PARTICLES
// ============================================================
let particles = [];

function spawnParticle(x, y, emoji, vx, vy) {
  particles.push({ x, y, vx: vx||((Math.random()-0.5)*2), vy: vy||(-(2+Math.random()*2)), life:1, emoji: emoji||'‚ù§Ô∏è', size:18+Math.random()*10 });
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.03;
    p.life -= dt * 0.001;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.font = Math.round(p.size * p.life) + 'px sans-serif';
    ctx.fillText(p.emoji, p.x, p.y);
  }
  ctx.globalAlpha = 1;
}

// ============================================================
// STARS
// ============================================================
let stars = [];
for (let i = 0; i < 80; i++) {
  stars.push({ x: Math.random(), y: Math.random(), s: 0.5 + Math.random() * 1.5, twinkle: Math.random() * Math.PI * 2 });
}

function drawStars(t) {
  for (const s of stars) {
    const a = 0.3 + 0.7 * Math.abs(Math.sin(t * 0.001 + s.twinkle));
    ctx.globalAlpha = a * 0.6;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(s.x * vw(), s.y * vh() * 0.6, s.s, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ============================================================
// BACKGROUND
// ============================================================
function drawBackground(t, mood) {
  const theme = THEMES[mood] || THEMES.neutral;
  const w = vw(), h = vh();

  // Sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, h);
  grad.addColorStop(0, theme.bg1);
  grad.addColorStop(0.5, theme.bg2);
  grad.addColorStop(0.8, theme.bg3);
  grad.addColorStop(1, theme.ground);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, w, h);

  // Stars
  if (theme.stars) drawStars(t);

  // Ground
  const gy = h * 0.72;
  ctx.fillStyle = theme.ground;
  ctx.beginPath();
  ctx.moveTo(0, gy);
  for (let x = 0; x <= w; x += 20) {
    ctx.lineTo(x, gy + Math.sin(x * 0.02 + t * 0.0005) * 4);
  }
  ctx.lineTo(w, h);
  ctx.lineTo(0, h);
  ctx.closePath();
  ctx.fill();

  // Subtle ground highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, gy);
  for (let x = 0; x <= w; x += 20) {
    ctx.lineTo(x, gy + Math.sin(x * 0.02 + t * 0.0005) * 4);
  }
  ctx.stroke();

  // Moon (when sleeping)
  if (mood === 'sleepy') {
    ctx.fillStyle = 'rgba(255,255,200,0.15)';
    ctx.beginPath();
    ctx.arc(w * 0.8, h * 0.12, 40, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,200,0.25)';
    ctx.beginPath();
    ctx.arc(w * 0.8, h * 0.12, 30, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ============================================================
// PET DRAWING (on main canvas, not pixel art)
// ============================================================
const petSize = () => Math.min(vw(), vh()) * 0.22;
const petX = () => vw() / 2;
const petY = () => vh() * 0.55;

function drawPet(t, mood, stage, variant, sleeping, accessory) {
  const sz = petSize();
  const px = petX();
  const py = petY();
  const bounce = Math.sin(t * 0.003) * sz * 0.03;
  const breathe = 1 + Math.sin(t * 0.002) * 0.02;

  ctx.save();
  ctx.translate(px, py + bounce);
  ctx.scale(breathe, breathe);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(0, sz * 0.55, sz * 0.5, sz * 0.08, 0, 0, Math.PI * 2);
  ctx.fill();

  if (stage === 'EGG') {
    drawEggPet(t, sz);
  } else if (stage === 'BABY') {
    drawBabyPet(t, sz, mood);
  } else if (stage === 'CHILD') {
    drawChildPet(t, sz, mood, variant);
  } else if (stage === 'TEEN') {
    drawTeenPet(t, sz, mood, variant);
  } else if (stage === 'ADULT') {
    drawAdultPet(t, sz, mood, variant);
  }

  // Draw accessory
  drawAcc(accessory, sz, stage);

  // Sleep Zzz
  if (sleeping && stage !== 'EGG') {
    ctx.font = Math.round(sz * 0.25) + 'px sans-serif';
    const zt = (t * 0.002) % 3;
    ctx.globalAlpha = 0.6;
    ctx.fillText('z', sz * 0.3, -sz * 0.3 - zt * 15);
    ctx.font = Math.round(sz * 0.2) + 'px sans-serif';
    ctx.globalAlpha = 0.4;
    ctx.fillText('z', sz * 0.4, -sz * 0.5 - zt * 10);
    ctx.font = Math.round(sz * 0.15) + 'px sans-serif';
    ctx.globalAlpha = 0.25;
    ctx.fillText('z', sz * 0.5, -sz * 0.65 - zt * 6);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function drawEggPet(t, sz) {
  const wobble = Math.sin(t * 0.005) * 0.05 * (state.stageTime > STAGES.EGG.dur * 1000 * 0.5 ? 2 : 1);
  ctx.rotate(wobble);

  // Egg body
  const grad = ctx.createRadialGradient(0, 0, sz * 0.05, 0, 0, sz * 0.5);
  grad.addColorStop(0, '#ffeaa7');
  grad.addColorStop(0.7, '#fdcb6e');
  grad.addColorStop(1, '#e17055');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, sz * 0.35, sz * 0.45, 0, 0, Math.PI * 2);
  ctx.fill();

  // Spots
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.beginPath(); ctx.arc(-sz*0.1, -sz*0.15, sz*0.06, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(sz*0.12, sz*0.05, sz*0.05, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(-sz*0.05, sz*0.2, sz*0.04, 0, Math.PI*2); ctx.fill();

  // Crack near hatching
  if (state.stageTime > STAGES.EGG.dur * 1000 * 0.7) {
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-sz*0.1, -sz*0.02);
    ctx.lineTo(-sz*0.02, sz*0.06);
    ctx.lineTo(sz*0.06, -sz*0.01);
    ctx.lineTo(sz*0.12, sz*0.08);
    ctx.stroke();
  }

  ctx.rotate(-wobble);
}

function drawBabyPet(t, sz, mood) {
  const r = sz * 0.4;
  // Body
  const grad = ctx.createRadialGradient(-r*0.2, -r*0.3, r*0.1, 0, 0, r);
  grad.addColorStop(0, '#a29bfe');
  grad.addColorStop(1, '#6c5ce7');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();

  // Cheeks
  ctx.fillStyle = 'rgba(255,150,150,0.3)';
  ctx.beginPath(); ctx.arc(-r*0.45, r*0.15, r*0.15, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(r*0.45, r*0.15, r*0.15, 0, Math.PI*2); ctx.fill();

  drawFace(t, r * 0.65, mood, sz);

  // Feet
  ctx.fillStyle = '#5b4ccc';
  ctx.beginPath(); ctx.ellipse(-r*0.3, r*0.9, r*0.2, r*0.12, -0.1, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.3, r*0.9, r*0.2, r*0.12, 0.1, 0, Math.PI*2); ctx.fill();
}

function drawChildPet(t, sz, mood, variant) {
  const r = sz * 0.42;
  const hue = variant === 0 ? '#55efc4' : '#fd79a8';
  const hue2 = variant === 0 ? '#00b894' : '#e84393';

  const grad = ctx.createRadialGradient(-r*0.2, -r*0.3, r*0.1, 0, 0, r);
  grad.addColorStop(0, hue);
  grad.addColorStop(1, hue2);
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();

  // Variant features
  if (variant === 0) { // Round ears
    ctx.fillStyle = hue2;
    ctx.beginPath(); ctx.arc(-r*0.65, -r*0.65, r*0.25, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(r*0.65, -r*0.65, r*0.25, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = hue;
    ctx.beginPath(); ctx.arc(-r*0.65, -r*0.65, r*0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(r*0.65, -r*0.65, r*0.15, 0, Math.PI*2); ctx.fill();
  } else { // Spikes
    ctx.fillStyle = hue2;
    for (let i = 0; i < 3; i++) {
      const a = -Math.PI/2 + (i-1)*0.4;
      const sx = Math.cos(a)*r*1.15, sy = Math.sin(a)*r*1.15;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + Math.cos(a-0.3)*r*0.15, sy + Math.sin(a-0.3)*r*0.15);
      ctx.lineTo(sx + Math.cos(a+0.3)*r*0.15, sy + Math.sin(a+0.3)*r*0.15);
      ctx.closePath();
      ctx.fill();
    }
  }

  drawFace(t, r * 0.6, mood, sz);

  // Arms
  ctx.fillStyle = hue2;
  ctx.beginPath(); ctx.ellipse(-r*1.05, r*0.1, r*0.12, r*0.25, 0.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*1.05, r*0.1, r*0.12, r*0.25, -0.2, 0, Math.PI*2); ctx.fill();

  // Feet
  ctx.beginPath(); ctx.ellipse(-r*0.35, r*0.9, r*0.2, r*0.13, -0.1, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.35, r*0.9, r*0.2, r*0.13, 0.1, 0, Math.PI*2); ctx.fill();
}

function drawTeenPet(t, sz, mood, variant) {
  const r = sz * 0.38;
  const colors = [
    ['#74b9ff','#0984e3'], // Horned
    ['#dfe6e9','#b2bec3'], // Winged
    ['#ffeaa7','#fdcb6e'], // Tailed
    ['#fab1a0','#e17055']  // Antenna
  ];
  const [c1, c2] = colors[variant % 4];

  // Body - taller
  const grad = ctx.createRadialGradient(-r*0.2, -r*0.3, r*0.1, 0, 0, r*1.1);
  grad.addColorStop(0, c1);
  grad.addColorStop(1, c2);
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, r, r * 1.2, 0, 0, Math.PI * 2);
  ctx.fill();

  const v = variant % 4;
  ctx.fillStyle = c2;
  if (v === 0) { // Horns
    ctx.beginPath(); ctx.moveTo(-r*0.5, -r*1); ctx.lineTo(-r*0.3, -r*1.6); ctx.lineTo(-r*0.1, -r*1); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.5, -r*1); ctx.lineTo(r*0.3, -r*1.6); ctx.lineTo(r*0.1, -r*1); ctx.closePath(); ctx.fill();
  } else if (v === 1) { // Wings
    ctx.globalAlpha = 0.4;
    ctx.beginPath(); ctx.ellipse(-r*1.3, -r*0.2, r*0.6, r*0.9, 0.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*1.3, -r*0.2, r*0.6, r*0.9, -0.2, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  } else if (v === 2) { // Tail
    ctx.lineWidth = r*0.15;
    ctx.strokeStyle = c2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(r*0.6, r*0.8);
    const twave = Math.sin(t*0.004)*0.3;
    ctx.quadraticCurveTo(r*1.5+Math.sin(t*0.003)*r*0.3, r*0.3+twave*r, r*1.2, -r*0.2+twave*r*0.5);
    ctx.stroke();
    ctx.fillStyle = c1;
    ctx.beginPath(); ctx.arc(r*1.2, -r*0.2+twave*r*0.5, r*0.12, 0, Math.PI*2); ctx.fill();
  } else { // Antenna
    ctx.strokeStyle = c2;
    ctx.lineWidth = r*0.06;
    ctx.beginPath(); ctx.moveTo(0, -r*1.15); ctx.lineTo(0, -r*1.7); ctx.stroke();
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath(); ctx.arc(0, -r*1.7, r*0.12, 0, Math.PI*2); ctx.fill();
  }

  drawFace(t, r * 0.6, mood, sz);

  // Feet
  ctx.fillStyle = c2;
  ctx.beginPath(); ctx.ellipse(-r*0.35, r*1.15, r*0.22, r*0.12, -0.1, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.35, r*1.15, r*0.22, r*0.12, 0.1, 0, Math.PI*2); ctx.fill();
}

function drawAdultPet(t, sz, mood, variant) {
  const r = sz * 0.42;
  const forms = [
    { name:'Dragon',  c1:'#ff7675', c2:'#d63031' },
    { name:'Angel',   c1:'#dfe6e9', c2:'#b2bec3' },
    { name:'Devil',   c1:'#636e72', c2:'#2d3436' },
    { name:'Cat',     c1:'#ffeaa7', c2:'#fdcb6e' },
    { name:'Robot',   c1:'#74b9ff', c2:'#0984e3' },
    { name:'BlobKing',c1:'#a29bfe', c2:'#6c5ce7' }
  ];
  const v = variant % 6;
  const {c1, c2} = forms[v];

  // Main body
  const grad = ctx.createRadialGradient(-r*0.2, -r*0.3, r*0.1, 0, 0, r*1.1);
  grad.addColorStop(0, c1);
  grad.addColorStop(1, c2);
  ctx.fillStyle = grad;

  if (v === 4) { // Robot - square
    roundRect(-r*0.8, -r, r*1.6, r*2, r*0.15);
  } else {
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r * 1.15, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Variant decorations
  ctx.fillStyle = c2;
  if (v === 0) { // Dragon - horns + wings
    ctx.beginPath(); ctx.moveTo(-r*0.5, -r*0.9); ctx.lineTo(-r*0.35, -r*1.7); ctx.lineTo(-r*0.05, -r*0.9); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.5, -r*0.9); ctx.lineTo(r*0.35, -r*1.7); ctx.lineTo(r*0.05, -r*0.9); ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 0.5;
    ctx.beginPath(); ctx.ellipse(-r*1.4, -r*0.1, r*0.65, r*0.9, 0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*1.4, -r*0.1, r*0.65, r*0.9, -0.15, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    // Fire breath occasionally
    if (mood === 'ecstatic' && Math.sin(t*0.005) > 0.7) {
      ctx.fillStyle = '#ffa502';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(r*0.2, r*0.3);
      ctx.quadraticCurveTo(r*0.5, r*0.6, r*0.1, r*1.0);
      ctx.quadraticCurveTo(-r*0.1, r*0.7, -r*0.2, r*0.3);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  } else if (v === 1) { // Angel - halo + wings
    ctx.strokeStyle = 'rgba(255,255,200,0.6)';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.ellipse(0, -r*1.3, r*0.45, r*0.1, 0, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.beginPath(); ctx.ellipse(-r*1.3, -r*0.2, r*0.5, r*0.85, 0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*1.3, -r*0.2, r*0.5, r*0.85, -0.15, 0, Math.PI*2); ctx.fill();
  } else if (v === 2) { // Devil - horns + tail
    ctx.fillStyle = '#d63031';
    ctx.beginPath(); ctx.moveTo(-r*0.55, -r*0.85); ctx.lineTo(-r*0.7, -r*1.6); ctx.lineTo(-r*0.3, -r*0.85); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.55, -r*0.85); ctx.lineTo(r*0.7, -r*1.6); ctx.lineTo(r*0.3, -r*0.85); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = c2;
    ctx.lineWidth = r*0.12;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(r*0.5, r*0.8);
    ctx.quadraticCurveTo(r*1.6, r*0.5, r*1.3, -r*0.3);
    ctx.stroke();
    // Trident tip
    ctx.fillStyle = '#d63031';
    ctx.beginPath();
    ctx.moveTo(r*1.3, -r*0.3);
    ctx.lineTo(r*1.15, -r*0.55);
    ctx.lineTo(r*1.3, -r*0.45);
    ctx.lineTo(r*1.45, -r*0.55);
    ctx.closePath();
    ctx.fill();
  } else if (v === 3) { // Cat - ears + whiskers + tail
    ctx.fillStyle = c2;
    ctx.beginPath(); ctx.moveTo(-r*0.7, -r*0.6); ctx.lineTo(-r*0.5, -r*1.5); ctx.lineTo(-r*0.1, -r*0.85); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.7, -r*0.6); ctx.lineTo(r*0.5, -r*1.5); ctx.lineTo(r*0.1, -r*0.85); ctx.closePath(); ctx.fill();
    // Inner ears
    ctx.fillStyle = '#fab1a0';
    ctx.beginPath(); ctx.moveTo(-r*0.55, -r*0.7); ctx.lineTo(-r*0.48, -r*1.2); ctx.lineTo(-r*0.25, -r*0.85); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.55, -r*0.7); ctx.lineTo(r*0.48, -r*1.2); ctx.lineTo(r*0.25, -r*0.85); ctx.closePath(); ctx.fill();
    // Whiskers
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1.5;
    for (let side of [-1,1]) {
      for (let w = -1; w <= 1; w++) {
        ctx.beginPath();
        ctx.moveTo(side*r*0.3, r*0.15+w*r*0.1);
        ctx.lineTo(side*r*1.1, r*0.05+w*r*0.15);
        ctx.stroke();
      }
    }
    // Tail
    ctx.strokeStyle = c2;
    ctx.lineWidth = r*0.12;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(r*0.5, r*0.7);
    const tw = Math.sin(t*0.004)*0.3;
    ctx.bezierCurveTo(r*1.5, r*0.5+tw*r, r*1.2, -r*0.5+tw*r, r*0.8, -r*0.3+tw*r*0.5);
    ctx.stroke();
  } else if (v === 4) { // Robot - antenna + screen
    ctx.fillStyle = c2;
    ctx.fillRect(-r*0.06, -r*1.2, r*0.12, r*0.25);
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath(); ctx.arc(0, -r*1.25, r*0.1, 0, Math.PI*2); ctx.fill();
    // Screen face
    ctx.fillStyle = 'rgba(0,255,200,0.15)';
    roundRect(-r*0.55, -r*0.5, r*1.1, r*0.8, r*0.1);
    // Bolts
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath(); ctx.arc(-r*0.6, r*0.6, r*0.08, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(r*0.6, r*0.6, r*0.08, 0, Math.PI*2); ctx.fill();
  } else { // Blob King - crown
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath();
    ctx.moveTo(-r*0.55, -r*0.8);
    ctx.lineTo(-r*0.5, -r*1.3);
    ctx.lineTo(-r*0.25, -r*1.0);
    ctx.lineTo(0, -r*1.5);
    ctx.lineTo(r*0.25, -r*1.0);
    ctx.lineTo(r*0.5, -r*1.3);
    ctx.lineTo(r*0.55, -r*0.8);
    ctx.closePath();
    ctx.fill();
    // Jewels
    ctx.fillStyle = '#e84393';
    ctx.beginPath(); ctx.arc(0, -r*1.15, r*0.06, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#00b894';
    ctx.beginPath(); ctx.arc(-r*0.3, -r*0.95, r*0.04, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(r*0.3, -r*0.95, r*0.04, 0, Math.PI*2); ctx.fill();
  }

  drawFace(t, r * 0.55, mood, sz);

  // Feet (not robot)
  if (v !== 4) {
    ctx.fillStyle = c2;
    ctx.beginPath(); ctx.ellipse(-r*0.35, r*1.1, r*0.22, r*0.13, -0.1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*0.35, r*1.1, r*0.22, r*0.13, 0.1, 0, Math.PI*2); ctx.fill();
  }
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
  ctx.fill();
}

function drawFace(t, spread, mood, sz) {
  const eyeSize = sz * 0.04;
  const pupilSize = eyeSize * 0.55;
  const blink = (t % 4000) < 100;

  // Eyes
  if (mood === 'sleepy') {
    // Closed eyes (lines)
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-spread*0.5, -spread*0.15); ctx.lineTo(-spread*0.2, -spread*0.1); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(spread*0.2, -spread*0.1); ctx.lineTo(spread*0.5, -spread*0.15); ctx.stroke();
  } else if (blink) {
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-spread-eyeSize, -spread*0.15); ctx.lineTo(-spread+eyeSize, -spread*0.15); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(spread-eyeSize, -spread*0.15); ctx.lineTo(spread+eyeSize, -spread*0.15); ctx.stroke();
  } else {
    // White
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-spread*0.35, -spread*0.2, eyeSize*1.4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(spread*0.35, -spread*0.2, eyeSize*1.4, 0, Math.PI*2); ctx.fill();
    // Pupil
    ctx.fillStyle = mood === 'sick' ? '#636e72' : '#2d3436';
    ctx.beginPath(); ctx.arc(-spread*0.35, -spread*0.18, pupilSize, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(spread*0.35, -spread*0.18, pupilSize, 0, Math.PI*2); ctx.fill();
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.beginPath(); ctx.arc(-spread*0.35-pupilSize*0.3, -spread*0.22, pupilSize*0.35, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(spread*0.35-pupilSize*0.3, -spread*0.22, pupilSize*0.35, 0, Math.PI*2); ctx.fill();
  }

  // Mouth
  ctx.strokeStyle = 'rgba(0,0,0,0.5)';
  ctx.lineWidth = 1.5;
  ctx.lineCap = 'round';
  if (mood === 'ecstatic' || mood === 'happy') {
    ctx.beginPath();
    ctx.arc(0, spread*0.15, spread*0.2, 0.1, Math.PI-0.1);
    ctx.stroke();
  } else if (mood === 'sad' || mood === 'hungry' || mood === 'sick') {
    ctx.beginPath();
    ctx.arc(0, spread*0.45, spread*0.15, Math.PI+0.2, -0.2);
    ctx.stroke();
  } else if (mood === 'sleepy') {
    ctx.beginPath();
    ctx.ellipse(0, spread*0.25, spread*0.08, spread*0.06, 0, 0, Math.PI*2);
    ctx.stroke();
  } else {
    ctx.beginPath();
    ctx.moveTo(-spread*0.12, spread*0.25);
    ctx.lineTo(spread*0.12, spread*0.25);
    ctx.stroke();
  }

  // Sick swirl
  if (mood === 'sick') {
    ctx.fillStyle = 'rgba(100,200,100,0.3)';
    ctx.font = Math.round(sz*0.15) + 'px sans-serif';
    ctx.fillText('~', spread*0.5, -spread*0.5);
  }
}

function drawAcc(accId, sz, stage) {
  if (accId === 0) return;
  const acc = ACCESSORIES.find(a => a.id === accId);
  if (!acc || !acc.emoji) return;
  const s = sz * 0.3;

  // Glasses drawn with canvas instead of emoji
  if (accId === 6) {
    const oy = stage === 'ADULT' || stage === 'TEEN' ? -sz*0.12 : -sz*0.05;
    const lensR = sz * 0.09;
    const gap = sz * 0.04;
    const lensX = lensR + gap * 0.5;
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.lineWidth = Math.max(2, sz * 0.025);
    // Left lens
    ctx.beginPath(); ctx.arc(-lensX, oy, lensR, 0, Math.PI*2); ctx.stroke();
    // Right lens
    ctx.beginPath(); ctx.arc(lensX, oy, lensR, 0, Math.PI*2); ctx.stroke();
    // Bridge
    ctx.beginPath(); ctx.moveTo(-lensX + lensR, oy); ctx.lineTo(lensX - lensR, oy); ctx.stroke();
    // Arms
    ctx.beginPath(); ctx.moveTo(-lensX - lensR, oy); ctx.lineTo(-lensX - lensR - sz*0.08, oy - sz*0.02); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(lensX + lensR, oy); ctx.lineTo(lensX + lensR + sz*0.08, oy - sz*0.02); ctx.stroke();
    return;
  }

  ctx.font = Math.round(s) + 'px sans-serif';
  ctx.textAlign = 'center';
  const oy = stage === 'ADULT' || stage === 'TEEN' ? -sz*0.55 : -sz*0.4;
  ctx.fillText(acc.emoji, 0, oy);
  ctx.textAlign = 'start';
}

// ============================================================
// VISITOR PET DRAWING
// ============================================================
function drawVisitorPet(t) {
  if (!visitor) return;
  const mainSz = petSize();
  const sz = mainSz * 0.55;
  // Position to the right of main pet, but clamped to stay on screen
  const px = Math.min(petX() + mainSz * 0.75, vw() - sz * 0.6);
  const py = petY() + mainSz * 0.22;
  const bounce = Math.sin(t * 0.0025 + 1) * sz * 0.035;
  const breathe = 1 + Math.sin(t * 0.0018) * 0.015;

  ctx.save();
  ctx.translate(px, py + bounce);
  ctx.scale(breathe, breathe);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(0, sz * 0.55, sz * 0.45, sz * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();

  // Draw visitor body (skip EGG stage drawing since it references state internals)
  if (visitor.stage === 'EGG') {
    // Simple egg drawing without state dependency
    const grad = ctx.createRadialGradient(0, 0, sz * 0.05, 0, 0, sz * 0.5);
    grad.addColorStop(0, '#fff5e6');
    grad.addColorStop(1, '#f0d9b5');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, sz * 0.35, sz * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();
  } else if (visitor.stage === 'BABY') {
    drawBabyPet(t, sz, 'happy');
  } else if (visitor.stage === 'CHILD') {
    drawChildPet(t, sz, 'happy', visitor.variant);
  } else if (visitor.stage === 'TEEN') {
    drawTeenPet(t, sz, 'happy', visitor.variant);
  } else if (visitor.stage === 'ADULT') {
    drawAdultPet(t, sz, 'happy', visitor.variant);
  }

  drawAcc(visitor.accessory, sz, visitor.stage);

  ctx.restore();

  // "Visitor" label
  ctx.save();
  ctx.font = Math.round(sz * 0.2) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('Visitor', px, py - sz * 0.55);
  ctx.textAlign = 'start';
  ctx.restore();
}

// ============================================================
// HOUSE DRAWING
// ============================================================
function drawHouse(t) {
  if (!state || state.house === 0) return;
  const hx = petX();
  const hy = petY();
  const sz = petSize();
  const hs = sz * 1.6; // house scale

  ctx.save();
  ctx.translate(hx, hy + sz * 0.15);

  switch(state.house) {
    case 1: // Tent
      ctx.fillStyle = '#e17055';
      ctx.beginPath();
      ctx.moveTo(0, -hs*0.7);
      ctx.lineTo(-hs*0.6, hs*0.3);
      ctx.lineTo(hs*0.6, hs*0.3);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#d63031';
      ctx.beginPath();
      ctx.moveTo(0, -hs*0.7);
      ctx.lineTo(0, hs*0.3);
      ctx.lineTo(-hs*0.6, hs*0.3);
      ctx.closePath();
      ctx.fill();
      // Door
      ctx.fillStyle = '#2d3436';
      ctx.beginPath();
      ctx.moveTo(0, hs*0.3);
      ctx.lineTo(-hs*0.15, hs*0.3);
      ctx.lineTo(-hs*0.08, hs*0.05);
      ctx.lineTo(hs*0.08, hs*0.05);
      ctx.lineTo(hs*0.15, hs*0.3);
      ctx.closePath();
      ctx.fill();
      // Flag
      ctx.strokeStyle = '#636e72';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(0, -hs*0.7); ctx.lineTo(0, -hs*0.9); ctx.stroke();
      ctx.fillStyle = '#ffd93d';
      ctx.beginPath();
      ctx.moveTo(0, -hs*0.9);
      ctx.lineTo(hs*0.12, -hs*0.82);
      ctx.lineTo(0, -hs*0.74);
      ctx.closePath();
      ctx.fill();
      break;

    case 2: // Cottage
      // Walls
      ctx.fillStyle = '#ffeaa7';
      ctx.fillRect(-hs*0.45, -hs*0.2, hs*0.9, hs*0.5);
      // Roof
      ctx.fillStyle = '#e17055';
      ctx.beginPath();
      ctx.moveTo(-hs*0.55, -hs*0.2);
      ctx.lineTo(0, -hs*0.65);
      ctx.lineTo(hs*0.55, -hs*0.2);
      ctx.closePath();
      ctx.fill();
      // Door
      ctx.fillStyle = '#6c5ce7';
      roundRectAt(-hs*0.08, hs*0.0, hs*0.16, hs*0.3, hs*0.03);
      // Windows
      ctx.fillStyle = '#74b9ff';
      ctx.fillRect(-hs*0.35, -hs*0.1, hs*0.15, hs*0.12);
      ctx.fillRect(hs*0.2, -hs*0.1, hs*0.15, hs*0.12);
      ctx.strokeStyle = '#dfe6e9';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(-hs*0.35, -hs*0.1, hs*0.15, hs*0.12);
      ctx.strokeRect(hs*0.2, -hs*0.1, hs*0.15, hs*0.12);
      // Chimney
      ctx.fillStyle = '#b2bec3';
      ctx.fillRect(hs*0.2, -hs*0.6, hs*0.12, hs*0.25);
      // Smoke
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#dfe6e9';
      const smokeY = Math.sin(t*0.002)*hs*0.05;
      ctx.beginPath(); ctx.arc(hs*0.26, -hs*0.7+smokeY, hs*0.06, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.3, -hs*0.82+smokeY, hs*0.04, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      break;

    case 3: // Cabin
      // Log walls
      ctx.fillStyle = '#8B6914';
      ctx.fillRect(-hs*0.45, -hs*0.25, hs*0.9, hs*0.55);
      // Log lines
      ctx.strokeStyle = '#6B4F12';
      ctx.lineWidth = 2;
      for (let i = 0; i < 5; i++) {
        const ly = -hs*0.2 + i * hs*0.1;
        ctx.beginPath(); ctx.moveTo(-hs*0.45, ly); ctx.lineTo(hs*0.45, ly); ctx.stroke();
      }
      // Roof
      ctx.fillStyle = '#636e72';
      ctx.beginPath();
      ctx.moveTo(-hs*0.55, -hs*0.25);
      ctx.lineTo(0, -hs*0.6);
      ctx.lineTo(hs*0.55, -hs*0.25);
      ctx.closePath();
      ctx.fill();
      // Door
      ctx.fillStyle = '#4a3510';
      roundRectAt(-hs*0.1, hs*0.0, hs*0.2, hs*0.3, hs*0.02);
      // Window
      ctx.fillStyle = '#ffeaa7';
      ctx.fillRect(hs*0.15, -hs*0.12, hs*0.15, hs*0.12);
      break;

    case 4: // Treehouse
      // Tree trunk
      ctx.fillStyle = '#6B4F12';
      ctx.fillRect(-hs*0.08, -hs*0.1, hs*0.16, hs*0.55);
      // Branches
      ctx.strokeStyle = '#6B4F12';
      ctx.lineWidth = hs*0.04;
      ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(-hs*0.02, -hs*0.3); ctx.lineTo(-hs*0.4, -hs*0.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hs*0.02, -hs*0.25); ctx.lineTo(hs*0.35, -hs*0.45); ctx.stroke();
      // Platform
      ctx.fillStyle = '#8B6914';
      ctx.fillRect(-hs*0.35, -hs*0.45, hs*0.7, hs*0.06);
      // House on platform
      ctx.fillStyle = '#e17055';
      ctx.fillRect(-hs*0.28, -hs*0.75, hs*0.56, hs*0.3);
      // Roof
      ctx.fillStyle = '#55efc4';
      ctx.beginPath();
      ctx.moveTo(-hs*0.35, -hs*0.75);
      ctx.lineTo(0, -hs*1.0);
      ctx.lineTo(hs*0.35, -hs*0.75);
      ctx.closePath();
      ctx.fill();
      // Window
      ctx.fillStyle = '#ffeaa7';
      ctx.beginPath(); ctx.arc(0, -hs*0.62, hs*0.08, 0, Math.PI*2); ctx.fill();
      // Leaves
      ctx.fillStyle = '#00b894';
      ctx.globalAlpha = 0.6;
      ctx.beginPath(); ctx.arc(-hs*0.4, -hs*0.55, hs*0.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.35, -hs*0.5, hs*0.18, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0, -hs*1.05, hs*0.15, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      break;

    case 5: // Castle
      // Main wall
      ctx.fillStyle = '#b2bec3';
      ctx.fillRect(-hs*0.35, -hs*0.3, hs*0.7, hs*0.6);
      // Towers
      ctx.fillStyle = '#636e72';
      ctx.fillRect(-hs*0.45, -hs*0.55, hs*0.18, hs*0.85);
      ctx.fillRect(hs*0.27, -hs*0.55, hs*0.18, hs*0.85);
      // Tower tops
      ctx.fillStyle = '#6c5ce7';
      ctx.beginPath();
      ctx.moveTo(-hs*0.48, -hs*0.55);
      ctx.lineTo(-hs*0.36, -hs*0.78);
      ctx.lineTo(-hs*0.24, -hs*0.55);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(hs*0.24, -hs*0.55);
      ctx.lineTo(hs*0.36, -hs*0.78);
      ctx.lineTo(hs*0.48, -hs*0.55);
      ctx.closePath();
      ctx.fill();
      // Battlement
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = '#b2bec3';
        ctx.fillRect(-hs*0.28 + i*hs*0.14, -hs*0.36, hs*0.08, hs*0.06);
      }
      // Gate
      ctx.fillStyle = '#2d3436';
      ctx.beginPath();
      ctx.moveTo(-hs*0.1, hs*0.3);
      ctx.lineTo(-hs*0.1, -hs*0.05);
      ctx.arc(0, -hs*0.05, hs*0.1, Math.PI, 0);
      ctx.lineTo(hs*0.1, hs*0.3);
      ctx.closePath();
      ctx.fill();
      // Flags
      ctx.fillStyle = '#ff6b6b';
      const fw = Math.sin(t*0.004)*hs*0.02;
      ctx.strokeStyle = '#636e72'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(-hs*0.36, -hs*0.78); ctx.lineTo(-hs*0.36, -hs*0.95); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hs*0.36, -hs*0.78); ctx.lineTo(hs*0.36, -hs*0.95); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-hs*0.36, -hs*0.95);
      ctx.lineTo(-hs*0.22+fw, -hs*0.88);
      ctx.lineTo(-hs*0.36, -hs*0.81);
      ctx.closePath();
      ctx.fill();
      break;

    case 6: // Igloo
      // Dome
      ctx.fillStyle = '#dfe6e9';
      ctx.beginPath();
      ctx.arc(0, hs*0.15, hs*0.5, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Ice block lines
      ctx.strokeStyle = 'rgba(178,190,195,0.5)';
      ctx.lineWidth = 1;
      for (let i = 1; i < 4; i++) {
        const ay = hs*0.15 - i*hs*0.12;
        ctx.beginPath();
        ctx.arc(0, hs*0.15, hs*0.5, Math.PI + i*0.25, -i*0.25);
        ctx.stroke();
      }
      // Entrance
      ctx.fillStyle = '#74b9ff';
      ctx.beginPath();
      ctx.arc(0, hs*0.15, hs*0.15, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Snow on top
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath(); ctx.arc(0, -hs*0.35, hs*0.1, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-hs*0.15, -hs*0.3, hs*0.07, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.12, -hs*0.32, hs*0.06, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      break;

    case 7: // Spaceship
      // Body
      const grd = ctx.createRadialGradient(0, -hs*0.15, hs*0.05, 0, -hs*0.15, hs*0.45);
      grd.addColorStop(0, '#b2bec3');
      grd.addColorStop(1, '#636e72');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(0, -hs*0.15, hs*0.55, hs*0.18, 0, 0, Math.PI*2);
      ctx.fill();
      // Dome
      ctx.fillStyle = 'rgba(116,185,255,0.5)';
      ctx.beginPath();
      ctx.arc(0, -hs*0.25, hs*0.2, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Lights
      const colors = ['#ff6b6b','#ffd93d','#55efc4','#74b9ff'];
      for (let i = 0; i < 4; i++) {
        const lx = -hs*0.35 + i*hs*0.23;
        const blink = Math.sin(t*0.005 + i*1.5) > 0 ? 1 : 0.3;
        ctx.globalAlpha = blink;
        ctx.fillStyle = colors[i];
        ctx.beginPath(); ctx.arc(lx, -hs*0.05, hs*0.04, 0, Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha = 1;
      // Landing legs
      ctx.strokeStyle = '#636e72';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-hs*0.3, hs*0.02); ctx.lineTo(-hs*0.4, hs*0.25); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hs*0.3, hs*0.02); ctx.lineTo(hs*0.4, hs*0.25); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, hs*0.03); ctx.lineTo(0, hs*0.25); ctx.stroke();
      break;

    case 8: // Mushroom
      // Stem
      ctx.fillStyle = '#ffeaa7';
      ctx.fillRect(-hs*0.12, -hs*0.15, hs*0.24, hs*0.5);
      // Cap
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(0, -hs*0.15, hs*0.45, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Spots
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(-hs*0.2, -hs*0.35, hs*0.08, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.15, -hs*0.4, hs*0.06, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.0, -hs*0.5, hs*0.07, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-hs*0.3, -hs*0.22, hs*0.05, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.28, -hs*0.25, hs*0.05, 0, Math.PI*2); ctx.fill();
      // Door
      ctx.fillStyle = '#6c5ce7';
      ctx.beginPath();
      ctx.arc(0, hs*0.15, hs*0.08, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Window
      ctx.fillStyle = '#74b9ff';
      ctx.beginPath(); ctx.arc(hs*0.0, hs*0.0, hs*0.05, 0, Math.PI*2); ctx.fill();
      break;

    case 9: // Cloud Palace
      // Cloud base
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.beginPath(); ctx.arc(-hs*0.2, hs*0.2, hs*0.25, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.15, hs*0.22, hs*0.22, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0, hs*0.15, hs*0.3, 0, Math.PI*2); ctx.fill();
      // Pillars
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(-hs*0.3, -hs*0.5, hs*0.06, hs*0.55);
      ctx.fillRect(hs*0.24, -hs*0.5, hs*0.06, hs*0.55);
      // Roof
      ctx.fillStyle = '#ffd93d';
      ctx.beginPath();
      ctx.moveTo(-hs*0.38, -hs*0.5);
      ctx.lineTo(0, -hs*0.8);
      ctx.lineTo(hs*0.38, -hs*0.5);
      ctx.closePath();
      ctx.fill();
      // Arch
      ctx.fillStyle = 'rgba(116,185,255,0.4)';
      ctx.beginPath();
      ctx.arc(0, -hs*0.05, hs*0.18, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Sparkles
      ctx.globalAlpha = 0.5 + Math.sin(t*0.003)*0.3;
      ctx.fillStyle = '#ffd93d';
      ctx.font = Math.round(hs*0.1) + 'px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚ú®', -hs*0.15, -hs*0.65);
      ctx.fillText('‚ú®', hs*0.2, -hs*0.7);
      ctx.textAlign = 'start';
      ctx.globalAlpha = 1;
      break;

    case 10: // Crystal
      // Main crystal
      ctx.fillStyle = 'rgba(162,155,254,0.6)';
      ctx.beginPath();
      ctx.moveTo(0, -hs*0.85);
      ctx.lineTo(-hs*0.2, -hs*0.15);
      ctx.lineTo(hs*0.2, -hs*0.15);
      ctx.closePath();
      ctx.fill();
      // Side crystals
      ctx.fillStyle = 'rgba(108,92,231,0.5)';
      ctx.beginPath();
      ctx.moveTo(-hs*0.25, -hs*0.55);
      ctx.lineTo(-hs*0.4, hs*0.05);
      ctx.lineTo(-hs*0.15, hs*0.05);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(hs*0.3, -hs*0.5);
      ctx.lineTo(hs*0.15, hs*0.05);
      ctx.lineTo(hs*0.42, hs*0.05);
      ctx.closePath();
      ctx.fill();
      // Small crystal
      ctx.fillStyle = 'rgba(253,121,168,0.5)';
      ctx.beginPath();
      ctx.moveTo(-hs*0.42, -hs*0.25);
      ctx.lineTo(-hs*0.5, hs*0.1);
      ctx.lineTo(-hs*0.35, hs*0.1);
      ctx.closePath();
      ctx.fill();
      // Glow
      ctx.globalAlpha = 0.15 + Math.sin(t*0.003)*0.1;
      const cGlow = ctx.createRadialGradient(0, -hs*0.3, 0, 0, -hs*0.3, hs*0.6);
      cGlow.addColorStop(0, 'rgba(162,155,254,0.4)');
      cGlow.addColorStop(1, 'rgba(162,155,254,0)');
      ctx.fillStyle = cGlow;
      ctx.beginPath(); ctx.arc(0, -hs*0.3, hs*0.6, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      // Shine lines
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(-hs*0.05, -hs*0.7); ctx.lineTo(-hs*0.12, -hs*0.4); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hs*0.08, -hs*0.6); ctx.lineTo(hs*0.1, -hs*0.35); ctx.stroke();
      break;
  }
  ctx.restore();
}

function roundRectAt(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
  ctx.fill();
}

// ============================================================
// LANDSCAPE BACKGROUNDS
// ============================================================
function drawLandscapeBackground(t, mood) {
  const w = vw(), h = vh();
  const landscapeId = (state && state.landscape) || 0;

  if (landscapeId === 0) {
    // Default Night Sky - use original mood-based background
    drawBackground(t, mood);
    return;
  }

  switch(landscapeId) {
    case 1: // Green Meadow
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#87CEEB');
        grad.addColorStop(0.5, '#B0E0E6');
        grad.addColorStop(0.7, '#90EE90');
        grad.addColorStop(1, '#228B22');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Sun
        ctx.fillStyle = 'rgba(255,255,100,0.3)';
        ctx.beginPath(); ctx.arc(w*0.85, h*0.1, 50, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,150,0.6)';
        ctx.beginPath(); ctx.arc(w*0.85, h*0.1, 35, 0, Math.PI*2); ctx.fill();
        // Clouds
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        drawCloud(w*0.2 + Math.sin(t*0.0003)*20, h*0.12, 40);
        drawCloud(w*0.6 + Math.sin(t*0.0002+1)*15, h*0.08, 30);
        drawCloud(w*0.85 + Math.sin(t*0.00025+2)*18, h*0.2, 25);
        // Ground
        const gy = h*0.68;
        ctx.fillStyle = '#3CB371';
        ctx.fillRect(0, gy, w, h-gy);
        // Grass tufts
        ctx.strokeStyle = '#2E8B57';
        ctx.lineWidth = 1.5;
        for (let gx = 0; gx < w; gx += 25) {
          const gh = 8 + Math.sin(gx*0.5)*3 + Math.sin(t*0.003+gx*0.1)*2;
          ctx.beginPath();
          ctx.moveTo(gx, gy);
          ctx.quadraticCurveTo(gx-3, gy-gh, gx+2, gy-gh-3);
          ctx.stroke();
        }
        // Flowers
        const flowerColors = ['#ff6b6b','#ffd93d','#fd79a8','#a29bfe','#fff'];
        for (let i = 0; i < 12; i++) {
          const fx = (i*w/12 + Math.sin(i*3)*20) % w;
          const fy = gy + 10 + Math.sin(i*7)*5;
          ctx.fillStyle = flowerColors[i%5];
          ctx.beginPath(); ctx.arc(fx, fy, 3, 0, Math.PI*2); ctx.fill();
        }
      }
      break;

    case 2: // Desert
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#FF8C00');
        grad.addColorStop(0.3, '#FFA500');
        grad.addColorStop(0.6, '#F4A460');
        grad.addColorStop(1, '#DEB887');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Sun (big and hot)
        ctx.fillStyle = 'rgba(255,200,0,0.2)';
        ctx.beginPath(); ctx.arc(w*0.5, h*0.08, 70, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,220,50,0.5)';
        ctx.beginPath(); ctx.arc(w*0.5, h*0.08, 40, 0, Math.PI*2); ctx.fill();
        // Dunes
        const gy = h*0.68;
        ctx.fillStyle = '#D2B48C';
        ctx.beginPath();
        ctx.moveTo(0, gy);
        for (let x = 0; x <= w; x += 10) {
          ctx.lineTo(x, gy + Math.sin(x*0.01)*20 + Math.sin(x*0.025)*8);
        }
        ctx.lineTo(w, h); ctx.lineTo(0, h);
        ctx.closePath();
        ctx.fill();
        // Cactus
        ctx.fillStyle = '#2E8B57';
        drawCactus(w*0.15, gy-5, 30);
        drawCactus(w*0.78, gy-10, 22);
        // Heat shimmer
        ctx.globalAlpha = 0.05;
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 8; i++) {
          const sx = (i*w/8 + Math.sin(t*0.002+i)*30) % w;
          ctx.fillRect(sx, h*0.4, 2, h*0.15);
        }
        ctx.globalAlpha = 1;
      }
      break;

    case 3: // Clouds
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#4FC3F7');
        grad.addColorStop(0.5, '#81D4FA');
        grad.addColorStop(1, '#B3E5FC');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Many clouds
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        for (let i = 0; i < 8; i++) {
          const cx = (i*w/5 + Math.sin(t*0.0002+i*2)*40 + t*0.01*(i%3+1)*0.3) % (w+200) - 100;
          const cy = h*0.1 + i*h*0.1 + Math.sin(i*5)*h*0.05;
          drawCloud(cx, cy, 25+i*5);
        }
        // Ground clouds
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        const gy = h*0.72;
        for (let x = -50; x < w+50; x += 40) {
          const cr = 25 + Math.sin(x*0.05)*10;
          ctx.beginPath(); ctx.arc(x, gy+10, cr, 0, Math.PI*2); ctx.fill();
        }
      }
      break;

    case 4: // Snow
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#708090');
        grad.addColorStop(0.4, '#B0C4DE');
        grad.addColorStop(0.7, '#E8E8E8');
        grad.addColorStop(1, '#FFFFFF');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Snow ground
        const gy = h*0.68;
        ctx.fillStyle = '#F0F8FF';
        ctx.beginPath();
        ctx.moveTo(0, gy);
        for (let x = 0; x <= w; x += 15) {
          ctx.lineTo(x, gy + Math.sin(x*0.02)*5 + Math.sin(x*0.05)*2);
        }
        ctx.lineTo(w, h); ctx.lineTo(0, h);
        ctx.closePath();
        ctx.fill();
        // Pine trees (background)
        ctx.fillStyle = '#2F4F4F';
        drawPineTree(w*0.1, gy, 35);
        drawPineTree(w*0.25, gy+3, 25);
        drawPineTree(w*0.8, gy-2, 30);
        drawPineTree(w*0.92, gy+5, 20);
        // Snowflakes
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 30; i++) {
          const sx = (i*w/15 + t*0.02*(i%3+1)*0.3) % w;
          const sy = (i*h/12 + t*0.03*(i%4+1)*0.2) % h;
          const ss = 1 + (i%3);
          ctx.globalAlpha = 0.4 + Math.sin(t*0.003+i)*0.2;
          ctx.beginPath(); ctx.arc(sx, sy, ss, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
      break;

    case 5: // Beach
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#00BFFF');
        grad.addColorStop(0.45, '#1E90FF');
        grad.addColorStop(0.55, '#4169E1');
        grad.addColorStop(0.62, '#F5DEB3');
        grad.addColorStop(1, '#DEB887');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Sun
        ctx.fillStyle = 'rgba(255,255,100,0.3)';
        ctx.beginPath(); ctx.arc(w*0.8, h*0.08, 50, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,150,0.6)';
        ctx.beginPath(); ctx.arc(w*0.8, h*0.08, 32, 0, Math.PI*2); ctx.fill();
        // Waves
        const waveY = h*0.55;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        for (let wl = 0; wl < 3; wl++) {
          ctx.beginPath();
          ctx.moveTo(0, waveY + wl*8);
          for (let x = 0; x <= w; x += 5) {
            ctx.lineTo(x, waveY + wl*8 + Math.sin(x*0.03 + t*0.003 + wl)*4);
          }
          ctx.stroke();
        }
        // Sand
        const sy = h*0.62;
        ctx.fillStyle = '#F5DEB3';
        ctx.fillRect(0, sy, w, h-sy);
        // Palm tree
        drawPalmTree(w*0.12, sy, 60);
        // Shells
        ctx.font = '10px sans-serif';
        ctx.fillText('üêö', w*0.4, sy+15);
        ctx.fillText('üêö', w*0.7, sy+20);
        ctx.fillText('‚≠ê', w*0.55, sy+12);
      }
      break;

    case 6: // Forest
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#1B3A1B');
        grad.addColorStop(0.3, '#2D5A2D');
        grad.addColorStop(0.6, '#1B4A1B');
        grad.addColorStop(1, '#0D2B0D');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Filtered light
        ctx.globalAlpha = 0.05;
        ctx.fillStyle = '#FFD700';
        for (let i = 0; i < 5; i++) {
          const lx = w*0.2 + i*w*0.15;
          ctx.beginPath();
          ctx.moveTo(lx, 0);
          ctx.lineTo(lx-30, h*0.7);
          ctx.lineTo(lx+30, h*0.7);
          ctx.closePath();
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        // Ground
        const gy = h*0.7;
        ctx.fillStyle = '#1a3a0a';
        ctx.fillRect(0, gy, w, h-gy);
        // Background trees
        ctx.fillStyle = '#0D3B0D';
        for (let i = 0; i < 6; i++) {
          const tx = i*w/5;
          drawForestTree(tx, gy, 50+Math.sin(i*3)*15, '#0D3B0D');
        }
        // Foreground trees
        for (let i = 0; i < 3; i++) {
          const tx = w*0.1 + i*w*0.35;
          drawForestTree(tx, gy, 40, '#1B5A1B');
        }
        // Fireflies
        for (let i = 0; i < 6; i++) {
          const fx = (w*0.15+i*w/6 + Math.sin(t*0.001+i*2)*20);
          const fy = h*0.3 + Math.sin(t*0.002+i*3)*h*0.15;
          ctx.globalAlpha = 0.3 + Math.sin(t*0.005+i)*0.3;
          ctx.fillStyle = '#ADFF2F';
          ctx.beginPath(); ctx.arc(fx, fy, 2, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
      break;

    case 7: // Space
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#0a001a');
        grad.addColorStop(0.5, '#120025');
        grad.addColorStop(1, '#0a001a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Nebula
        ctx.globalAlpha = 0.08;
        const nGrad = ctx.createRadialGradient(w*0.3, h*0.4, 0, w*0.3, h*0.4, w*0.4);
        nGrad.addColorStop(0, '#8B00FF');
        nGrad.addColorStop(0.5, '#FF1493');
        nGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = nGrad;
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
        // Stars
        drawStars(t);
        // Planet
        ctx.fillStyle = '#E17055';
        ctx.beginPath(); ctx.arc(w*0.82, h*0.25, 25, 0, Math.PI*2); ctx.fill();
        // Ring
        ctx.strokeStyle = 'rgba(255,200,150,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(w*0.82, h*0.25, 40, 8, -0.3, 0, Math.PI*2);
        ctx.stroke();
        // Small planet
        ctx.fillStyle = '#74b9ff';
        ctx.beginPath(); ctx.arc(w*0.15, h*0.15, 12, 0, Math.PI*2); ctx.fill();
        // Ground (space platform)
        const gy = h*0.72;
        ctx.fillStyle = '#1a1a3e';
        ctx.fillRect(0, gy, w, h-gy);
        ctx.strokeStyle = 'rgba(100,100,200,0.2)';
        ctx.lineWidth = 1;
        for (let x = 0; x < w; x += 30) {
          ctx.beginPath(); ctx.moveTo(x, gy); ctx.lineTo(x, h); ctx.stroke();
        }
        for (let y = gy; y < h; y += 15) {
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
        }
      }
      break;
  }
}

// Landscape helper functions
function drawCloud(x, y, size) {
  ctx.beginPath();
  ctx.arc(x, y, size, 0, Math.PI*2);
  ctx.arc(x+size*0.8, y-size*0.2, size*0.7, 0, Math.PI*2);
  ctx.arc(x+size*1.4, y, size*0.6, 0, Math.PI*2);
  ctx.arc(x-size*0.6, y+size*0.1, size*0.5, 0, Math.PI*2);
  ctx.fill();
}

function drawCactus(x, y, size) {
  ctx.fillRect(x-size*0.1, y-size, size*0.2, size);
  // Arms
  ctx.fillRect(x-size*0.35, y-size*0.7, size*0.25, size*0.1);
  ctx.fillRect(x-size*0.35, y-size*0.7, size*0.1, size*0.35);
  ctx.fillRect(x+size*0.1, y-size*0.5, size*0.25, size*0.1);
  ctx.fillRect(x+size*0.25, y-size*0.5, size*0.1, size*0.3);
}

function drawPineTree(x, y, size) {
  ctx.save();
  // Trunk
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(x-size*0.06, y-size*0.2, size*0.12, size*0.25);
  // Layers
  ctx.fillStyle = '#2E7D32';
  for (let i = 0; i < 3; i++) {
    const ly = y - size*0.2 - i*size*0.3;
    const lw = size*0.4 - i*size*0.08;
    ctx.beginPath();
    ctx.moveTo(x-lw, ly);
    ctx.lineTo(x, ly-size*0.35);
    ctx.lineTo(x+lw, ly);
    ctx.closePath();
    ctx.fill();
  }
  // Snow caps
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  for (let i = 0; i < 3; i++) {
    const ly = y - size*0.2 - i*size*0.3;
    ctx.beginPath();
    ctx.moveTo(x-size*0.1, ly-size*0.25);
    ctx.lineTo(x, ly-size*0.35);
    ctx.lineTo(x+size*0.1, ly-size*0.25);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawPalmTree(x, y, size) {
  // Trunk
  ctx.fillStyle = '#8B6914';
  ctx.lineWidth = size*0.08;
  ctx.strokeStyle = '#6B4F12';
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.quadraticCurveTo(x+size*0.15, y-size*0.5, x+size*0.05, y-size*0.8);
  ctx.lineWidth = size*0.1;
  ctx.stroke();
  // Leaves
  ctx.fillStyle = '#228B22';
  const lx = x+size*0.05, ly = y-size*0.8;
  for (let i = 0; i < 5; i++) {
    const angle = -Math.PI/2 + (i-2)*0.5;
    ctx.save();
    ctx.translate(lx, ly);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.ellipse(0, -size*0.25, size*0.06, size*0.3, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  // Coconuts
  ctx.fillStyle = '#8B4513';
  ctx.beginPath(); ctx.arc(lx+3, ly+5, 4, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(lx-4, ly+6, 4, 0, Math.PI*2); ctx.fill();
}

function drawForestTree(x, y, size, color) {
  ctx.fillStyle = '#3E2723';
  ctx.fillRect(x-size*0.06, y-size*0.3, size*0.12, size*0.35);
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x, y-size*0.45, size*0.35, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x-size*0.2, y-size*0.3, size*0.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x+size*0.2, y-size*0.35, size*0.22, 0, Math.PI*2); ctx.fill();
}

// Draw poop on screen
function drawPoops(t) {
  if (!state || state.poopCount <= 0 || state.stage === 'EGG') return;
  const sz = petSize() * 0.3;
  ctx.font = Math.round(sz) + 'px sans-serif';
  for (let i = 0; i < state.poopCount; i++) {
    const px = petX() + petSize() * 0.6 + i * sz * 0.8;
    const py = petY() + petSize() * 0.3 + Math.sin(t * 0.003 + i) * 3;
    ctx.fillText('üí©', px, py);
    // Stink
    ctx.globalAlpha = 0.3 + Math.sin(t*0.005+i)*0.15;
    ctx.font = Math.round(sz*0.4) + 'px sans-serif';
    ctx.fillText('~', px + sz*0.5, py - sz*0.5 - Math.sin(t*0.008+i)*5);
    ctx.globalAlpha = 1;
    ctx.font = Math.round(sz) + 'px sans-serif';
  }
}

// Dead pet
function drawDeadPet() {
  const sz = petSize();
  ctx.font = Math.round(sz * 0.8) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('üëª', petX(), petY());
  ctx.font = '18px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('Your pet has passed away...', petX(), petY() + sz * 0.6);
  ctx.font = '14px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillText('Tap anywhere for a new egg', petX(), petY() + sz * 0.6 + 24);
  ctx.textAlign = 'start';
}

// Evolution animation
let evolveAnim = null;
function drawEvolveAnim(t) {
  if (!evolveAnim) return false;
  const elapsed = t - evolveAnim.start;
  if (elapsed > 3500) { evolveAnim = null; return false; }

  // Flash overlay
  const flash = elapsed < 1500 ? Math.sin(elapsed * 0.015) * 0.5 + 0.5 : 0;
  if (flash > 0) {
    ctx.fillStyle = `rgba(255,255,255,${flash * 0.6})`;
    ctx.fillRect(0, 0, vw(), vh());
  }

  // Text
  if (elapsed > 1200) {
    ctx.textAlign = 'center';
    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = `rgba(255,255,255,${Math.min(1, (elapsed-1200)/500)})`;
    ctx.fillText('Evolved to ' + state.stage + '!', vw()/2, vh() * 0.25);
    ctx.textAlign = 'start';
  }

  // Sparkles
  if (elapsed < 2500 && Math.random() < 0.3) {
    spawnParticle(petX() + (Math.random()-0.5)*petSize(), petY() + (Math.random()-0.5)*petSize(), '‚ú®');
  }

  return true;
}

// ============================================================
// GAME STATE
// ============================================================
let state = null;

function newState() {
  return {
    stage:'EGG', variant:0, stageTime:0, totalTime:0,
    hunger:80, happiness:80, energy:100, hygiene:100, health:100,
    careScore:50, feedCount:0, playCount:0, missedCare:0,
    happinessSum:0, happinessSamples:0,
    poopCount:0, poopTimer:0,
    sleeping:false, alive:true, accessory:0,
    unlockedAccessories:[],
    house:0, landscape:0, unlockedHouses:[],
    lastUpdate:Date.now(), created:Date.now()
  };
}

function save() { try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); } catch(e){} }
function load() { 
  try { 
    const d=localStorage.getItem(SAVE_KEY); 
    if(d){
      state=JSON.parse(d);
      // Migration: add missing fields
      if(!state.unlockedAccessories) state.unlockedAccessories=[];
      if(!state.unlockedHouses) state.unlockedHouses=[];
      if(state.house===undefined) state.house=0;
      if(state.landscape===undefined) state.landscape=0;
      return true;
    } 
  } catch(e){} 
  return false; 
}

function applyOfflineDecay() {
  if (!state||!state.alive||state.stage==='EGG') return;
  const now=Date.now();
  let elapsed=Math.min(now-state.lastUpdate, MAX_OFFLINE_MS);
  if (elapsed<1000) return;
  const secs=elapsed/1000, sm=state.sleeping?0.3:1;
  state.hunger=Math.max(0,state.hunger-DECAY.hunger*secs*sm);
  state.happiness=Math.max(0,state.happiness-DECAY.happiness*secs*sm);
  state.energy=state.sleeping?Math.min(100,state.energy+0.05*secs):Math.max(0,state.energy-DECAY.energy*secs);
  state.hygiene=Math.max(0,state.hygiene-DECAY.hygiene*secs*sm);
  if (state.hunger<10||state.hygiene<10) state.health=Math.max(0,state.health-DECAY.health*secs*2);
  state.poopTimer+=elapsed;
  while(state.poopTimer>60000&&state.poopCount<5){state.poopTimer-=60000;state.poopCount++;state.hygiene=Math.max(0,state.hygiene-10);}
  state.stageTime+=elapsed; state.totalTime+=elapsed;
  if(state.health<=0) state.alive=false;
  state.lastUpdate=now;
}

function getMood() {
  if(!state||!state.alive) return 'dead';
  if(state.stage==='EGG') return 'neutral';
  if(state.sleeping) return 'sleepy';
  if(state.health<20) return 'sick';
  if(state.hunger<20) return 'hungry';
  if(state.hygiene<20) return 'dirty';
  if(state.energy<15) return 'sleepy';
  const avg=(state.hunger+state.happiness+state.energy+state.hygiene+state.health)/5;
  if(avg>85) return 'ecstatic';
  if(avg>60) return 'happy';
  if(state.happiness<30) return 'sad';
  return 'neutral';
}

function getStageIndex(s){ return ['EGG','BABY','CHILD','TEEN','ADULT'].indexOf(s); }

function updateCareScore() {
  if(state.happinessSamples>0){
    const avg=state.happinessSum/state.happinessSamples;
    state.careScore=Math.max(0,Math.min(100, avg*0.4+Math.min(state.feedCount,50)*0.6+Math.min(state.playCount,30)*0.8-state.missedCare*2));
  }
}

function checkEvolution() {
  if(!state.alive||state.stage==='ADULT') return;
  if(state.stageTime>=STAGES[state.stage].dur*1000) evolve();
}

function evolve() {
  updateCareScore();
  const cs=state.careScore;
  if(state.stage==='EGG') state.stage='BABY';
  else if(state.stage==='BABY'){state.stage='CHILD';state.variant=cs>=50?0:1;}
  else if(state.stage==='CHILD'){state.stage='TEEN';state.variant=cs>=75?0:cs>=50?1:cs>=25?2:3;}
  else if(state.stage==='TEEN'){state.stage='ADULT';state.variant=cs>=85?0:cs>=70?1:cs>=55?3:cs>=40?5:cs>=20?4:2;}
  state.stageTime=0;
  evolveAnim={start:performance.now()};
  sfxEvolve();
  save();
  updateHUD();
  buildDressPanel();
  // Notify chat system of evolution
  if(typeof clearChatOnEvolve === 'function') clearChatOnEvolve();
  if(typeof updateChatUI === 'function') updateChatUI();
}

// ============================================================
// SOUND
// ============================================================
let audioCtx=null;
function getAudioCtx(){if(!audioCtx)audioCtx=new(window.AudioContext||window.webkitAudioContext)();return audioCtx;}
function beep(f,d,type){try{const ctx=getAudioCtx();const o=ctx.createOscillator(),g=ctx.createGain();o.type=type||'square';o.frequency.value=f;g.gain.value=0.04;g.gain.exponentialRampToValueAtTime(0.001,ctx.currentTime+(d||0.1));o.connect(g);g.connect(ctx.destination);o.start();o.stop(ctx.currentTime+(d||0.1));}catch(e){}}
function sfxSelect(){beep(880,0.05);}
function sfxConfirm(){beep(660,0.05);setTimeout(()=>beep(880,0.08),60);}
function sfxDeny(){beep(220,0.15);}
function sfxEvolve(){beep(440,0.1);setTimeout(()=>beep(550,0.1),100);setTimeout(()=>beep(660,0.1),200);setTimeout(()=>beep(880,0.15),300);}

// Cute pet sounds
function playNote(freq, duration, type='sine', volume=0.08, delay=0) {
  try {
    const ctx = getAudioCtx();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, ctx.currentTime + delay);
    gain.gain.setValueAtTime(volume, ctx.currentTime + delay);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + duration);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(ctx.currentTime + delay);
    osc.stop(ctx.currentTime + delay + duration);
  } catch(e) {}
}

// Baby giggle sound
function sfxBabyGiggle() {
  const notes = [600, 800, 700, 900, 750, 850];
  notes.forEach((n, i) => {
    playNote(n + Math.random()*50, 0.08, 'sine', 0.06, i * 0.07);
  });
}

// Baby coo sound
function sfxBabyCoo() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.linearRampToValueAtTime(600, ctx.currentTime + 0.15);
  osc.frequency.linearRampToValueAtTime(500, ctx.currentTime + 0.3);
  gain.gain.setValueAtTime(0.08, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.35);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.35);
}

// Child happy sound
function sfxChildHappy() {
  playNote(523, 0.12, 'sine', 0.07, 0);      // C
  playNote(659, 0.12, 'sine', 0.07, 0.1);    // E
  playNote(784, 0.15, 'sine', 0.07, 0.2);    // G
}

// Child curious sound
function sfxChildCurious() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.linearRampToValueAtTime(700, ctx.currentTime + 0.25);
  gain.gain.setValueAtTime(0.07, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.3);
}

// Teen sound (more chill)
function sfxTeenSound() {
  playNote(350, 0.15, 'triangle', 0.06, 0);
  playNote(400, 0.2, 'triangle', 0.05, 0.12);
}

// Adult wise sound (warm chord)
function sfxAdultSound() {
  playNote(262, 0.3, 'sine', 0.04, 0);  // C
  playNote(330, 0.3, 'sine', 0.04, 0);  // E
  playNote(392, 0.3, 'sine', 0.04, 0);  // G
  playNote(523, 0.25, 'sine', 0.03, 0.15); // High C
}

// Play appropriate sound based on stage and mood
function sfxPetSpeak(stage, mood) {
  const isHappy = mood === 'happy' || mood === 'ecstatic';
  
  switch(stage) {
    case 'BABY':
      if (isHappy) sfxBabyGiggle();
      else sfxBabyCoo();
      break;
    case 'CHILD':
      if (isHappy) sfxChildHappy();
      else sfxChildCurious();
      break;
    case 'TEEN':
      sfxTeenSound();
      break;
    case 'ADULT':
      sfxAdultSound();
      break;
    default:
      sfxSelect();
  }
}

// ============================================================
// TEXT-TO-SPEECH
// ============================================================
let ttsEnabled = true;
let ttsVoice = null;

// Initialize TTS voice (prefer female English voice)
function initTTS() {
  if (!('speechSynthesis' in window)) {
    console.log('Text-to-speech not supported');
    ttsEnabled = false;
    return;
  }
  
  const loadVoices = () => {
    const voices = speechSynthesis.getVoices();
    // Prefer female English voices
    const preferred = ['Samantha', 'Victoria', 'Karen', 'Moira', 'Fiona', 'Google US English Female'];
    for (const name of preferred) {
      const found = voices.find(v => v.name.includes(name));
      if (found) { ttsVoice = found; return; }
    }
    // Fallback to any English female voice
    ttsVoice = voices.find(v => v.lang.startsWith('en') && v.name.toLowerCase().includes('female')) 
            || voices.find(v => v.lang.startsWith('en'))
            || voices[0];
  };
  
  loadVoices();
  if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = loadVoices;
  }
}

// Speak text with stage-appropriate voice settings
function speakText(text, stage) {
  if (!ttsEnabled || !('speechSynthesis' in window)) return;
  
  // Cancel any ongoing speech
  speechSynthesis.cancel();
  
  // Remove emojis for cleaner speech
  const cleanText = text.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F600}-\u{1F64F}]|[\u{1F680}-\u{1F6FF}]/gu, '').trim();
  if (!cleanText) return;
  
  const utterance = new SpeechSynthesisUtterance(cleanText);
  
  // Set voice
  if (ttsVoice) utterance.voice = ttsVoice;
  utterance.lang = 'en-US';
  
  // Adjust pitch and rate based on stage
  switch(stage) {
    case 'BABY':
      utterance.pitch = 1.8;  // High pitch for baby
      utterance.rate = 0.85;  // Slower
      break;
    case 'CHILD':
      utterance.pitch = 1.5;  // Higher pitch
      utterance.rate = 1.0;   // Normal speed
      break;
    case 'TEEN':
      utterance.pitch = 1.2;  // Slightly higher
      utterance.rate = 1.05;  // Slightly faster
      break;
    case 'ADULT':
      utterance.pitch = 1.1;  // Near normal
      utterance.rate = 0.95;  // Calm pace
      break;
    default:
      utterance.pitch = 1.3;
      utterance.rate = 1.0;
  }
  
  utterance.volume = 0.9;
  
  speechSynthesis.speak(utterance);
}

// Toggle TTS on/off
function toggleTTS() {
  ttsEnabled = !ttsEnabled;
  if (!ttsEnabled) speechSynthesis.cancel();
  const btn = document.getElementById('tts-toggle');
  if (btn) {
    btn.textContent = ttsEnabled ? 'üîä' : 'üîá';
    btn.classList.toggle('muted', !ttsEnabled);
  }
  notify(ttsEnabled ? 'üîä Voice enabled' : 'üîá Voice disabled');
  sfxSelect();
}
window.toggleTTS = toggleTTS;

// ============================================================
// NOTIFICATION
// ============================================================
const notifEl=document.getElementById('notif');
let notifTimer=null;
function notify(msg){notifEl.textContent=msg;notifEl.classList.add('show');clearTimeout(notifTimer);notifTimer=setTimeout(()=>notifEl.classList.remove('show'),2500);}

// ============================================================
// HUD UPDATE
// ============================================================
function updateHUD() {
  if(!state) return;
  const mood=getMood();
  const moodEmojis={ecstatic:'üòç',happy:'üòä',neutral:'üòê',sad:'üò¢',hungry:'üçΩÔ∏è',sleepy:'üò¥',dirty:'ü§¢',sick:'ü§í',dead:'üíÄ'};
  document.getElementById('mood-badge').textContent=(moodEmojis[mood]||'')+ ' ' + mood.charAt(0).toUpperCase()+mood.slice(1);
  document.getElementById('stage-badge').textContent=state.stage + (state.stage==='ADULT'?' ‚òÖ':'');
  document.getElementById('age-badge').textContent=formatTime(state.totalTime);

  document.getElementById('bar-hunger').style.width=Math.round(state.hunger)+'%';
  document.getElementById('bar-happy').style.width=Math.round(state.happiness)+'%';
  document.getElementById('bar-energy').style.width=Math.round(state.energy)+'%';
  document.getElementById('bar-hygiene').style.width=Math.round(state.hygiene)+'%';
  document.getElementById('bar-health').style.width=Math.round(state.health)+'%';

  // Disable buttons for egg
  const isEgg=state.stage==='EGG';
  document.querySelectorAll('.action-btn').forEach(b=>{
    const a=b.dataset.action;
    if(a==='stats'||a==='home') b.classList.toggle('disabled',false);
    else b.classList.toggle('disabled',isEgg||(!state.alive));
  });

  // Update sleep button text
  const sleepBtn=document.querySelector('[data-action="sleep"]');
  if(sleepBtn){
    sleepBtn.querySelector('.label').textContent=state.sleeping?'Wake':'Sleep';
    sleepBtn.querySelector('.icon').textContent=state.sleeping?'‚òÄÔ∏è':'üí§';
  }
  
  // Update chat UI if function exists
  if(typeof updateChatUI === 'function') updateChatUI();
}

function formatTime(ms){
  const s=Math.floor(ms/1000),m=Math.floor(s/60),h=Math.floor(m/60);
  if(h>0) return h+'h '+( m%60)+'m';
  return m+'m '+(s%60)+'s';
}

// ============================================================
// PANELS
// ============================================================
function openPanel(name){
  document.getElementById(name+'-panel').classList.add('open');
  sfxSelect();
}
function closePanel(name){
  document.getElementById(name+'-panel').classList.remove('open');
}
// expose globally for onclick
window.closePanel=closePanel;

function buildFeedPanel(){
  const grid=document.getElementById('food-grid');
  grid.innerHTML='';
  FOODS.forEach((f,i)=>{
    const card=document.createElement('div');
    card.className='food-card';
    const statLine=(k,v)=>`<span class="${v>=0?'pos':'neg'}">${v>=0?'+':''}${v} ${k}</span>`;
    card.innerHTML=`<div class="food-icon">${f.emoji}</div><div class="food-name">${f.name}</div><div class="food-stat">${statLine('hun',f.hunger)}<br>${statLine('hap',f.happiness)}<br>${statLine('hp',f.health)}</div>`;
    card.onclick=()=>{feedPet(i);closePanel('feed');};
    grid.appendChild(card);
  });
}

function buildDressPanel(){
  const grid=document.getElementById('acc-grid');
  grid.innerHTML='';
  const si=getStageIndex(state.stage);
  ACCESSORIES.forEach(a=>{
    const card=document.createElement('div');
    
    // Check lock type
    const isStageLocked = a.stage !== undefined && a.stage > si;
    const isMathLocked = a.mathLevel !== undefined && !state.unlockedAccessories.includes(a.id);
    const isUnlocked = !isStageLocked && !isMathLocked;
    
    // Set classes
    let className = 'acc-card';
    if (isStageLocked) className += ' locked';
    else if (isMathLocked) className += ' math-locked';
    if (state.accessory === a.id) className += ' active-acc';
    card.className = className;
    
    // Set content
    if (isStageLocked) {
      card.innerHTML = `<div class="acc-icon">üîí</div><div class="acc-name">Locked</div>`;
    } else if (isMathLocked) {
      const levelNames = ['', 'Easy', 'Medium', 'Tricky', 'Challenge'];
      card.innerHTML = `<div class="acc-icon">üß©</div><div class="acc-name">${a.name}</div><div class="acc-level">Lv${a.mathLevel} ${levelNames[a.mathLevel]}</div>`;
      card.onclick = () => openMathRiddle(a, 'acc');
    } else {
      card.innerHTML = `<div class="acc-icon">${a.emoji}</div><div class="acc-name">${a.name}</div>`;
      card.onclick = () => {
        state.accessory = a.id;
        notify('Wearing: ' + a.name);
        sfxConfirm();
        closePanel('dress');
        save();
        buildDressPanel();
      };
    }
    
    grid.appendChild(card);
  });
}

// ============================================================
// MATH RIDDLE SYSTEM
// ============================================================
const MATH_DIFFICULTY = {
  1: { ops: ['+', '-'], max: 10, name: 'Easy' },
  2: { ops: ['+', '-'], max: 20, name: 'Medium' },
  3: { ops: ['+', '-', '√ó'], max: 12, name: 'Tricky' },
  4: { ops: ['+', '-', '√ó', '√∑'], max: 12, name: 'Challenge' }
};

let currentMathAcc = null;
let currentMathType = 'acc'; // 'acc' or 'house'
let currentMathProblem = null;

function generateMathProblem(level) {
  const config = MATH_DIFFICULTY[level];
  const op = config.ops[Math.floor(Math.random() * config.ops.length)];
  let a, b, answer;
  
  if (op === '+') {
    a = Math.floor(Math.random() * config.max) + 1;
    b = Math.floor(Math.random() * (config.max - a)) + 1;
    answer = a + b;
  } else if (op === '-') {
    a = Math.floor(Math.random() * config.max) + 1;
    b = Math.floor(Math.random() * a) + 1;
    answer = a - b;
  } else if (op === '√ó') {
    a = Math.floor(Math.random() * config.max) + 1;
    b = Math.floor(Math.random() * config.max) + 1;
    answer = a * b;
  } else if (op === '√∑') {
    // Ensure clean division
    b = Math.floor(Math.random() * (config.max - 1)) + 2;
    answer = Math.floor(Math.random() * config.max) + 1;
    a = b * answer;
  }
  
  const question = `${a} ${op} ${b} = ?`;
  
  // Generate 4 choices including the correct answer
  const choices = new Set([answer]);
  while (choices.size < 4) {
    let wrong = answer + Math.floor(Math.random() * 11) - 5;
    if (wrong !== answer && wrong >= 0) choices.add(wrong);
  }
  
  // Shuffle choices
  const shuffled = Array.from(choices).sort(() => Math.random() - 0.5);
  
  return { question, answer, choices: shuffled };
}

function openMathRiddle(acc, type) {
  currentMathAcc = acc;
  currentMathType = type || 'acc';
  currentMathProblem = generateMathProblem(acc.mathLevel);

  document.getElementById('math-prize-emoji').textContent = acc.emoji;
  document.getElementById('math-prize-name').textContent = acc.name;
  document.getElementById('math-difficulty').textContent = `Level ${acc.mathLevel} - ${MATH_DIFFICULTY[acc.mathLevel].name}`;
  document.getElementById('math-question').textContent = currentMathProblem.question;
  document.getElementById('math-feedback').textContent = '';
  document.getElementById('math-feedback').className = 'feedback';

  const choicesDiv = document.getElementById('math-choices');
  choicesDiv.innerHTML = '';
  currentMathProblem.choices.forEach(choice => {
    const btn = document.createElement('button');
    btn.className = 'choice-btn';
    btn.textContent = choice;
    btn.onclick = () => handleMathAnswer(btn, choice);
    choicesDiv.appendChild(btn);
  });

  document.getElementById('math-modal').classList.add('open');
  if (currentMathType === 'house') closePanel('home');
  else closePanel('dress');
  sfxSelect();
}

function handleMathAnswer(btn, chosen) {
  const correct = currentMathProblem.answer;
  const allBtns = document.querySelectorAll('#math-choices .choice-btn');
  const feedback = document.getElementById('math-feedback');
  
  // Disable all buttons
  allBtns.forEach(b => b.disabled = true);
  
  if (chosen === correct) {
    // Correct answer!
    btn.classList.add('correct');
    feedback.textContent = 'üéâ Correct! Accessory unlocked!';
    feedback.className = 'feedback success';
    
    // Unlock item
    if (currentMathType === 'house') {
      state.unlockedHouses.push(currentMathAcc.id);
      state.house = currentMathAcc.id;
    } else {
      state.unlockedAccessories.push(currentMathAcc.id);
      state.accessory = currentMathAcc.id;
    }
    save();
    
    // Celebration
    sfxEvolve();
    for (let i = 0; i < 8; i++) {
      setTimeout(() => {
        spawnParticle(
          vw()/2 + (Math.random()-0.5)*150, 
          vh()/2 + (Math.random()-0.5)*100, 
          ['‚ú®','üéâ','‚≠ê','üí´'][Math.floor(Math.random()*4)]
        );
      }, i * 80);
    }
    
    // Close after delay
    setTimeout(() => {
      closeMathModal();
      notify('üéâ Unlocked: ' + currentMathAcc.name + '!');
    }, 1500);
    
  } else {
    // Wrong answer
    btn.classList.add('wrong');
    // Highlight correct answer
    allBtns.forEach(b => {
      if (parseInt(b.textContent) === correct) b.classList.add('correct');
    });
    feedback.textContent = `The answer was ${correct}. Try again!`;
    feedback.className = 'feedback error';
    sfxDeny();
    
    // Generate new problem after delay
    setTimeout(() => {
      currentMathProblem = generateMathProblem(currentMathAcc.mathLevel);
      document.getElementById('math-question').textContent = currentMathProblem.question;
      feedback.textContent = '';
      feedback.className = 'feedback';
      
      const choicesDiv = document.getElementById('math-choices');
      choicesDiv.innerHTML = '';
      currentMathProblem.choices.forEach(choice => {
        const newBtn = document.createElement('button');
        newBtn.className = 'choice-btn';
        newBtn.textContent = choice;
        newBtn.onclick = () => handleMathAnswer(newBtn, choice);
        choicesDiv.appendChild(newBtn);
      });
    }, 2000);
  }
}

function closeMathModal() {
  document.getElementById('math-modal').classList.remove('open');
  const wasHouse = currentMathType === 'house';
  currentMathAcc = null;
  currentMathProblem = null;
  if (wasHouse) buildHousePanel();
  else buildDressPanel();
}
window.closeMathModal = closeMathModal;

function switchHomeTab(tab) {
  const tabs = ['houses','landscape','friends'];
  document.querySelectorAll('.home-tab').forEach((t,i) => {
    t.classList.toggle('active', tab===tabs[i]);
  });
  tabs.forEach(id => {
    document.getElementById(id+'-section').classList.toggle('active', tab===id);
  });
  if (tab === 'friends') buildFriendsSection();
}
window.switchHomeTab = switchHomeTab;

// ============================================================
// FRIEND PET VISITS - Share Code System
// ============================================================
let visitor = null; // {stage, variant, accessory, house, landscape}

const STAGE_NAMES = ['EGG','BABY','CHILD','TEEN','ADULT'];

function encodePetCode() {
  if (!state) return 'PET-0000';
  const si = getStageIndex(state.stage);
  const v = state.variant || 0;
  const a = state.accessory || 0;
  const h = state.house || 0;
  const l = state.landscape || 0;
  // stage:0-4, variant:0-5, accessory:0-19, house:0-10, landscape:0-7
  const value = si * (6*20*11*8) + v * (20*11*8) + a * (11*8) + h * 8 + l;
  const code = value.toString(36).toUpperCase().padStart(4, '0');
  return 'PET-' + code;
}

function decodePetCode(code) {
  if (!code || !code.startsWith('PET-') || code.length !== 8) return null;
  const hex = code.slice(4);
  const value = parseInt(hex, 36);
  if (isNaN(value) || value < 0) return null;
  const l = value % 8;
  const rem1 = Math.floor(value / 8);
  const h = rem1 % 11;
  const rem2 = Math.floor(rem1 / 11);
  const a = rem2 % 20;
  const rem3 = Math.floor(rem2 / 20);
  const v = rem3 % 6;
  const si = Math.floor(rem3 / 6);
  if (si < 0 || si > 4) return null;
  return { stage: STAGE_NAMES[si], variant: v, accessory: a, house: h, landscape: l };
}

function buildFriendsSection() {
  document.getElementById('my-pet-code').textContent = encodePetCode();
  const container = document.getElementById('visitor-card-container');
  if (visitor) {
    const stageName = visitor.stage;
    const acc = ACCESSORIES.find(a => a.id === visitor.accessory);
    const accName = acc ? acc.name : 'None';
    container.innerHTML = '<div class="friend-label" style="margin-top:16px">Current Visitor</div>' +
      '<div class="visitor-card">' +
      '<div class="visitor-info"><strong>' + stageName + ' Pet</strong><br>Accessory: ' + accName + '</div>' +
      '<button class="dismiss-btn" onclick="dismissVisitor()">Dismiss</button>' +
      '</div>';
  } else {
    container.innerHTML = '';
  }
}

function copyPetCode() {
  const code = encodePetCode();
  navigator.clipboard.writeText(code).then(() => {
    notify('üìã Code copied: ' + code);
  }).catch(() => {
    notify('Code: ' + code);
  });
}
window.copyPetCode = copyPetCode;

function addVisitorFromCode() {
  const input = document.getElementById('friend-code-input');
  const code = (input.value || '').trim().toUpperCase();
  const data = decodePetCode(code);
  if (!data) {
    notify('‚ùå Invalid code! Use format PET-XXXX');
    return;
  }
  visitor = data;
  input.value = '';
  closePanel('home');
  notify('üë´ Visitor pet arrived!');
}
window.addVisitorFromCode = addVisitorFromCode;

function dismissVisitor() {
  visitor = null;
  notify('üëã Visitor dismissed');
  buildFriendsSection();
}
window.dismissVisitor = dismissVisitor;

function buildHousePanel() {
  // Build houses grid
  const grid = document.getElementById('house-grid');
  grid.innerHTML = '';
  HOUSES.forEach(h => {
    const card = document.createElement('div');
    const isMathLocked = h.mathLevel !== undefined && !state.unlockedHouses.includes(h.id);
    const isUnlocked = !isMathLocked;

    let className = 'house-card';
    if (isMathLocked) className += ' math-locked';
    if (state.house === h.id) className += ' active-house';
    card.className = className;

    if (isMathLocked) {
      const levelNames = ['', 'Easy', 'Medium', 'Tricky', 'Challenge'];
      card.innerHTML = `<div class="house-icon">üß©</div><div class="house-name">${h.name}</div><div class="house-level">Lv${h.mathLevel} ${levelNames[h.mathLevel]}</div>`;
      card.onclick = () => openMathRiddle(h, 'house');
    } else {
      card.innerHTML = `<div class="house-icon">${h.emoji}</div><div class="house-name">${h.name}</div>`;
      card.onclick = () => {
        state.house = h.id;
        notify(h.id === 0 ? 'House removed' : 'Living in: ' + h.name);
        sfxConfirm();
        save();
        buildHousePanel();
      };
    }
    grid.appendChild(card);
  });

  // Build landscape grid
  const landGrid = document.getElementById('land-grid');
  landGrid.innerHTML = '';
  LANDSCAPES.forEach(l => {
    const card = document.createElement('div');
    let className = 'land-card';
    if (state.landscape === l.id) className += ' active-land';
    card.className = className;
    card.innerHTML = `<div class="land-icon">${l.emoji}</div><div class="land-name">${l.name}</div>`;
    card.onclick = () => {
      state.landscape = l.id;
      notify('Landscape: ' + l.name);
      sfxConfirm();
      save();
      buildHousePanel();
    };
    landGrid.appendChild(card);
  });
}

function buildStatsPanel(){
  const grid=document.getElementById('stats-grid');
  const si=STAGES[state.stage];
  const evoPct=si.dur<Infinity?Math.min(100,Math.round(state.stageTime/si.dur*100)):100;
  grid.innerHTML=`
    <div class="stat-card"><div class="stat-val">${Math.round(state.hunger)}%</div><div class="stat-lbl">Hunger</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.happiness)}%</div><div class="stat-lbl">Happiness</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.energy)}%</div><div class="stat-lbl">Energy</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.hygiene)}%</div><div class="stat-lbl">Hygiene</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.health)}%</div><div class="stat-lbl">Health</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.careScore)}</div><div class="stat-lbl">Care Score</div></div>
    <div class="stat-card"><div class="stat-val">${state.feedCount}</div><div class="stat-lbl">Meals</div></div>
    <div class="stat-card"><div class="stat-val">${state.playCount}</div><div class="stat-lbl">Games Played</div></div>
    <div class="stat-card wide"><div class="stat-val">${state.stage}${state.stage==='ADULT'?' (Final Form!)':''}</div><div class="stat-lbl">Stage${si.dur<Infinity?' - '+evoPct+'% to next':''}</div>${si.dur<Infinity?`<div class="evo-bar"><div class="evo-fill" style="width:${evoPct}%"></div></div>`:''}</div>
    <div class="stat-card wide"><div class="stat-val">${formatTime(state.totalTime)}</div><div class="stat-lbl">Age</div></div>
  `;
}

// ============================================================
// ACTIONS
// ============================================================
function feedPet(i){
  const f=FOODS[i];
  state.hunger=Math.min(100,state.hunger+f.hunger);
  state.happiness=Math.min(100,Math.max(0,state.happiness+f.happiness));
  state.health=Math.min(100,Math.max(0,state.health+f.health));
  state.energy=Math.min(100,state.energy+f.energy);
  state.feedCount++;
  state.careScore=Math.min(100,state.careScore+1);
  notify(f.emoji+' '+f.name+'! Yum!');
  sfxConfirm();
  // Food particles
  for(let j=0;j<5;j++) spawnParticle(petX()+(Math.random()-0.5)*60, petY()-20, f.emoji);
  save();
  updateHUD();
}

function doClean(){
  if(state.poopCount>0){
    state.poopCount=0;state.hygiene=100;state.careScore=Math.min(100,state.careScore+3);
    notify('‚ú® All clean!');sfxConfirm();
    for(let j=0;j<6;j++) spawnParticle(petX()+(Math.random()-0.5)*80, petY()+(Math.random()-0.5)*40, '‚ú®');
  } else {
    state.hygiene=Math.min(100,state.hygiene+20);
    notify('Already clean!');sfxSelect();
    for(let j=0;j<3;j++) spawnParticle(petX()+(Math.random()-0.5)*60, petY(), 'ü´ß');
  }
  save();updateHUD();
}

function toggleSleep(){
  state.sleeping=!state.sleeping;
  if(state.sleeping){notify('üí§ Good night...');}
  else{notify('‚òÄÔ∏è Good morning!');if(state.energy>80) state.careScore=Math.min(100,state.careScore+2);}
  sfxConfirm();save();updateHUD();
}

function petPat(){
  if(!state||!state.alive||state.stage==='EGG') return;
  if(state.sleeping) return;
  state.happiness=Math.min(100,state.happiness+2);
  state.careScore=Math.min(100,state.careScore+0.3);
  for(let j=0;j<3;j++) spawnParticle(petX()+(Math.random()-0.5)*40, petY()-petSize()*0.3, '‚ù§Ô∏è');
  sfxSelect();
  // Hide hint after first pat
  document.getElementById('pet-hint').style.opacity='0';
}

// ============================================================
// ACTION BAR
// ============================================================
document.querySelectorAll('.action-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const a=btn.dataset.action;
    if(!state||!state.alive) return;
    if(state.stage==='EGG'&&a!=='stats'&&a!=='home'){notify('Egg is not ready yet!');sfxDeny();return;}
    if(state.sleeping&&a!=='sleep'&&a!=='stats'&&a!=='home'){notify('Pet is sleeping!');sfxDeny();return;}
    sfxSelect();
    if(a==='feed'){buildFeedPanel();openPanel('feed');}
    else if(a==='play'){
      if(state.energy<10){notify('Too tired to play!');sfxDeny();return;}
      openPanel('play');
    }
    else if(a==='clean') doClean();
    else if(a==='dress'){buildDressPanel();openPanel('dress');}
    else if(a==='home'){buildHousePanel();openPanel('home');}
    else if(a==='sleep') toggleSleep();
    else if(a==='stats'){buildStatsPanel();openPanel('stats');}
  });
});

// ============================================================
// CANVAS CLICK -> PET / POOP / DEAD
// ============================================================
canvas.addEventListener('click', e=>{
  if(!state) return;

  // Dead -> new pet
  if(!state.alive){
    state=newState();save();notify('ü•ö A new egg!');updateHUD();return;
  }

  const cx=e.clientX, cy=e.clientY;
  const dx=cx-petX(), dy=cy-petY();
  const dist=Math.sqrt(dx*dx+dy*dy);

  // Tap poop to clean
  if(state.poopCount>0){
    const poopX=petX()+petSize()*0.6;
    const poopY=petY()+petSize()*0.3;
    if(cx>poopX-30 && cx<poopX+state.poopCount*30+30 && cy>poopY-40 && cy<poopY+30){
      doClean();return;
    }
  }

  // Tap pet to pat
  if(dist<petSize()*0.7){
    petPat();
  }
});

// ============================================================
// MINI-GAMES (rendered on mg-canvas)
// ============================================================
const mgCanvas=document.getElementById('mg-canvas');
const mgCtx=mgCanvas.getContext('2d');
mgCtx.imageSmoothingEnabled=false;
const MGW=240, MGH=200;
let miniGame=null;

function startGame(type){
  if(state.energy<10){notify('Too tired!');sfxDeny();return;}
  closePanel('play');
  if(type==='guess') startGuessGame();
  else if(type==='memory') startMemoryGame();
  else if(type==='dodge') startDodgeGame();
  document.getElementById('minigame-overlay').classList.add('open');
}
window.startGame=startGame;

function quitMiniGame(){
  endMiniGame(miniGame?miniGame.score||0:0);
}
window.quitMiniGame=quitMiniGame;

function endMiniGame(score){
  const reward=Math.min(30, score*3);
  state.happiness=Math.min(100,state.happiness+reward);
  state.energy=Math.max(0,state.energy-10);
  state.playCount++;
  state.careScore=Math.min(100,state.careScore+2);
  miniGame=null;
  document.getElementById('minigame-overlay').classList.remove('open');
  notify('üéÆ Fun! +'+reward+' happiness');
  sfxConfirm();save();updateHUD();
}

// Guess Direction
function startGuessGame(){
  miniGame={type:'guess',phase:'show',direction:['LEFT','RIGHT','UP','DOWN'][Math.floor(Math.random()*4)],timer:90,score:0,rounds:0,maxRounds:5};
}

// Memory Match
function startMemoryGame(){
  const syms=['üåü','üéà','üçï','üåà'];
  let cards=[];
  for(let i=0;i<4;i++) cards.push(syms[i],syms[i]);
  for(let i=cards.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[cards[i],cards[j]]=[cards[j],cards[i]];}
  miniGame={type:'memory',cards,revealed:new Array(8).fill(false),matched:new Array(8).fill(false),first:-1,second:-1,phase:'pick',timer:0,cursor:0,pairs:0,moves:0,score:0};
}

// Dodge
function startDodgeGame(){
  miniGame={type:'dodge',px:MGW/2,obstacles:[],spawnTimer:0,score:0,timer:600,hit:false,phase:'play'};
}

// MG keyboard
document.addEventListener('keydown',e=>{
  if(!miniGame) return;
  if(e.key==='Escape'){quitMiniGame();return;}
  if(miniGame.type==='guess') guessInput(e.key);
  else if(miniGame.type==='memory') memoryInput(e.key);
  else if(miniGame.type==='dodge') dodgeInput(e.key);
});

// MG canvas click for memory
mgCanvas.addEventListener('click',e=>{
  if(!miniGame||miniGame.type!=='memory'||miniGame.phase!=='pick') return;
  const rect=mgCanvas.getBoundingClientRect();
  const sx=MGW/rect.width, sy=MGH/rect.height;
  const mx=(e.clientX-rect.left)*sx, my=(e.clientY-rect.top)*sy;
  for(let i=0;i<8;i++){
    const col=i%4, row=Math.floor(i/4);
    const cx=16+col*55, cy=50+row*70;
    if(mx>=cx&&mx<=cx+45&&my>=cy&&my<=cy+55){
      memorySelect(i);
      break;
    }
  }
});

// MG canvas touch for dodge
let dodgeTouchX=null;
mgCanvas.addEventListener('touchstart',e=>{
  if(!miniGame||miniGame.type!=='dodge') return;
  dodgeTouchX=e.touches[0].clientX;
},{passive:true});
mgCanvas.addEventListener('touchmove',e=>{
  if(!miniGame||miniGame.type!=='dodge'||dodgeTouchX===null) return;
  const dx=e.touches[0].clientX-dodgeTouchX;
  dodgeTouchX=e.touches[0].clientX;
  miniGame.px=Math.max(10,Math.min(MGW-20,miniGame.px+dx*1.5));
},{passive:true});

// Guess game click on arrows
mgCanvas.addEventListener('click',e=>{
  if(!miniGame||miniGame.type!=='guess'||miniGame.phase!=='input') return;
  const rect=mgCanvas.getBoundingClientRect();
  const sx=MGW/rect.width;
  const mx=(e.clientX-rect.left)*sx, my=(e.clientY-rect.top)*sx;
  if(mx<MGW*0.33) guessAnswer('LEFT');
  else if(mx>MGW*0.66) guessAnswer('RIGHT');
  else if(my<MGH*0.4) guessAnswer('UP');
  else guessAnswer('DOWN');
});

function guessInput(key){
  if(miniGame.phase!=='input') return;
  if(key==='ArrowLeft') guessAnswer('LEFT');
  else if(key==='ArrowRight') guessAnswer('RIGHT');
  else if(key==='ArrowUp') guessAnswer('UP');
  else if(key==='ArrowDown') guessAnswer('DOWN');
}

function guessAnswer(dir){
  if(miniGame.phase!=='input') return;
  if(dir===miniGame.direction) miniGame.score++;
  miniGame.phase='result';
  miniGame.answer=dir;
  miniGame.timer=45;
}

function memoryInput(key){
  if(miniGame.phase!=='pick') return;
  if(key==='ArrowLeft') miniGame.cursor=(miniGame.cursor-1+8)%8;
  else if(key==='ArrowRight') miniGame.cursor=(miniGame.cursor+1)%8;
  else if(key==='ArrowUp') miniGame.cursor=(miniGame.cursor-4+8)%8;
  else if(key==='ArrowDown') miniGame.cursor=(miniGame.cursor+4)%8;
  else if(key==='Enter'||key===' ') memorySelect(miniGame.cursor);
}

function memorySelect(idx){
  if(miniGame.phase!=='pick'||miniGame.matched[idx]||miniGame.revealed[idx]) return;
  miniGame.revealed[idx]=true;
  miniGame.moves++;
  if(miniGame.first===-1){miniGame.first=idx;}
  else{miniGame.second=idx;miniGame.phase='compare';miniGame.timer=30;}
}

function dodgeInput(key){
  if(miniGame.phase!=='play') return;
  if(key==='ArrowLeft') miniGame.px=Math.max(10,miniGame.px-12);
  if(key==='ArrowRight') miniGame.px=Math.min(MGW-20,miniGame.px+12);
}

// MG update + draw
function updateMiniGame(){
  if(!miniGame) return;
  const mg=miniGame;

  if(mg.type==='guess'){
    mg.timer--;
    if(mg.phase==='show'&&mg.timer<=0){mg.phase='input';mg.timer=120;}
    else if(mg.phase==='input'&&mg.timer<=0){mg.phase='result';mg.answer=null;mg.timer=45;}
    else if(mg.phase==='result'&&mg.timer<=0){
      mg.rounds++;
      if(mg.rounds>=mg.maxRounds){endMiniGame(mg.score);return;}
      mg.direction=['LEFT','RIGHT','UP','DOWN'][Math.floor(Math.random()*4)];
      mg.phase='show';mg.timer=90;mg.answer=null;
    }
  } else if(mg.type==='memory'){
    if(mg.phase==='compare'){
      mg.timer--;
      if(mg.timer<=0){
        if(mg.cards[mg.first]===mg.cards[mg.second]){mg.matched[mg.first]=true;mg.matched[mg.second]=true;mg.pairs++;mg.score+=2;
          if(mg.pairs>=4){endMiniGame(mg.score+Math.max(0,20-mg.moves));return;}}
        mg.revealed[mg.first]=false;mg.revealed[mg.second]=false;mg.first=-1;mg.second=-1;mg.phase='pick';
      }
    }
  } else if(mg.type==='dodge'){
    if(mg.phase==='play'){
      mg.spawnTimer--;
      if(mg.spawnTimer<=0){mg.obstacles.push({x:Math.random()*(MGW-20),y:-10,w:10+Math.random()*20,speed:1.5+Math.random()*2});mg.spawnTimer=12+Math.random()*18;}
      for(let i=mg.obstacles.length-1;i>=0;i--){
        mg.obstacles[i].y+=mg.obstacles[i].speed;
        if(mg.obstacles[i].y+8>MGH-30&&mg.obstacles[i].y<MGH-15&&mg.obstacles[i].x+mg.obstacles[i].w>mg.px-5&&mg.obstacles[i].x<mg.px+15){mg.hit=true;mg.phase='end';mg.timer=60;return;}
        if(mg.obstacles[i].y>MGH){mg.obstacles.splice(i,1);mg.score++;}
      }
      mg.timer--;
      if(mg.timer<=0){mg.phase='end';mg.timer=60;}
    } else if(mg.phase==='end'){
      mg.timer--;
      if(mg.timer<=0) endMiniGame(mg.score);
    }
  }

  document.getElementById('mg-score').textContent='Score: '+(mg.score||0);
}

function drawMiniGame(){
  if(!miniGame) return;
  const mg=miniGame;
  mgCtx.fillStyle='#1a1a2e';
  mgCtx.fillRect(0,0,MGW,MGH);

  if(mg.type==='guess'){
    mgCtx.textAlign='center';
    mgCtx.fillStyle='#fff';
    mgCtx.font='bold 16px sans-serif';
    mgCtx.fillText('Guess Direction',MGW/2,25);
    mgCtx.font='12px sans-serif';
    mgCtx.fillStyle='rgba(255,255,255,0.5)';
    mgCtx.fillText(`Round ${mg.rounds+1}/${mg.maxRounds}`,MGW/2,42);

    if(mg.phase==='show'){
      // Draw big arrow
      mgCtx.font='48px sans-serif';
      const arrows={LEFT:'‚¨ÖÔ∏è',RIGHT:'‚û°Ô∏è',UP:'‚¨ÜÔ∏è',DOWN:'‚¨áÔ∏è'};
      mgCtx.fillText(arrows[mg.direction],MGW/2,120);
      mgCtx.font='14px sans-serif';
      mgCtx.fillStyle='rgba(255,255,255,0.6)';
      mgCtx.fillText('Remember this!',MGW/2,160);
    } else if(mg.phase==='input'){
      mgCtx.font='14px sans-serif';
      mgCtx.fillStyle='#fff';
      mgCtx.fillText('Which way was it?',MGW/2,70);
      // Draw clickable zones
      mgCtx.font='32px sans-serif';
      mgCtx.fillText('‚¨ÖÔ∏è',50,125);
      mgCtx.fillText('‚¨ÜÔ∏è',MGW/2,85);
      mgCtx.fillText('‚¨áÔ∏è',MGW/2,165);
      mgCtx.fillText('‚û°Ô∏è',MGW-50,125);
      // Timer bar
      mgCtx.fillStyle='rgba(255,255,255,0.1)';
      mgCtx.fillRect(20,180,200,6);
      mgCtx.fillStyle='#74b9ff';
      mgCtx.fillRect(20,180,200*mg.timer/120,6);
    } else {
      const correct=mg.answer===mg.direction;
      mgCtx.font='bold 20px sans-serif';
      mgCtx.fillStyle=correct?'#55efc4':'#ff7675';
      mgCtx.fillText(correct?'Correct! ‚úì':'Wrong ‚úó',MGW/2,100);
      mgCtx.font='14px sans-serif';
      mgCtx.fillStyle='rgba(255,255,255,0.5)';
      mgCtx.fillText('Answer: '+mg.direction,MGW/2,130);
    }
    mgCtx.textAlign='start';
  } else if(mg.type==='memory'){
    mgCtx.textAlign='center';
    mgCtx.fillStyle='#fff';
    mgCtx.font='bold 16px sans-serif';
    mgCtx.fillText('Memory Match',MGW/2,25);
    mgCtx.font='11px sans-serif';
    mgCtx.fillStyle='rgba(255,255,255,0.4)';
    mgCtx.fillText('Moves: '+mg.moves,MGW/2,40);
    mgCtx.textAlign='start';

    for(let i=0;i<8;i++){
      const col=i%4, row=Math.floor(i/4);
      const cx=16+col*55, cy=50+row*70;
      if(mg.matched[i]){
        mgCtx.fillStyle='rgba(85,239,196,0.15)';
        mgCtx.fillRect(cx,cy,45,55);
        mgCtx.font='24px sans-serif';
        mgCtx.textAlign='center';
        mgCtx.fillText(mg.cards[i],cx+22,cy+38);
        mgCtx.textAlign='start';
      } else if(mg.revealed[i]){
        mgCtx.fillStyle='rgba(116,185,255,0.2)';
        mgCtx.fillRect(cx,cy,45,55);
        mgCtx.font='24px sans-serif';
        mgCtx.textAlign='center';
        mgCtx.fillText(mg.cards[i],cx+22,cy+38);
        mgCtx.textAlign='start';
      } else {
        mgCtx.fillStyle='rgba(255,255,255,0.08)';
        mgCtx.fillRect(cx,cy,45,55);
        mgCtx.font='20px sans-serif';
        mgCtx.textAlign='center';
        mgCtx.fillStyle='rgba(255,255,255,0.2)';
        mgCtx.fillText('?',cx+22,cy+36);
        mgCtx.textAlign='start';
      }
      // Keyboard cursor
      if(i===mg.cursor&&mg.phase==='pick'){
        mgCtx.strokeStyle='rgba(255,255,255,0.5)';
        mgCtx.lineWidth=2;
        mgCtx.strokeRect(cx-1,cy-1,47,57);
      }
    }
  } else if(mg.type==='dodge'){
    mgCtx.textAlign='center';
    mgCtx.fillStyle='#fff';
    mgCtx.font='bold 14px sans-serif';
    mgCtx.fillText('Dodge!',MGW/2,20);
    mgCtx.textAlign='start';

    // Player
    mgCtx.fillStyle='#74b9ff';
    mgCtx.beginPath();
    mgCtx.moveTo(mg.px,MGH-30);
    mgCtx.lineTo(mg.px-8,MGH-15);
    mgCtx.lineTo(mg.px+8,MGH-15);
    mgCtx.closePath();
    mgCtx.fill();

    // Obstacles
    mgCtx.fillStyle='#ff7675';
    for(const ob of mg.obstacles){
      mgCtx.fillRect(Math.round(ob.x),Math.round(ob.y),Math.round(ob.w),8);
    }

    // Timer
    mgCtx.fillStyle='rgba(255,255,255,0.1)';
    mgCtx.fillRect(20,MGH-8,200,4);
    mgCtx.fillStyle='#ffd93d';
    mgCtx.fillRect(20,MGH-8,200*mg.timer/600,4);

    if(mg.phase==='end'){
      mgCtx.fillStyle='rgba(0,0,0,0.6)';
      mgCtx.fillRect(0,0,MGW,MGH);
      mgCtx.textAlign='center';
      mgCtx.fillStyle='#fff';
      mgCtx.font='bold 20px sans-serif';
      mgCtx.fillText(mg.hit?'Hit!':'Time Up!',MGW/2,85);
      mgCtx.font='16px sans-serif';
      mgCtx.fillText('Score: '+mg.score,MGW/2,115);
      mgCtx.textAlign='start';
    }
  }
}

// ============================================================
// GAME LOOP
// ============================================================
let lastTime=performance.now();
let decayAccum=0, saveAccum=0, hudAccum=0, warnAccum=0;

function gameLoop(now){
  const dt=Math.min(now-lastTime,100);
  lastTime=now;

  if(state&&state.alive&&state.stage!=='EGG'){
    decayAccum+=dt;
    while(decayAccum>=500){
      decayAccum-=500;
      const s=0.5, sm=state.sleeping?0.3:1;
      state.hunger=Math.max(0,state.hunger-DECAY.hunger*s*sm);
      state.happiness=Math.max(0,state.happiness-DECAY.happiness*s*sm);
      state.energy=state.sleeping?Math.min(100,state.energy+0.05*s):Math.max(0,state.energy-DECAY.energy*s);
      state.hygiene=Math.max(0,state.hygiene-DECAY.hygiene*s*sm);
      if(state.hunger<10||state.hygiene<10) state.health=Math.max(0,state.health-DECAY.health*s*2);
      state.poopTimer+=500;
      if(state.poopTimer>=60000&&state.poopCount<5){state.poopTimer-=60000;state.poopCount++;state.hygiene=Math.max(0,state.hygiene-10);}
      state.happinessSum+=state.happiness;state.happinessSamples++;
      if(state.health<=0) state.alive=false;
    }
    state.stageTime+=dt;state.totalTime+=dt;state.lastUpdate=Date.now();
  } else if(state&&state.stage==='EGG'){
    state.stageTime+=dt;state.totalTime+=dt;state.lastUpdate=Date.now();
  }

  // Save
  saveAccum+=dt;
  if(saveAccum>=AUTO_SAVE_MS){saveAccum=0;save();}

  // HUD update
  hudAccum+=dt;
  if(hudAccum>=500){hudAccum=0;updateHUD();}

  // Warnings
  warnAccum+=dt;
  if(warnAccum>=8000&&state&&state.alive&&state.stage!=='EGG'){
    warnAccum=0;
    if(state.hunger<15){notify('üçΩÔ∏è Pet is hungry!');state.missedCare++;}
    else if(state.hygiene<15){notify('ü§¢ Pet is dirty!');state.missedCare++;}
    else if(state.energy<10&&!state.sleeping) notify('üò¥ Pet is tired!');
    else if(state.health<25){notify('ü§í Pet is sick!');state.missedCare++;}
  }

  // Evolution
  if(state&&state.alive&&!evolveAnim) checkEvolution();

  // Particles
  updateParticles(dt);

  // Mini-game
  if(miniGame) updateMiniGame();

  // ---- DRAW ----
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(devicePixelRatio,devicePixelRatio);
  const mood=getMood();
  // Use landscape background if set, otherwise default
  if (state && state.landscape && state.landscape > 0) {
    drawLandscapeBackground(now, mood);
  } else {
    drawBackground(now, mood);
  }

  if(state&&state.alive){
    drawHouse(now);
    drawPet(now, mood, state.stage, state.variant, state.sleeping, state.accessory);
    if (visitor) drawVisitorPet(now);
    drawPoops(now);
  } else if(state){
    drawDeadPet();
  }

  drawParticles();
  if(evolveAnim) drawEvolveAnim(now);

  // Mini-game
  if(miniGame) drawMiniGame();

  requestAnimationFrame(gameLoop);
}

// ============================================================
// CHAT SYSTEM - Speech Bubble
// ============================================================
const chatToggle = document.getElementById('chat-toggle');
const speechBubbleContainer = document.getElementById('speech-bubble-container');
const speechBubble = document.getElementById('speech-bubble');
const bubbleText = document.querySelector('#speech-bubble .bubble-text');
const bubbleClose = document.getElementById('bubble-close');
const chatInputBar = document.getElementById('chat-input-bar');
const chatInput = document.getElementById('chat-input');
const chatSend = document.getElementById('chat-send');
let chatOpen = false;
let conversationHistory = [];
let isSending = false;
let bubbleTimeout = null;

// API base URL - uses same origin when served from the server
const API_BASE = '';

function toggleChat() {
  if (!state || state.stage === 'EGG') {
    notify('ü•ö Your pet can\'t talk yet!');
    sfxDeny();
    return;
  }
  chatOpen = !chatOpen;
  chatInputBar.classList.toggle('visible', chatOpen);
  if (chatOpen) {
    chatInput.focus();
    // Show a greeting bubble if not already showing
    if (!speechBubbleContainer.classList.contains('visible')) {
      showBubble(getGreeting());
    }
  } else {
    hideBubble();
  }
}

function closeChat() {
  chatOpen = false;
  chatInputBar.classList.remove('visible');
  hideBubble();
}

function getGreeting() {
  const mood = getMood();
  const greetings = {
    BABY: {
      happy: ['Hewwo! üíï', 'Yay! You here! üéâ', 'Me wuv you! üíñ'],
      hungry: ['Hungwy... üçº', 'Want nummies! üò¢'],
      sleepy: ['*yawns* Sweepy... üí§', 'Me tired... üò¥'],
      default: ['Hi hi! ‚ú®', 'Goo goo! üíï']
    },
    CHILD: {
      happy: ['Hi!! What are we doing today? üåü', 'Yay you\'re here! üéà', 'Let\'s play!! üéÆ'],
      hungry: ['My tummy is rumbling... üçï', 'Can we eat something? ü•∫'],
      sleepy: ['*yawns* I\'m getting sleepy... üò¥', 'Maybe nap time? üí§'],
      default: ['Hey hey! ‚ú®', 'What\'s up? üòä']
    },
    TEEN: {
      happy: ['Oh hey! üëã', 'What\'s good? ‚úåÔ∏è', 'Finally some company üòé'],
      hungry: ['Ugh I\'m starving... üçî', 'Can we get food? üò§'],
      sleepy: ['*yawns* So tired rn... üò¥', 'Need sleep tbh üí§'],
      default: ['Sup üëã', 'Hey there üòè']
    },
    ADULT: {
      happy: ['Hello, dear friend! üí´', 'Wonderful to see you! ‚ú®', 'What a lovely moment üå∏'],
      hungry: ['I could use a nice meal... üçΩÔ∏è', 'Feeling a bit peckish üòä'],
      sleepy: ['Feeling peaceful and drowsy... üåô', 'Perhaps some rest would be nice üí§'],
      default: ['Hello there üíï', 'Good to see you ‚ú®']
    }
  };
  
  const stageGreetings = greetings[state.stage] || greetings.BABY;
  let pool = stageGreetings.default;
  
  if (mood === 'hungry' && stageGreetings.hungry) pool = stageGreetings.hungry;
  else if (mood === 'sleepy' && stageGreetings.sleepy) pool = stageGreetings.sleepy;
  else if ((mood === 'happy' || mood === 'ecstatic') && stageGreetings.happy) pool = stageGreetings.happy;
  
  return pool[Math.floor(Math.random() * pool.length)];
}

function showBubble(text, duration = 0) {
  clearTimeout(bubbleTimeout);
  bubbleText.classList.remove('typing');
  bubbleText.textContent = text;
  speechBubbleContainer.classList.add('visible');
  
  // Re-trigger animation
  speechBubble.style.animation = 'none';
  speechBubble.offsetHeight; // Trigger reflow
  speechBubble.style.animation = 'bubblePop 0.3s ease-out';
  
  // Auto-hide after duration (if set)
  if (duration > 0) {
    bubbleTimeout = setTimeout(() => {
      if (!chatOpen) hideBubble();
    }, duration);
  }
}

function hideBubble() {
  clearTimeout(bubbleTimeout);
  speechBubbleContainer.classList.remove('visible');
}

function showTypingBubble() {
  bubbleText.textContent = 'Thinking';
  bubbleText.classList.add('typing');
  speechBubbleContainer.classList.add('visible');
}

function updateChatUI() {
  if (!state) return;
  const canChat = state.alive && state.stage !== 'EGG';
  
  chatToggle.classList.toggle('disabled', !canChat);
  chatInput.disabled = !canChat || isSending;
  chatSend.disabled = !canChat || isSending;
  
  if (!canChat && chatOpen) {
    closeChat();
  }
}

async function sendChatMessage() {
  const message = chatInput.value.trim();
  if (!message || isSending || !state || state.stage === 'EGG') return;
  
  chatInput.value = '';
  
  // Add to conversation history
  conversationHistory.push({ role: 'user', content: message });
  
  isSending = true;
  updateChatUI();
  showTypingBubble();
  
  try {
    // Add timeout for fetch request (30 seconds)
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);
    
    const response = await fetch(`${API_BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      signal: controller.signal,
      body: JSON.stringify({
        message,
        petState: {
          stage: state.stage,
          mood: getMood(),
          hunger: state.hunger,
          happiness: state.happiness,
          energy: state.energy,
          hygiene: state.hygiene,
          health: state.health,
          variant: state.variant,
          accessory: state.accessory,
          totalTime: state.totalTime,
          sleeping: state.sleeping
        },
        conversationHistory: conversationHistory.slice(-10)
      })
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      let errorMsg = `Server error: ${response.status}`;
      try {
        const error = await response.json();
        errorMsg = error.error || error.details || errorMsg;
      } catch (e) {
        // Response wasn't JSON, use status text
        errorMsg = response.statusText || errorMsg;
      }
      throw new Error(errorMsg);
    }
    
    const data = await response.json();
    
    // Show pet response in bubble
    showBubble(data.response);
    
    // Add to conversation history
    conversationHistory.push({ role: 'assistant', content: data.response });
    
    // Small happiness boost for chatting
    state.happiness = Math.min(100, state.happiness + 1);
    
    // Spawn heart particles
    for(let j=0;j<2;j++) spawnParticle(petX()+(Math.random()-0.5)*40, petY()-petSize()*0.5, 'üíï');
    
    // Speak the response (text-to-speech)
    speakText(data.response, state.stage);
    
    // Play cute pet sound based on stage and mood
    sfxPetSpeak(state.stage, getMood());
    
  } catch (error) {
    console.error('Chat error:', error);
    console.error('Chat error details:', {
      message: error.message,
      name: error.name,
      stack: error.stack
    });
    
    // Determine user-friendly error message
    let errorDescription = error.message;
    if (error.name === 'AbortError') {
      errorDescription = 'Request timed out - server may be slow';
    } else if (error.message === 'Failed to fetch' || error.message.includes('NetworkError')) {
      errorDescription = 'Cannot reach server - is it running?';
    }
    
    // Fallback responses based on stage with error hint in dev
    const fallbacks = {
      BABY: 'Me sleepy... hehe!',
      CHILD: 'Hmm, I got confused! Can you say that again?',
      TEEN: 'Ugh, something went wrong... whatever',
      ADULT: 'I apologize, I seem to be having trouble thinking clearly right now'
    };
    const fallbackMsg = fallbacks[state.stage] || 'Hmm...';
    showBubble(fallbackMsg);
    speakText(fallbackMsg, state.stage);
    
    // Show notification with actual error in development
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      notify(`Chat error: ${errorDescription}`, 5000);
    }
  }
  
  isSending = false;
  updateChatUI();
  chatInput.focus();
}

// Chat event listeners
chatToggle.addEventListener('click', toggleChat);
bubbleClose.addEventListener('click', closeChat);
chatSend.addEventListener('click', sendChatMessage);
chatInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendChatMessage();
  }
});

// Clear chat history on evolution
function clearChatOnEvolve() {
  conversationHistory = [];
  // Show evolution celebration bubble
  if (state.stage !== 'EGG') {
    const evolveMessages = {
      BABY: 'I hatched!! Hi hi! üê£üíï',
      CHILD: 'Wow I grew up! Look at me! üåü',
      TEEN: 'Whoa... I feel different! üòé‚ú®',
      ADULT: 'I have reached my final form! Thank you for everything üí´üå∏'
    };
    setTimeout(() => showBubble(evolveMessages[state.stage] || 'I evolved! ‚ú®', 5000), 1500);
  }
}

// ============================================================
// INIT
// ============================================================
function init(){
  if(!load()) state=newState();
  else applyOfflineDecay();
  updateHUD();
  updateChatUI();
  buildFeedPanel();
  buildDressPanel();
  initTTS();

  document.addEventListener('visibilitychange',()=>{if(document.hidden) save();});
  window.addEventListener('beforeunload',save);

  requestAnimationFrame(gameLoop);
}

init();

})();
</script>
</body>
</html>
