<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Tamagotchi AI - Virtual Pet</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;touch-action:manipulation;user-select:none;-webkit-user-select:none;background:#0a0a1a;}
canvas#game{position:fixed;top:0;left:0;width:100%;height:100%;display:block;}

/* ---- Top HUD ---- */
#hud{position:fixed;top:0;left:0;right:0;padding:12px 16px;display:flex;align-items:center;gap:10px;z-index:10;pointer-events:none;}
#mood-badge{background:rgba(255,255,255,0.15);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.1);border-radius:20px;padding:4px 14px;font-size:13px;color:#fff;letter-spacing:0.5px;text-transform:uppercase;pointer-events:auto;}
#stage-badge{margin-left:auto;background:rgba(255,255,255,0.12);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.08);border-radius:20px;padding:4px 14px;font-size:13px;color:rgba(255,255,255,0.8);pointer-events:auto;}
#age-badge{background:rgba(255,255,255,0.08);border-radius:20px;padding:4px 10px;font-size:11px;color:rgba(255,255,255,0.5);}

/* ---- Stat bars ---- */
#stats-bar{position:fixed;top:52px;left:0;right:0;padding:0 16px;display:flex;gap:6px;z-index:10;pointer-events:none;}
.stat{flex:1;display:flex;flex-direction:column;gap:2px;}
.stat-label{font-size:9px;color:rgba(255,255,255,0.5);text-transform:uppercase;letter-spacing:0.5px;text-align:center;}
.stat-track{height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;}
.stat-fill{height:100%;border-radius:2px;transition:width 0.5s ease;}
.stat-fill.hunger{background:linear-gradient(90deg,#ff6b6b,#ffa502);}
.stat-fill.happy{background:linear-gradient(90deg,#ffd93d,#ff9ff3);}
.stat-fill.energy{background:linear-gradient(90deg,#48dbfb,#0abde3);}
.stat-fill.hygiene{background:linear-gradient(90deg,#55efc4,#00b894);}
.stat-fill.health{background:linear-gradient(90deg,#fd79a8,#e84393);}

/* ---- Bottom action bar ---- */
#actions{position:fixed;bottom:0;left:0;right:0;padding:12px 8px;padding-bottom:max(12px,env(safe-area-inset-bottom));display:flex;justify-content:center;gap:6px;z-index:10;}
.action-btn{display:flex;flex-direction:column;align-items:center;gap:4px;background:rgba(255,255,255,0.1);backdrop-filter:blur(16px);-webkit-backdrop-filter:blur(16px);border:1px solid rgba(255,255,255,0.08);border-radius:16px;padding:10px 10px 8px;cursor:pointer;transition:all 0.2s;min-width:46px;-webkit-tap-highlight-color:transparent;}
.action-btn:hover{background:rgba(255,255,255,0.18);transform:translateY(-2px);}
.action-btn:active{transform:scale(0.92);background:rgba(255,255,255,0.25);}
.action-btn .icon{font-size:22px;line-height:1;}
.action-btn .label{font-size:9px;color:rgba(255,255,255,0.6);text-transform:uppercase;letter-spacing:0.5px;}
.action-btn.disabled{opacity:0.35;pointer-events:none;}

/* ---- Notification toast ---- */
#notif{position:fixed;top:85px;left:50%;transform:translateX(-50%) translateY(-20px);background:rgba(0,0,0,0.75);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 20px;border-radius:24px;font-size:13px;opacity:0;transition:all 0.35s cubic-bezier(0.4,0,0.2,1);pointer-events:none;z-index:20;white-space:nowrap;}
#notif.show{opacity:1;transform:translateX(-50%) translateY(0);}

/* ---- Overlay panels ---- */
.panel{position:fixed;inset:0;z-index:30;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(10,10,26,0.92);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);opacity:0;pointer-events:none;transition:opacity 0.3s;}
.panel.open{opacity:1;pointer-events:auto;}
.panel-title{font-size:18px;font-weight:700;color:#fff;margin-bottom:20px;letter-spacing:1px;}
.panel-close{position:absolute;top:16px;right:16px;width:36px;height:36px;background:rgba(255,255,255,0.1);border:none;border-radius:50%;color:#fff;font-size:20px;cursor:pointer;display:flex;align-items:center;justify-content:center;}
.panel-close:hover{background:rgba(255,255,255,0.2);}

/* Feed panel */
#feed-panel .food-grid{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;padding:0 20px;}
.food-card{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:16px 14px 12px;cursor:pointer;transition:all 0.2s;text-align:center;width:100px;}
.food-card:hover{background:rgba(255,255,255,0.15);transform:translateY(-3px);border-color:rgba(255,255,255,0.25);}
.food-card:active{transform:scale(0.95);}
.food-card .food-icon{font-size:32px;margin-bottom:6px;}
.food-card .food-name{font-size:12px;color:#fff;font-weight:600;margin-bottom:4px;}
.food-card .food-stat{font-size:9px;color:rgba(255,255,255,0.5);line-height:1.5;}
.food-card .food-stat span.pos{color:#55efc4;}
.food-card .food-stat span.neg{color:#ff6b6b;}

/* Play panel */
#play-panel .game-list{display:flex;flex-direction:column;gap:10px;width:280px;}
.game-card{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:16px 20px;cursor:pointer;transition:all 0.2s;display:flex;align-items:center;gap:14px;}
.game-card:hover{background:rgba(255,255,255,0.15);transform:translateX(4px);border-color:rgba(255,255,255,0.25);}
.game-card:active{transform:scale(0.97);}
.game-card .game-icon{font-size:28px;}
.game-card .game-info{display:flex;flex-direction:column;gap:2px;}
.game-card .game-name{font-size:14px;color:#fff;font-weight:600;}
.game-card .game-desc{font-size:11px;color:rgba(255,255,255,0.5);}

/* Dress panel */
#dress-panel .acc-grid{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;padding:0 20px;}
.acc-card{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:14px;padding:12px 16px;cursor:pointer;transition:all 0.2s;text-align:center;min-width:70px;}
.acc-card:hover{background:rgba(255,255,255,0.15);}
.acc-card:active{transform:scale(0.95);}
.acc-card.active-acc{border-color:rgba(255,220,100,0.6);background:rgba(255,220,100,0.1);}
.acc-card.locked{opacity:0.3;pointer-events:none;}
.acc-card.math-locked{opacity:0.85;border-color:rgba(255,200,100,0.4);background:rgba(255,200,100,0.08);cursor:pointer;}
.acc-card.math-locked:hover{background:rgba(255,200,100,0.15);transform:translateY(-2px);}
.acc-card .acc-icon{font-size:24px;margin-bottom:4px;}
.acc-card .acc-name{font-size:10px;color:rgba(255,255,255,0.7);}
.acc-card .acc-level{font-size:8px;color:rgba(255,200,100,0.7);margin-top:2px;}

/* House panel */
#home-panel .home-tabs{display:flex;gap:0;margin-bottom:16px;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,0.1);}
.home-tab{flex:1;padding:10px 16px;background:rgba(255,255,255,0.05);color:rgba(255,255,255,0.5);border:none;font-size:13px;font-weight:600;cursor:pointer;transition:all 0.2s;text-align:center;}
.home-tab.active{background:rgba(255,255,255,0.15);color:#fff;}
.home-tab:hover{background:rgba(255,255,255,0.1);}
#home-panel .home-section{display:none;width:100%;}
#home-panel .home-section.active{display:block;}
#home-panel .house-grid,#home-panel .land-grid{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;padding:0 20px;max-width:380px;}
.house-card,.land-card{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:14px;padding:12px 14px;cursor:pointer;transition:all 0.2s;text-align:center;min-width:70px;width:80px;}
.house-card:hover,.land-card:hover{background:rgba(255,255,255,0.15);transform:translateY(-2px);}
.house-card:active,.land-card:active{transform:scale(0.95);}
.house-card.active-house,.land-card.active-land{border-color:rgba(100,200,255,0.6);background:rgba(100,200,255,0.1);}
.house-card.math-locked{opacity:0.85;border-color:rgba(255,200,100,0.4);background:rgba(255,200,100,0.08);cursor:pointer;}
.house-card.math-locked:hover{background:rgba(255,200,100,0.15);transform:translateY(-2px);}
.house-card .house-icon,.land-card .land-icon{font-size:24px;margin-bottom:4px;}
.house-card .house-name,.land-card .land-name{font-size:10px;color:rgba(255,255,255,0.7);}
.house-card .house-level{font-size:8px;color:rgba(255,200,100,0.7);margin-top:2px;}

/* Friends section */
#friends-section{padding:0 20px;max-width:380px;width:100%;}
.friend-code-box{display:flex;align-items:center;gap:8px;margin-bottom:16px;}
.friend-code-box .code-display{flex:1;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);border-radius:10px;padding:10px 14px;font-size:18px;font-weight:700;color:#fff;font-family:monospace;letter-spacing:2px;text-align:center;}
.friend-code-box .copy-btn{background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.15);border-radius:10px;padding:10px 14px;color:#fff;font-size:13px;cursor:pointer;transition:all 0.2s;white-space:nowrap;}
.friend-code-box .copy-btn:hover{background:rgba(255,255,255,0.2);}
.friend-code-box .copy-btn:active{transform:scale(0.95);}
.friend-invite{display:flex;gap:8px;margin-bottom:16px;}
.friend-invite input{flex:1;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);border-radius:10px;padding:10px 14px;color:#fff;font-size:14px;font-family:monospace;outline:none;}
.friend-invite input::placeholder{color:rgba(255,255,255,0.3);}
.friend-invite .add-btn{background:rgba(100,200,255,0.15);border:1px solid rgba(100,200,255,0.3);border-radius:10px;padding:10px 14px;color:#fff;font-size:13px;cursor:pointer;transition:all 0.2s;white-space:nowrap;}
.friend-invite .add-btn:hover{background:rgba(100,200,255,0.25);}
.friend-invite .add-btn:active{transform:scale(0.95);}
.visitor-card{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:14px;padding:14px;display:flex;align-items:center;gap:12px;}
.visitor-card .visitor-info{flex:1;color:rgba(255,255,255,0.7);font-size:13px;}
.visitor-card .visitor-info strong{color:#fff;font-size:14px;}
.visitor-card .dismiss-btn{background:rgba(255,107,107,0.15);border:1px solid rgba(255,107,107,0.3);border-radius:10px;padding:8px 12px;color:#ff6b6b;font-size:12px;cursor:pointer;transition:all 0.2s;}
.visitor-card .dismiss-btn:hover{background:rgba(255,107,107,0.25);}
.friend-label{font-size:12px;color:rgba(255,255,255,0.4);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;}

/* Math riddle modal */
#math-modal{position:fixed;inset:0;z-index:50;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(10,10,26,0.95);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);opacity:0;pointer-events:none;transition:opacity 0.3s;}
#math-modal.open{opacity:1;pointer-events:auto;}
#math-modal .modal-content{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:24px;padding:30px;text-align:center;max-width:340px;width:90%;}
#math-modal .prize-emoji{font-size:48px;margin-bottom:10px;}
#math-modal .prize-name{font-size:18px;font-weight:700;color:#fff;margin-bottom:4px;}
#math-modal .difficulty-label{font-size:11px;color:rgba(255,200,100,0.8);text-transform:uppercase;letter-spacing:1px;margin-bottom:20px;}
#math-modal .question{font-size:28px;font-weight:700;color:#fff;margin-bottom:24px;font-family:monospace;}
#math-modal .choices{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:16px;}
#math-modal .choice-btn{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.15);border-radius:12px;padding:14px;font-size:20px;font-weight:600;color:#fff;cursor:pointer;transition:all 0.2s;}
#math-modal .choice-btn:hover{background:rgba(255,255,255,0.2);border-color:rgba(255,255,255,0.3);transform:scale(1.03);}
#math-modal .choice-btn:active{transform:scale(0.97);}
#math-modal .choice-btn.correct{background:rgba(85,239,196,0.3);border-color:#55efc4;color:#55efc4;}
#math-modal .choice-btn.wrong{background:rgba(255,107,107,0.3);border-color:#ff6b6b;color:#ff6b6b;}
#math-modal .choice-btn:disabled{pointer-events:none;}
#math-modal .feedback{font-size:14px;color:rgba(255,255,255,0.6);min-height:20px;margin-bottom:12px;}
#math-modal .feedback.success{color:#55efc4;}
#math-modal .feedback.error{color:#ff6b6b;}
#math-modal .modal-close{background:rgba(255,255,255,0.1);border:none;border-radius:20px;padding:10px 24px;color:#fff;font-size:13px;cursor:pointer;transition:all 0.2s;}
#math-modal .modal-close:hover{background:rgba(255,255,255,0.2);}

/* Stats panel */
#stats-panel .stats-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;padding:0 20px;width:320px;max-width:90vw;}
.stat-card{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:12px;text-align:center;}
.stat-card .stat-val{font-size:22px;font-weight:700;color:#fff;}
.stat-card .stat-lbl{font-size:10px;color:rgba(255,255,255,0.4);text-transform:uppercase;margin-top:2px;}
.stat-card.wide{grid-column:span 2;}
.evo-bar{width:100%;height:6px;background:rgba(255,255,255,0.1);border-radius:3px;margin-top:8px;overflow:hidden;}
.evo-fill{height:100%;background:linear-gradient(90deg,#a29bfe,#6c5ce7);border-radius:3px;transition:width 0.5s;}

/* Minigame overlay */
#minigame-overlay{position:fixed;inset:0;z-index:40;display:none;flex-direction:column;align-items:center;justify-content:center;}
#minigame-overlay.open{display:flex;}
#mg-canvas{border-radius:16px;max-width:90vw;max-height:70vh;image-rendering:pixelated;image-rendering:crisp-edges;}
#mg-hud{position:fixed;top:16px;left:50%;transform:translateX(-50%);display:flex;gap:12px;align-items:center;}
#mg-score{background:rgba(0,0,0,0.6);backdrop-filter:blur(8px);border-radius:20px;padding:6px 16px;color:#fff;font-size:14px;font-weight:600;}
#mg-quit{position:fixed;top:16px;right:16px;width:36px;height:36px;background:rgba(255,255,255,0.15);border:none;border-radius:50%;color:#fff;font-size:18px;cursor:pointer;}

/* Pet interaction hint */
#pet-hint{position:fixed;bottom:120px;left:50%;transform:translateX(-50%);color:rgba(255,255,255,0.25);font-size:11px;pointer-events:none;z-index:5;transition:opacity 0.5s;letter-spacing:0.5px;}

/* Floating hearts/particles */
.float-particle{position:fixed;pointer-events:none;z-index:15;font-size:18px;animation:floatUp 1.2s ease-out forwards;}
@keyframes floatUp{0%{opacity:1;transform:translateY(0) scale(1);}100%{opacity:0;transform:translateY(-60px) scale(0.5);}}

/* ---- Chat UI - Speech Bubble ---- */
#chat-toggle{position:fixed;left:calc(50% + 140px);top:calc(55vh - 26px);width:52px;height:52px;border-radius:50%;background:linear-gradient(135deg,#667eea,#764ba2);border:none;color:#fff;font-size:24px;cursor:pointer;z-index:25;box-shadow:0 4px 15px rgba(102,126,234,0.4);transition:all 0.3s;display:flex;align-items:center;justify-content:center;}
#chat-toggle:hover{transform:scale(1.1);box-shadow:0 6px 20px rgba(102,126,234,0.5);}
#chat-toggle:active{transform:scale(0.95);}
#chat-toggle.has-unread::after{content:'';position:absolute;top:2px;right:2px;width:12px;height:12px;background:#ff6b6b;border-radius:50%;border:2px solid #0a0a1a;}
#chat-toggle.disabled{opacity:0.4;pointer-events:none;}

#tts-toggle{position:fixed;left:calc(50% + 140px);top:calc(55vh + 35px);width:44px;height:44px;border-radius:50%;background:linear-gradient(135deg,#4ade80,#22c55e);border:none;color:#fff;font-size:20px;cursor:pointer;z-index:25;box-shadow:0 4px 15px rgba(74,222,128,0.4);transition:all 0.3s;display:flex;align-items:center;justify-content:center;}
#tts-toggle:hover{background:rgba(255,255,255,0.25);transform:scale(1.1);}
#tts-toggle:active{transform:scale(0.95);}
#tts-toggle.muted{opacity:0.5;}

/* Speech bubble container - positioned above pet */
#speech-bubble-container{position:fixed;left:50%;transform:translateX(-50%);top:18%;z-index:25;pointer-events:none;opacity:0;transition:opacity 0.3s ease;}
#speech-bubble-container.visible{opacity:1;pointer-events:auto;}

/* The cute speech bubble */
#speech-bubble{position:relative;background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border-radius:20px;padding:14px 18px;max-width:280px;min-width:120px;box-shadow:0 8px 32px rgba(0,0,0,0.3);animation:bubblePop 0.3s ease-out;}
#speech-bubble::after{content:'';position:absolute;bottom:-12px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-top:14px solid rgba(255,255,255,0.95);}
@keyframes bubblePop{0%{transform:scale(0.8);opacity:0;}50%{transform:scale(1.05);}100%{transform:scale(1);opacity:1;}}

#speech-bubble .bubble-text{color:#1a1a2e;font-size:14px;line-height:1.5;text-align:center;word-wrap:break-word;}
#speech-bubble .bubble-text.typing{color:#666;}
#speech-bubble .bubble-text.typing::after{content:'...';animation:dots 1.5s infinite;}
@keyframes dots{0%,20%{content:'.';}40%{content:'..';}60%,100%{content:'...';}}

/* Close bubble button */
#bubble-close{position:absolute;top:-8px;right:-8px;width:24px;height:24px;border-radius:50%;background:#ff6b6b;border:2px solid #fff;color:#fff;font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(0,0,0,0.2);transition:transform 0.2s;}
#bubble-close:hover{transform:scale(1.1);}

/* Chat input bar at bottom */
#chat-input-bar{position:fixed;bottom:85px;left:50%;transform:translateX(-50%);width:90%;max-width:360px;z-index:25;display:flex;gap:8px;opacity:0;pointer-events:none;transition:all 0.3s ease;}
#chat-input-bar.visible{opacity:1;pointer-events:auto;}

#chat-input{flex:1;background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border:none;border-radius:25px;padding:12px 20px;color:#1a1a2e;font-size:14px;outline:none;box-shadow:0 4px 20px rgba(0,0,0,0.2);transition:all 0.2s;}
#chat-input::placeholder{color:#888;}
#chat-input:focus{box-shadow:0 4px 25px rgba(102,126,234,0.4);}

#chat-send{width:46px;height:46px;border-radius:50%;background:linear-gradient(135deg,#667eea,#764ba2);border:none;color:#fff;font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 15px rgba(102,126,234,0.4);transition:all 0.2s;}
#chat-send:hover{transform:scale(1.08);}
#chat-send:active{transform:scale(0.95);}
#chat-send:disabled{opacity:0.5;pointer-events:none;}

/* Emoji reactions floating up */
.bubble-emoji{position:absolute;font-size:20px;animation:emojiFloat 2s ease-out forwards;pointer-events:none;}
@keyframes emojiFloat{0%{opacity:1;transform:translateY(0) scale(1);}100%{opacity:0;transform:translateY(-50px) scale(0.5);}}
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud">
  <div id="mood-badge">...</div>
  <div id="age-badge">0m</div>
  <div id="stage-badge">EGG</div>
</div>
<div id="stats-bar">
  <div class="stat"><div class="stat-label">Hunger</div><div class="stat-track"><div class="stat-fill hunger" id="bar-hunger"></div></div></div>
  <div class="stat"><div class="stat-label">Happy</div><div class="stat-track"><div class="stat-fill happy" id="bar-happy"></div></div></div>
  <div class="stat"><div class="stat-label">Energy</div><div class="stat-track"><div class="stat-fill energy" id="bar-energy"></div></div></div>
  <div class="stat"><div class="stat-label">Hygiene</div><div class="stat-track"><div class="stat-fill hygiene" id="bar-hygiene"></div></div></div>
  <div class="stat"><div class="stat-label">Health</div><div class="stat-track"><div class="stat-fill health" id="bar-health"></div></div></div>
</div>

<!-- Action bar -->
<div id="actions">
  <div class="action-btn" data-action="feed"><span class="icon">üçé</span><span class="label">Feed</span></div>
  <div class="action-btn" data-action="play"><span class="icon">üéÆ</span><span class="label">Play</span></div>
  <div class="action-btn" data-action="clean"><span class="icon">üßπ</span><span class="label">Clean</span></div>
  <div class="action-btn" data-action="dress"><span class="icon">üëí</span><span class="label">Dress</span></div>
  <div class="action-btn" data-action="home"><span class="icon">üè†</span><span class="label">Home</span></div>
  <div class="action-btn" data-action="sleep"><span class="icon">üí§</span><span class="label">Sleep</span></div>
  <div class="action-btn" data-action="stats"><span class="icon">üìä</span><span class="label">Stats</span></div>
</div>

<!-- Pet hint -->
<div id="pet-hint">Tap your pet to show love</div>

<!-- Notification -->
<div id="notif"></div>

<!-- FEED PANEL -->
<div class="panel" id="feed-panel">
  <button class="panel-close" onclick="closePanel('feed')">&times;</button>
  <div class="panel-title">Choose Food</div>
  <div class="food-grid" id="food-grid"></div>
</div>

<!-- PLAY PANEL -->
<div class="panel" id="play-panel">
  <button class="panel-close" onclick="closePanel('play')">&times;</button>
  <div class="panel-title">Mini-Games</div>
  <div class="game-list">
    <div class="game-card" onclick="startGame('guess')"><span class="game-icon">üß≠</span><div class="game-info"><div class="game-name">Guess Direction</div><div class="game-desc">Remember which way the arrow points</div></div></div>
    <div class="game-card" onclick="startGame('memory')"><span class="game-icon">üÉè</span><div class="game-info"><div class="game-name">Memory Match</div><div class="game-desc">Find all matching pairs</div></div></div>
    <div class="game-card" onclick="startGame('dodge')"><span class="game-icon">üí®</span><div class="game-info"><div class="game-name">Dodge</div><div class="game-desc">Avoid falling obstacles</div></div></div>
  </div>
</div>

<!-- DRESS PANEL -->
<div class="panel" id="dress-panel">
  <button class="panel-close" onclick="closePanel('dress')">&times;</button>
  <div class="panel-title">Accessories</div>
  <div class="acc-grid" id="acc-grid"></div>
</div>

<!-- HOME PANEL -->
<div class="panel" id="home-panel">
  <button class="panel-close" onclick="closePanel('home')">&times;</button>
  <div class="panel-title">My Home</div>
  <div class="home-tabs">
    <button class="home-tab active" onclick="switchHomeTab('houses')">üè† Houses</button>
    <button class="home-tab" onclick="switchHomeTab('landscape')">üåÑ Landscape</button>
    <button class="home-tab" onclick="switchHomeTab('friends')">üë´ Friends</button>
  </div>
  <div class="home-section active" id="houses-section">
    <div class="house-grid" id="house-grid"></div>
  </div>
  <div class="home-section" id="landscape-section">
    <div class="land-grid" id="land-grid"></div>
  </div>
  <div class="home-section" id="friends-section">
    <div class="friend-label">Your Code</div>
    <div class="friend-code-box">
      <div class="code-display" id="my-pet-code">---</div>
      <button class="copy-btn" onclick="copyPetCode()">üìã Copy</button>
    </div>
    <div class="friend-label">Invite Friend</div>
    <div class="friend-invite">
      <input type="text" id="friend-code-input" placeholder="PET-XXXX" maxlength="8">
      <button class="add-btn" onclick="addVisitorFromCode()">Add</button>
    </div>
    <div id="visitor-card-container"></div>
  </div>
</div>

<!-- STATS PANEL -->
<div class="panel" id="stats-panel">
  <button class="panel-close" onclick="closePanel('stats')">&times;</button>
  <div class="panel-title">Pet Stats</div>
  <div class="stats-grid" id="stats-grid"></div>
</div>

<!-- MATH RIDDLE MODAL -->
<div id="math-modal">
  <div class="modal-content">
    <div class="prize-emoji" id="math-prize-emoji">üéÅ</div>
    <div class="prize-name" id="math-prize-name">Prize</div>
    <div class="difficulty-label" id="math-difficulty">Level 1</div>
    <div class="question" id="math-question">5 + 3 = ?</div>
    <div class="choices" id="math-choices"></div>
    <div class="feedback" id="math-feedback"></div>
    <button class="modal-close" onclick="closeMathModal()">Close</button>
  </div>
</div>

<!-- MINIGAME OVERLAY -->
<div id="minigame-overlay">
  <div id="mg-hud"><div id="mg-score">Score: 0</div></div>
  <button id="mg-quit" onclick="quitMiniGame()">&times;</button>
  <canvas id="mg-canvas" width="240" height="200"></canvas>
</div>

<!-- CHAT UI - Speech Bubble -->
<button id="chat-toggle" class="disabled" title="Chat with your pet">üí¨</button>
<button id="tts-toggle" title="Toggle voice" onclick="toggleTTS()">üîä</button>

<!-- Speech bubble above pet -->
<div id="speech-bubble-container">
  <div id="speech-bubble">
    <button id="bubble-close">&times;</button>
    <div class="bubble-text">Hi there! üíï</div>
  </div>
</div>

<!-- Chat input bar -->
<div id="chat-input-bar">
  <input type="text" id="chat-input" placeholder="Say something to your pet..." disabled>
  <button id="chat-send" disabled>üí¨</button>
</div>

<script>
(function(){
"use strict";

// ============================================================
// CONSTANTS
// ============================================================
const SAVE_KEY = 'tamagotchi_ai_save_v2';
const AUTO_SAVE_MS = 30000;
const MAX_OFFLINE_MS = 8 * 3600 * 1000;

const STAGES = {
  EGG:   { dur: 5 },  // 5 seconds for testing
  BABY:  { dur: 1800 },  // 30 minutes
  CHILD: { dur: 3600 },  // 60 minutes
  TEEN:  { dur: 5400 },  // 90 minutes
  ADULT: { dur: Infinity }
};

const DECAY = { hunger:0.08, happiness:0.05, energy:0.04, hygiene:0.06, health:0.02 };

const FOODS = [
  { name:'Apple',  emoji:'üçé', hunger:25, happiness:5,  health:5,  energy:5 },
  { name:'Cake',   emoji:'üç∞', hunger:15, happiness:25, health:-5, energy:10 },
  { name:'Soup',   emoji:'üçú', hunger:35, happiness:5,  health:10, energy:5 },
  { name:'Vitamin',emoji:'üíä', hunger:5,  happiness:-5, health:30, energy:5 },
  { name:'Candy',  emoji:'üç¨', hunger:10, happiness:30, health:-10,energy:15 }
];

const ACCESSORIES = [
  // Stage-locked accessories
  { name:'None',    emoji:'‚ùå', stage:0, id:0 },
  { name:'Bow',     emoji:'üéÄ', stage:1, id:1, type:'head' },
  { name:'Flower',  emoji:'üå∏', stage:1, id:5, type:'head' },
  { name:'Top Hat', emoji:'üé©', stage:2, id:2, type:'head' },
  { name:'Bandana', emoji:'üß£', stage:2, id:4, type:'scarf' },
  { name:'Crown',   emoji:'üëë', stage:3, id:3, type:'head' },
  { name:'Glasses', emoji:'üëì', stage:3, id:6, type:'glasses' },
  { name:'Halo',    emoji:'üòá', stage:4, id:7, type:'floating' },
  // Math-locked accessories (K-4 grade levels)
  { name:'Sunglasses', emoji:'üòé', mathLevel:1, id:8, type:'sunglasses' },
  { name:'Party Hat',  emoji:'ü•≥', mathLevel:1, id:9, type:'head' },
  { name:'Headphones', emoji:'üéß', mathLevel:1, id:10, type:'headphones' },
  { name:'Star',       emoji:'‚≠ê', mathLevel:2, id:11, type:'floating' },
  { name:'Rainbow',    emoji:'üåà', mathLevel:2, id:12, type:'floating' },
  { name:'Rocket',     emoji:'üöÄ', mathLevel:2, id:13, type:'floating' },
  { name:'Diamond',    emoji:'üíé', mathLevel:3, id:14, type:'floating' },
  { name:'Fire',       emoji:'üî•', mathLevel:3, id:15, type:'floating' },
  { name:'Lightning',  emoji:'‚ö°', mathLevel:3, id:16, type:'floating' },
  { name:'Unicorn',    emoji:'ü¶Ñ', mathLevel:4, id:17, type:'floating' },
  { name:'Dragon',     emoji:'üêâ', mathLevel:4, id:18, type:'floating' },
  { name:'Alien',      emoji:'üëΩ', mathLevel:4, id:19, type:'floating' }
];

const HOUSES = [
  { name:'None',         emoji:'‚ùå', id:0 },
  { name:'Tent',         emoji:'‚õ∫', mathLevel:1, id:1 },
  { name:'Cottage',      emoji:'üè°', mathLevel:1, id:2 },
  { name:'Cabin',        emoji:'üõñ', mathLevel:1, id:3 },
  { name:'Treehouse',    emoji:'üå≥', mathLevel:2, id:4 },
  { name:'Castle',       emoji:'üè∞', mathLevel:2, id:5 },
  { name:'Igloo',        emoji:'üßä', mathLevel:2, id:6 },
  { name:'Spaceship',    emoji:'üõ∏', mathLevel:3, id:7 },
  { name:'Mushroom',     emoji:'üçÑ', mathLevel:3, id:8 },
  { name:'Cloud Palace', emoji:'‚òÅÔ∏è', mathLevel:4, id:9 },
  { name:'Crystal',      emoji:'üíé', mathLevel:4, id:10 }
];

const LANDSCAPES = [
  { name:'Night Sky',    emoji:'üåô', id:0 },
  { name:'Green Meadow', emoji:'üåø', id:1 },
  { name:'Desert',       emoji:'üèúÔ∏è', id:2 },
  { name:'Clouds',       emoji:'‚òÅÔ∏è', id:3 },
  { name:'Snow',         emoji:'‚ùÑÔ∏è', id:4 },
  { name:'Beach',        emoji:'üèñÔ∏è', id:5 },
  { name:'Forest',       emoji:'üå≤', id:6 },
  { name:'Space',        emoji:'üöÄ', id:7 }
];

// Garden elements per landscape
const GARDEN_ELEMENTS = {
  0: [ // Night Sky - Moonlit garden
    { x:0.15, emoji:'üçÑ', label:'mushroom', glow:'#7B68EE' },
    { x:0.30, emoji:'üå∏', label:'moon flower', glow:'#DDA0DD' },
    { x:0.70, emoji:'üçÑ', label:'mushroom', glow:'#9370DB' },
    { x:0.85, emoji:'üå∫', label:'moon flower', glow:'#DA70D6' },
  ],
  1: [ // Green Meadow - Classic garden
    { x:0.12, emoji:'üåª', label:'flower bed' },
    { x:0.28, emoji:'üöø', label:'watering can' },
    { x:0.72, emoji:'ü•ï', label:'veggie patch' },
    { x:0.88, emoji:'üå∑', label:'flower bed' },
  ],
  2: [ // Desert - Succulent garden
    { x:0.14, emoji:'ü™¥', label:'succulent' },
    { x:0.32, emoji:'ü™®', label:'rock garden' },
    { x:0.70, emoji:'üíß', label:'small oasis' },
    { x:0.86, emoji:'ü™¥', label:'succulent' },
  ],
  3: [ // Clouds - Sky garden
    { x:0.15, emoji:'üåà', label:'rainbow plant' },
    { x:0.35, emoji:'üíÆ', label:'cloud flower' },
    { x:0.65, emoji:'üíÆ', label:'cloud flower' },
    { x:0.85, emoji:'üåà', label:'rainbow plant' },
  ],
  4: [ // Snow - Ice garden
    { x:0.13, emoji:'‚ùÑÔ∏è', label:'crystal flower' },
    { x:0.30, emoji:'üíé', label:'ice sculpture' },
    { x:0.70, emoji:'üíé', label:'ice sculpture' },
    { x:0.87, emoji:'‚ùÑÔ∏è', label:'crystal flower' },
  ],
  5: [ // Beach - Tropical garden
    { x:0.14, emoji:'üêö', label:'shell planter' },
    { x:0.32, emoji:'ü™∏', label:'coral garden' },
    { x:0.68, emoji:'ü´ß', label:'tide pool' },
    { x:0.86, emoji:'üêö', label:'shell planter' },
  ],
  6: [ // Forest - Fairy garden
    { x:0.12, emoji:'üçÑ', label:'mushroom ring' },
    { x:0.30, emoji:'üåø', label:'moss patch' },
    { x:0.70, emoji:'üåø', label:'fern bed' },
    { x:0.88, emoji:'üçÑ', label:'mushroom ring' },
  ],
  7: [ // Space - Alien garden
    { x:0.13, emoji:'üëæ', label:'alien plant', glow:'#00FF88' },
    { x:0.32, emoji:'üîÆ', label:'crystal pod', glow:'#FF00FF' },
    { x:0.68, emoji:'üåÄ', label:'space vine', glow:'#00BFFF' },
    { x:0.87, emoji:'üëæ', label:'alien plant', glow:'#00FF88' },
  ]
};

// Color themes per mood
const THEMES = {
  ecstatic: { bg1:'#0f0c29', bg2:'#302b63', bg3:'#24243e', ground:'#1a1a3e', stars:true },
  happy:    { bg1:'#141e30', bg2:'#243b55', bg3:'#1a2a44', ground:'#152238', stars:true },
  neutral:  { bg1:'#0f0c29', bg2:'#1a1a3e', bg3:'#16163a', ground:'#111133', stars:true },
  sad:      { bg1:'#0d0d2b', bg2:'#1b1b3a', bg3:'#151535', ground:'#0e0e28', stars:false },
  hungry:   { bg1:'#1a0a0a', bg2:'#2d1515', bg3:'#251010', ground:'#1a0a0a', stars:false },
  sleepy:   { bg1:'#050510', bg2:'#0a0a20', bg3:'#080818', ground:'#05050f', stars:true },
  dirty:    { bg1:'#1a1a0a', bg2:'#25250f', bg3:'#20200d', ground:'#15150a', stars:false },
  sick:     { bg1:'#1a0a1a', bg2:'#2d152d', bg3:'#251025', ground:'#1a0a1a', stars:false },
  dead:     { bg1:'#0a0a0a', bg2:'#151515', bg3:'#101010', ground:'#0a0a0a', stars:false }
};

// ============================================================
// CANVAS
// ============================================================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let cw, ch;

function resize() {
  cw = canvas.width = window.innerWidth * devicePixelRatio;
  ch = canvas.height = window.innerHeight * devicePixelRatio;
  ctx.scale(devicePixelRatio, devicePixelRatio);
}
window.addEventListener('resize', resize);
resize();

const vw = () => window.innerWidth;
const vh = () => window.innerHeight;

// ============================================================
// PARTICLES
// ============================================================
let particles = [];

function spawnParticle(x, y, emoji, vx, vy) {
  particles.push({ x, y, vx: vx||((Math.random()-0.5)*2), vy: vy||(-(2+Math.random()*2)), life:1, emoji: emoji||'‚ù§Ô∏è', size:18+Math.random()*10 });
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.03;
    p.life -= dt * 0.001;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.font = Math.round(p.size * p.life) + 'px sans-serif';
    ctx.fillText(p.emoji, p.x, p.y);
  }
  ctx.globalAlpha = 1;
}

// ============================================================
// STARS
// ============================================================
let stars = [];
for (let i = 0; i < 80; i++) {
  stars.push({ x: Math.random(), y: Math.random(), s: 0.5 + Math.random() * 1.5, twinkle: Math.random() * Math.PI * 2 });
}

function drawStars(t) {
  for (const s of stars) {
    const a = 0.3 + 0.7 * Math.abs(Math.sin(t * 0.001 + s.twinkle));
    ctx.globalAlpha = a * 0.6;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(s.x * vw(), s.y * vh() * 0.6, s.s, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ============================================================
// BACKGROUND
// ============================================================
function drawBackground(t, mood) {
  const theme = THEMES[mood] || THEMES.neutral;
  const w = vw(), h = vh();

  // Sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, h);
  grad.addColorStop(0, theme.bg1);
  grad.addColorStop(0.5, theme.bg2);
  grad.addColorStop(0.8, theme.bg3);
  grad.addColorStop(1, theme.ground);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, w, h);

  // Stars
  if (theme.stars) drawStars(t);

  // Ground
  const gy = h * 0.72;
  ctx.fillStyle = theme.ground;
  ctx.beginPath();
  ctx.moveTo(0, gy);
  for (let x = 0; x <= w; x += 20) {
    ctx.lineTo(x, gy + Math.sin(x * 0.02 + t * 0.0005) * 4);
  }
  ctx.lineTo(w, h);
  ctx.lineTo(0, h);
  ctx.closePath();
  ctx.fill();

  // Subtle ground highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, gy);
  for (let x = 0; x <= w; x += 20) {
    ctx.lineTo(x, gy + Math.sin(x * 0.02 + t * 0.0005) * 4);
  }
  ctx.stroke();

  // Moon (when sleeping)
  if (mood === 'sleepy') {
    ctx.fillStyle = 'rgba(255,255,200,0.15)';
    ctx.beginPath();
    ctx.arc(w * 0.8, h * 0.12, 40, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,200,0.25)';
    ctx.beginPath();
    ctx.arc(w * 0.8, h * 0.12, 30, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ============================================================
// PET DRAWING (on main canvas, not pixel art)
// ============================================================
const petSize = () => Math.min(vw(), vh()) * 0.22;
let gardenPetOffsetX = 0; // offset from center for garden wandering
const petX = () => vw() / 2 + gardenPetOffsetX;
const petY = () => vh() * 0.55;

function drawPet(t, mood, stage, variant, sleeping, accessory) {
  const sz = petSize();
  const px = petX();
  const py = petY();
  const bounce = Math.sin(t * 0.003) * sz * 0.03;
  const breathe = 1 + Math.sin(t * 0.002) * 0.02;

  ctx.save();
  ctx.translate(px, py + bounce);
  ctx.scale(breathe, breathe);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(0, sz * 0.55, sz * 0.5, sz * 0.08, 0, 0, Math.PI * 2);
  ctx.fill();

  if (stage === 'EGG') {
    drawEggPet(t, sz);
  } else if (stage === 'BABY') {
    drawBabyPet(t, sz, mood);
  } else if (stage === 'CHILD') {
    drawChildPet(t, sz, mood, variant);
  } else if (stage === 'TEEN') {
    drawTeenPet(t, sz, mood, variant);
  } else if (stage === 'ADULT') {
    drawAdultPet(t, sz, mood, variant);
  }

  // Draw accessory
  drawAcc(accessory, sz, stage);

  // Sleep Zzz
  if (sleeping && stage !== 'EGG') {
    ctx.font = Math.round(sz * 0.25) + 'px sans-serif';
    const zt = (t * 0.002) % 3;
    ctx.globalAlpha = 0.6;
    ctx.fillText('z', sz * 0.3, -sz * 0.3 - zt * 15);
    ctx.font = Math.round(sz * 0.2) + 'px sans-serif';
    ctx.globalAlpha = 0.4;
    ctx.fillText('z', sz * 0.4, -sz * 0.5 - zt * 10);
    ctx.font = Math.round(sz * 0.15) + 'px sans-serif';
    ctx.globalAlpha = 0.25;
    ctx.fillText('z', sz * 0.5, -sz * 0.65 - zt * 6);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function drawEggPet(t, sz) {
  const wobble = Math.sin(t * 0.005) * 0.05 * (state.stageTime > STAGES.EGG.dur * 1000 * 0.5 ? 2 : 1);
  ctx.rotate(wobble);

  // Egg body
  const grad = ctx.createRadialGradient(0, 0, sz * 0.05, 0, 0, sz * 0.5);
  grad.addColorStop(0, '#ffeaa7');
  grad.addColorStop(0.7, '#fdcb6e');
  grad.addColorStop(1, '#e17055');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, sz * 0.35, sz * 0.45, 0, 0, Math.PI * 2);
  ctx.fill();

  // Spots
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.beginPath(); ctx.arc(-sz*0.1, -sz*0.15, sz*0.06, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(sz*0.12, sz*0.05, sz*0.05, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(-sz*0.05, sz*0.2, sz*0.04, 0, Math.PI*2); ctx.fill();

  // Crack near hatching
  if (state.stageTime > STAGES.EGG.dur * 1000 * 0.7) {
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-sz*0.1, -sz*0.02);
    ctx.lineTo(-sz*0.02, sz*0.06);
    ctx.lineTo(sz*0.06, -sz*0.01);
    ctx.lineTo(sz*0.12, sz*0.08);
    ctx.stroke();
  }

  ctx.rotate(-wobble);
}

function drawBabyPet(t, sz, mood) {
  const r = sz * 0.4;
  // Body
  const grad = ctx.createRadialGradient(-r*0.2, -r*0.3, r*0.1, 0, 0, r);
  grad.addColorStop(0, '#a29bfe');
  grad.addColorStop(1, '#6c5ce7');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();

  // Cheeks
  ctx.fillStyle = 'rgba(255,150,150,0.3)';
  ctx.beginPath(); ctx.arc(-r*0.45, r*0.15, r*0.15, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(r*0.45, r*0.15, r*0.15, 0, Math.PI*2); ctx.fill();

  drawFace(t, r * 0.65, mood, sz);

  // Feet
  ctx.fillStyle = '#5b4ccc';
  ctx.beginPath(); ctx.ellipse(-r*0.3, r*0.9, r*0.2, r*0.12, -0.1, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.3, r*0.9, r*0.2, r*0.12, 0.1, 0, Math.PI*2); ctx.fill();
}

function drawChildPet(t, sz, mood, variant) {
  const r = sz * 0.42;
  const hue = variant === 0 ? '#55efc4' : '#fd79a8';
  const hue2 = variant === 0 ? '#00b894' : '#e84393';

  const grad = ctx.createRadialGradient(-r*0.2, -r*0.3, r*0.1, 0, 0, r);
  grad.addColorStop(0, hue);
  grad.addColorStop(1, hue2);
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();

  // Variant features
  if (variant === 0) { // Round ears
    ctx.fillStyle = hue2;
    ctx.beginPath(); ctx.arc(-r*0.65, -r*0.65, r*0.25, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(r*0.65, -r*0.65, r*0.25, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = hue;
    ctx.beginPath(); ctx.arc(-r*0.65, -r*0.65, r*0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(r*0.65, -r*0.65, r*0.15, 0, Math.PI*2); ctx.fill();
  } else { // Spikes
    ctx.fillStyle = hue2;
    for (let i = 0; i < 3; i++) {
      const a = -Math.PI/2 + (i-1)*0.4;
      const sx = Math.cos(a)*r*1.15, sy = Math.sin(a)*r*1.15;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + Math.cos(a-0.3)*r*0.15, sy + Math.sin(a-0.3)*r*0.15);
      ctx.lineTo(sx + Math.cos(a+0.3)*r*0.15, sy + Math.sin(a+0.3)*r*0.15);
      ctx.closePath();
      ctx.fill();
    }
  }

  drawFace(t, r * 0.6, mood, sz);

  // Arms
  ctx.fillStyle = hue2;
  ctx.beginPath(); ctx.ellipse(-r*1.05, r*0.1, r*0.12, r*0.25, 0.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*1.05, r*0.1, r*0.12, r*0.25, -0.2, 0, Math.PI*2); ctx.fill();

  // Feet
  ctx.beginPath(); ctx.ellipse(-r*0.35, r*0.9, r*0.2, r*0.13, -0.1, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.35, r*0.9, r*0.2, r*0.13, 0.1, 0, Math.PI*2); ctx.fill();
}

function drawTeenPet(t, sz, mood, variant) {
  const r = sz * 0.38;
  const colors = [
    ['#74b9ff','#0984e3'], // Horned
    ['#dfe6e9','#b2bec3'], // Winged
    ['#ffeaa7','#fdcb6e'], // Tailed
    ['#fab1a0','#e17055']  // Antenna
  ];
  const [c1, c2] = colors[variant % 4];

  // Body - taller
  const grad = ctx.createRadialGradient(-r*0.2, -r*0.3, r*0.1, 0, 0, r*1.1);
  grad.addColorStop(0, c1);
  grad.addColorStop(1, c2);
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, r, r * 1.2, 0, 0, Math.PI * 2);
  ctx.fill();

  const v = variant % 4;
  ctx.fillStyle = c2;
  if (v === 0) { // Horns
    ctx.beginPath(); ctx.moveTo(-r*0.5, -r*1); ctx.lineTo(-r*0.3, -r*1.6); ctx.lineTo(-r*0.1, -r*1); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.5, -r*1); ctx.lineTo(r*0.3, -r*1.6); ctx.lineTo(r*0.1, -r*1); ctx.closePath(); ctx.fill();
  } else if (v === 1) { // Wings
    ctx.globalAlpha = 0.4;
    ctx.beginPath(); ctx.ellipse(-r*1.3, -r*0.2, r*0.6, r*0.9, 0.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*1.3, -r*0.2, r*0.6, r*0.9, -0.2, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  } else if (v === 2) { // Tail
    ctx.lineWidth = r*0.15;
    ctx.strokeStyle = c2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(r*0.6, r*0.8);
    const twave = Math.sin(t*0.004)*0.3;
    ctx.quadraticCurveTo(r*1.5+Math.sin(t*0.003)*r*0.3, r*0.3+twave*r, r*1.2, -r*0.2+twave*r*0.5);
    ctx.stroke();
    ctx.fillStyle = c1;
    ctx.beginPath(); ctx.arc(r*1.2, -r*0.2+twave*r*0.5, r*0.12, 0, Math.PI*2); ctx.fill();
  } else { // Antenna
    ctx.strokeStyle = c2;
    ctx.lineWidth = r*0.06;
    ctx.beginPath(); ctx.moveTo(0, -r*1.15); ctx.lineTo(0, -r*1.7); ctx.stroke();
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath(); ctx.arc(0, -r*1.7, r*0.12, 0, Math.PI*2); ctx.fill();
  }

  drawFace(t, r * 0.6, mood, sz);

  // Feet
  ctx.fillStyle = c2;
  ctx.beginPath(); ctx.ellipse(-r*0.35, r*1.15, r*0.22, r*0.12, -0.1, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.35, r*1.15, r*0.22, r*0.12, 0.1, 0, Math.PI*2); ctx.fill();
}

function drawAdultPet(t, sz, mood, variant) {
  const r = sz * 0.42;
  const forms = [
    { name:'Dragon',  c1:'#ff7675', c2:'#d63031' },
    { name:'Angel',   c1:'#dfe6e9', c2:'#b2bec3' },
    { name:'Devil',   c1:'#636e72', c2:'#2d3436' },
    { name:'Cat',     c1:'#ffeaa7', c2:'#fdcb6e' },
    { name:'Robot',   c1:'#74b9ff', c2:'#0984e3' },
    { name:'BlobKing',c1:'#a29bfe', c2:'#6c5ce7' }
  ];
  const v = variant % 6;
  const {c1, c2} = forms[v];

  // Main body
  const grad = ctx.createRadialGradient(-r*0.2, -r*0.3, r*0.1, 0, 0, r*1.1);
  grad.addColorStop(0, c1);
  grad.addColorStop(1, c2);
  ctx.fillStyle = grad;

  if (v === 4) { // Robot - square
    roundRect(-r*0.8, -r, r*1.6, r*2, r*0.15);
  } else {
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r * 1.15, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Variant decorations
  ctx.fillStyle = c2;
  if (v === 0) { // Dragon - horns + wings
    ctx.beginPath(); ctx.moveTo(-r*0.5, -r*0.9); ctx.lineTo(-r*0.35, -r*1.7); ctx.lineTo(-r*0.05, -r*0.9); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.5, -r*0.9); ctx.lineTo(r*0.35, -r*1.7); ctx.lineTo(r*0.05, -r*0.9); ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 0.5;
    ctx.beginPath(); ctx.ellipse(-r*1.4, -r*0.1, r*0.65, r*0.9, 0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*1.4, -r*0.1, r*0.65, r*0.9, -0.15, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    // Fire breath occasionally
    if (mood === 'ecstatic' && Math.sin(t*0.005) > 0.7) {
      ctx.fillStyle = '#ffa502';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(r*0.2, r*0.3);
      ctx.quadraticCurveTo(r*0.5, r*0.6, r*0.1, r*1.0);
      ctx.quadraticCurveTo(-r*0.1, r*0.7, -r*0.2, r*0.3);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  } else if (v === 1) { // Angel - halo + wings
    ctx.strokeStyle = 'rgba(255,255,200,0.6)';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.ellipse(0, -r*1.3, r*0.45, r*0.1, 0, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.beginPath(); ctx.ellipse(-r*1.3, -r*0.2, r*0.5, r*0.85, 0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*1.3, -r*0.2, r*0.5, r*0.85, -0.15, 0, Math.PI*2); ctx.fill();
  } else if (v === 2) { // Devil - horns + tail
    ctx.fillStyle = '#d63031';
    ctx.beginPath(); ctx.moveTo(-r*0.55, -r*0.85); ctx.lineTo(-r*0.7, -r*1.6); ctx.lineTo(-r*0.3, -r*0.85); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.55, -r*0.85); ctx.lineTo(r*0.7, -r*1.6); ctx.lineTo(r*0.3, -r*0.85); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = c2;
    ctx.lineWidth = r*0.12;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(r*0.5, r*0.8);
    ctx.quadraticCurveTo(r*1.6, r*0.5, r*1.3, -r*0.3);
    ctx.stroke();
    // Trident tip
    ctx.fillStyle = '#d63031';
    ctx.beginPath();
    ctx.moveTo(r*1.3, -r*0.3);
    ctx.lineTo(r*1.15, -r*0.55);
    ctx.lineTo(r*1.3, -r*0.45);
    ctx.lineTo(r*1.45, -r*0.55);
    ctx.closePath();
    ctx.fill();
  } else if (v === 3) { // Cat - ears + whiskers + tail
    ctx.fillStyle = c2;
    ctx.beginPath(); ctx.moveTo(-r*0.7, -r*0.6); ctx.lineTo(-r*0.5, -r*1.5); ctx.lineTo(-r*0.1, -r*0.85); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.7, -r*0.6); ctx.lineTo(r*0.5, -r*1.5); ctx.lineTo(r*0.1, -r*0.85); ctx.closePath(); ctx.fill();
    // Inner ears
    ctx.fillStyle = '#fab1a0';
    ctx.beginPath(); ctx.moveTo(-r*0.55, -r*0.7); ctx.lineTo(-r*0.48, -r*1.2); ctx.lineTo(-r*0.25, -r*0.85); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(r*0.55, -r*0.7); ctx.lineTo(r*0.48, -r*1.2); ctx.lineTo(r*0.25, -r*0.85); ctx.closePath(); ctx.fill();
    // Whiskers
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1.5;
    for (let side of [-1,1]) {
      for (let w = -1; w <= 1; w++) {
        ctx.beginPath();
        ctx.moveTo(side*r*0.3, r*0.15+w*r*0.1);
        ctx.lineTo(side*r*1.1, r*0.05+w*r*0.15);
        ctx.stroke();
      }
    }
    // Tail
    ctx.strokeStyle = c2;
    ctx.lineWidth = r*0.12;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(r*0.5, r*0.7);
    const tw = Math.sin(t*0.004)*0.3;
    ctx.bezierCurveTo(r*1.5, r*0.5+tw*r, r*1.2, -r*0.5+tw*r, r*0.8, -r*0.3+tw*r*0.5);
    ctx.stroke();
  } else if (v === 4) { // Robot - antenna + screen
    ctx.fillStyle = c2;
    ctx.fillRect(-r*0.06, -r*1.2, r*0.12, r*0.25);
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath(); ctx.arc(0, -r*1.25, r*0.1, 0, Math.PI*2); ctx.fill();
    // Screen face
    ctx.fillStyle = 'rgba(0,255,200,0.15)';
    roundRect(-r*0.55, -r*0.5, r*1.1, r*0.8, r*0.1);
    // Bolts
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath(); ctx.arc(-r*0.6, r*0.6, r*0.08, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(r*0.6, r*0.6, r*0.08, 0, Math.PI*2); ctx.fill();
  } else { // Blob King - crown
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath();
    ctx.moveTo(-r*0.55, -r*0.8);
    ctx.lineTo(-r*0.5, -r*1.3);
    ctx.lineTo(-r*0.25, -r*1.0);
    ctx.lineTo(0, -r*1.5);
    ctx.lineTo(r*0.25, -r*1.0);
    ctx.lineTo(r*0.5, -r*1.3);
    ctx.lineTo(r*0.55, -r*0.8);
    ctx.closePath();
    ctx.fill();
    // Jewels
    ctx.fillStyle = '#e84393';
    ctx.beginPath(); ctx.arc(0, -r*1.15, r*0.06, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#00b894';
    ctx.beginPath(); ctx.arc(-r*0.3, -r*0.95, r*0.04, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(r*0.3, -r*0.95, r*0.04, 0, Math.PI*2); ctx.fill();
  }

  drawFace(t, r * 0.55, mood, sz);

  // Feet (not robot)
  if (v !== 4) {
    ctx.fillStyle = c2;
    ctx.beginPath(); ctx.ellipse(-r*0.35, r*1.1, r*0.22, r*0.13, -0.1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*0.35, r*1.1, r*0.22, r*0.13, 0.1, 0, Math.PI*2); ctx.fill();
  }
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
  ctx.fill();
}

function drawFace(t, spread, mood, sz) {
  const eyeSize = sz * 0.04;
  const pupilSize = eyeSize * 0.55;
  const blink = (t % 4000) < 100;

  // Eyes
  if (mood === 'sleepy') {
    // Closed eyes (lines)
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-spread*0.5, -spread*0.15); ctx.lineTo(-spread*0.2, -spread*0.1); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(spread*0.2, -spread*0.1); ctx.lineTo(spread*0.5, -spread*0.15); ctx.stroke();
  } else if (blink) {
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-spread-eyeSize, -spread*0.15); ctx.lineTo(-spread+eyeSize, -spread*0.15); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(spread-eyeSize, -spread*0.15); ctx.lineTo(spread+eyeSize, -spread*0.15); ctx.stroke();
  } else {
    // White
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-spread*0.35, -spread*0.2, eyeSize*1.4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(spread*0.35, -spread*0.2, eyeSize*1.4, 0, Math.PI*2); ctx.fill();
    // Pupil
    ctx.fillStyle = mood === 'sick' ? '#636e72' : '#2d3436';
    ctx.beginPath(); ctx.arc(-spread*0.35, -spread*0.18, pupilSize, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(spread*0.35, -spread*0.18, pupilSize, 0, Math.PI*2); ctx.fill();
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.beginPath(); ctx.arc(-spread*0.35-pupilSize*0.3, -spread*0.22, pupilSize*0.35, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(spread*0.35-pupilSize*0.3, -spread*0.22, pupilSize*0.35, 0, Math.PI*2); ctx.fill();
  }

  // Mouth
  ctx.strokeStyle = 'rgba(0,0,0,0.5)';
  ctx.lineWidth = 1.5;
  ctx.lineCap = 'round';
  if (mood === 'ecstatic' || mood === 'happy') {
    ctx.beginPath();
    ctx.arc(0, spread*0.15, spread*0.2, 0.1, Math.PI-0.1);
    ctx.stroke();
  } else if (mood === 'sad' || mood === 'hungry' || mood === 'sick') {
    ctx.beginPath();
    ctx.arc(0, spread*0.45, spread*0.15, Math.PI+0.2, -0.2);
    ctx.stroke();
  } else if (mood === 'sleepy') {
    ctx.beginPath();
    ctx.ellipse(0, spread*0.25, spread*0.08, spread*0.06, 0, 0, Math.PI*2);
    ctx.stroke();
  } else {
    ctx.beginPath();
    ctx.moveTo(-spread*0.12, spread*0.25);
    ctx.lineTo(spread*0.12, spread*0.25);
    ctx.stroke();
  }

  // Sick swirl
  if (mood === 'sick') {
    ctx.fillStyle = 'rgba(100,200,100,0.3)';
    ctx.font = Math.round(sz*0.15) + 'px sans-serif';
    ctx.fillText('~', spread*0.5, -spread*0.5);
  }
}

function drawAcc(accId, sz, stage) {
  if (accId === 0) return;
  const acc = ACCESSORIES.find(a => a.id === accId);
  if (!acc) return;

  const type = acc.type || 'floating';
  
  switch(type) {
    case 'glasses': drawGlasses(sz, stage); break;
    case 'sunglasses': drawSunglasses(sz, stage); break;
    case 'scarf': drawScarf(sz, stage); break;
    case 'headphones': drawHeadphones(sz, stage); break;
    case 'head': drawHeadAccessory(acc, sz, stage); break;
    default: drawFloatingAccessory(acc, sz, stage);
  }
}

// Draw regular glasses at eye level
function drawGlasses(sz, stage) {
  const oy = stage === 'ADULT' || stage === 'TEEN' ? -sz*0.12 : -sz*0.05;
  const lensR = sz * 0.09;
  const gap = sz * 0.04;
  const lensX = lensR + gap * 0.5;
  ctx.strokeStyle = 'rgba(255,255,255,0.85)';
  ctx.lineWidth = Math.max(2, sz * 0.025);
  // Left lens
  ctx.beginPath(); ctx.arc(-lensX, oy, lensR, 0, Math.PI*2); ctx.stroke();
  // Right lens
  ctx.beginPath(); ctx.arc(lensX, oy, lensR, 0, Math.PI*2); ctx.stroke();
  // Bridge
  ctx.beginPath(); ctx.moveTo(-lensX + lensR, oy); ctx.lineTo(lensX - lensR, oy); ctx.stroke();
  // Arms
  ctx.beginPath(); ctx.moveTo(-lensX - lensR, oy); ctx.lineTo(-lensX - lensR - sz*0.08, oy - sz*0.02); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(lensX + lensR, oy); ctx.lineTo(lensX + lensR + sz*0.08, oy - sz*0.02); ctx.stroke();
}

// Draw sunglasses with dark filled lenses
function drawSunglasses(sz, stage) {
  const oy = stage === 'ADULT' || stage === 'TEEN' ? -sz*0.12 : -sz*0.05;
  const lensR = sz * 0.10;
  const gap = sz * 0.03;
  const lensX = lensR + gap * 0.5;
  
  // Dark filled lenses
  ctx.fillStyle = 'rgba(30, 30, 30, 0.85)';
  ctx.beginPath(); ctx.arc(-lensX, oy, lensR, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(lensX, oy, lensR, 0, Math.PI*2); ctx.fill();
  
  // Frame
  ctx.strokeStyle = 'rgba(50, 50, 50, 0.9)';
  ctx.lineWidth = Math.max(2, sz * 0.03);
  ctx.beginPath(); ctx.arc(-lensX, oy, lensR, 0, Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.arc(lensX, oy, lensR, 0, Math.PI*2); ctx.stroke();
  
  // Bridge
  ctx.beginPath(); ctx.moveTo(-lensX + lensR, oy); ctx.lineTo(lensX - lensR, oy); ctx.stroke();
  
  // Arms
  ctx.beginPath(); ctx.moveTo(-lensX - lensR, oy); ctx.lineTo(-lensX - lensR - sz*0.1, oy - sz*0.02); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(lensX + lensR, oy); ctx.lineTo(lensX + lensR + sz*0.1, oy - sz*0.02); ctx.stroke();
  
  // Lens shine
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.beginPath(); ctx.arc(-lensX - lensR*0.3, oy - lensR*0.3, lensR*0.25, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(lensX - lensR*0.3, oy - lensR*0.3, lensR*0.25, 0, Math.PI*2); ctx.fill();
}

// Draw scarf wrapped around neck/body
function drawScarf(sz, stage) {
  // Get body radius based on stage
  let bodyR;
  if (stage === 'BABY') bodyR = sz * 0.4;
  else if (stage === 'TEEN') bodyR = sz * 0.38;
  else bodyR = sz * 0.42; // CHILD, ADULT
  
  const scarfY = bodyR * 0.25; // Position at lower part of body (neck area)
  const scarfWidth = sz * 0.12;
  
  // Main scarf color (burgundy/red)
  const scarfColor = '#c0392b';
  const scarfDark = '#922b21';
  
  // Draw the wrapped part of scarf (curved band around body)
  ctx.fillStyle = scarfColor;
  ctx.beginPath();
  // Draw arc for the front of scarf
  ctx.ellipse(0, scarfY, bodyR * 0.95, scarfWidth * 0.8, 0, 0.15 * Math.PI, 0.85 * Math.PI);
  ctx.ellipse(0, scarfY, bodyR * 0.95, scarfWidth * 1.6, 0, 0.85 * Math.PI, 0.15 * Math.PI);
  ctx.closePath();
  ctx.fill();
  
  // Knot in front
  ctx.fillStyle = scarfDark;
  ctx.beginPath();
  ctx.ellipse(0, scarfY + scarfWidth * 0.3, scarfWidth * 0.6, scarfWidth * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Hanging end 1 (left)
  ctx.fillStyle = scarfColor;
  ctx.beginPath();
  ctx.moveTo(-scarfWidth * 0.5, scarfY + scarfWidth * 0.5);
  ctx.quadraticCurveTo(-scarfWidth * 0.8, scarfY + sz * 0.25, -scarfWidth * 0.3, scarfY + sz * 0.35);
  ctx.lineTo(scarfWidth * 0.1, scarfY + sz * 0.32);
  ctx.quadraticCurveTo(-scarfWidth * 0.3, scarfY + sz * 0.2, scarfWidth * 0.2, scarfY + scarfWidth * 0.5);
  ctx.closePath();
  ctx.fill();
  
  // Hanging end 2 (right, slightly behind)
  ctx.fillStyle = scarfDark;
  ctx.beginPath();
  ctx.moveTo(scarfWidth * 0.3, scarfY + scarfWidth * 0.4);
  ctx.quadraticCurveTo(scarfWidth * 0.7, scarfY + sz * 0.2, scarfWidth * 0.5, scarfY + sz * 0.3);
  ctx.lineTo(scarfWidth * 0.9, scarfY + sz * 0.28);
  ctx.quadraticCurveTo(scarfWidth * 1.0, scarfY + sz * 0.15, scarfWidth * 0.6, scarfY + scarfWidth * 0.4);
  ctx.closePath();
  ctx.fill();
  
  // Fringe on ends
  ctx.strokeStyle = scarfColor;
  ctx.lineWidth = 2;
  for (let i = 0; i < 4; i++) {
    const fx = -scarfWidth * 0.2 + i * scarfWidth * 0.15;
    ctx.beginPath();
    ctx.moveTo(fx, scarfY + sz * 0.32);
    ctx.lineTo(fx - 2, scarfY + sz * 0.38);
    ctx.stroke();
  }
}

// Draw headphones over ears
function drawHeadphones(sz, stage) {
  // Get body radius based on stage
  let bodyR;
  if (stage === 'BABY') bodyR = sz * 0.4;
  else if (stage === 'TEEN') bodyR = sz * 0.38;
  else bodyR = sz * 0.42;
  
  const headY = stage === 'ADULT' || stage === 'TEEN' ? -sz * 0.05 : 0;
  const bandY = headY - bodyR * 0.7;
  const earX = bodyR * 0.85;
  const earY = headY - bodyR * 0.1;
  const cupR = sz * 0.1;
  
  // Headband
  ctx.strokeStyle = '#2c3e50';
  ctx.lineWidth = sz * 0.04;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.arc(0, headY, bodyR * 0.75, Math.PI * 1.15, Math.PI * 1.85);
  ctx.stroke();
  
  // Left ear cup
  ctx.fillStyle = '#34495e';
  ctx.beginPath();
  ctx.ellipse(-earX, earY, cupR, cupR * 1.2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#2c3e50';
  ctx.beginPath();
  ctx.ellipse(-earX, earY, cupR * 0.7, cupR * 0.9, 0, 0, Math.PI * 2);
  ctx.fill();
  // Cushion
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.ellipse(-earX, earY, cupR * 0.5, cupR * 0.65, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Right ear cup
  ctx.fillStyle = '#34495e';
  ctx.beginPath();
  ctx.ellipse(earX, earY, cupR, cupR * 1.2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#2c3e50';
  ctx.beginPath();
  ctx.ellipse(earX, earY, cupR * 0.7, cupR * 0.9, 0, 0, Math.PI * 2);
  ctx.fill();
  // Cushion
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.ellipse(earX, earY, cupR * 0.5, cupR * 0.65, 0, 0, Math.PI * 2);
  ctx.fill();
}

// Draw head accessories (hats, crowns, bows) positioned on top of head
function drawHeadAccessory(acc, sz, stage) {
  if (!acc.emoji) return;
  
  // Get body radius based on stage for proper positioning
  let bodyR;
  if (stage === 'BABY') bodyR = sz * 0.4;
  else if (stage === 'TEEN') bodyR = sz * 0.38;
  else bodyR = sz * 0.42;
  
  const s = sz * 0.28;
  // Position on top of head (accounting for body shape)
  const oy = -bodyR * 1.0;
  
  ctx.font = Math.round(s) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(acc.emoji, 0, oy);
  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';
}

// Draw floating/aura accessories above the pet
function drawFloatingAccessory(acc, sz, stage) {
  if (!acc.emoji) return;
  
  const s = sz * 0.3;
  const oy = stage === 'ADULT' || stage === 'TEEN' ? -sz*0.55 : -sz*0.4;
  
  ctx.font = Math.round(s) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(acc.emoji, 0, oy);
  ctx.textAlign = 'start';
}

// ============================================================
// VISITOR PET DRAWING
// ============================================================
function drawVisitorPet(t) {
  if (!visitor) return;
  const mainSz = petSize();
  const sz = mainSz * 0.55;
  // Position to the right of main pet, but clamped to stay on screen
  const px = Math.min(petX() + mainSz * 0.75, vw() - sz * 0.6);
  const py = petY() + mainSz * 0.22;
  const bounce = Math.sin(t * 0.0025 + 1) * sz * 0.035;
  const breathe = 1 + Math.sin(t * 0.0018) * 0.015;

  ctx.save();
  ctx.translate(px, py + bounce);
  ctx.scale(breathe, breathe);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(0, sz * 0.55, sz * 0.45, sz * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();

  // Draw visitor body (skip EGG stage drawing since it references state internals)
  if (visitor.stage === 'EGG') {
    // Simple egg drawing without state dependency
    const grad = ctx.createRadialGradient(0, 0, sz * 0.05, 0, 0, sz * 0.5);
    grad.addColorStop(0, '#fff5e6');
    grad.addColorStop(1, '#f0d9b5');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, sz * 0.35, sz * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();
  } else if (visitor.stage === 'BABY') {
    drawBabyPet(t, sz, 'happy');
  } else if (visitor.stage === 'CHILD') {
    drawChildPet(t, sz, 'happy', visitor.variant);
  } else if (visitor.stage === 'TEEN') {
    drawTeenPet(t, sz, 'happy', visitor.variant);
  } else if (visitor.stage === 'ADULT') {
    drawAdultPet(t, sz, 'happy', visitor.variant);
  }

  drawAcc(visitor.accessory, sz, visitor.stage);

  ctx.restore();

  // "Visitor" label
  ctx.save();
  ctx.font = Math.round(sz * 0.2) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('Visitor', px, py - sz * 0.55);
  ctx.textAlign = 'start';
  ctx.restore();
}

// ============================================================
// HOUSE DRAWING
// ============================================================
function drawHouse(t) {
  if (!state || state.house === 0) return;
  const hx = petX();
  const hy = petY();
  const sz = petSize();
  const hs = sz * 1.6; // house scale

  ctx.save();
  ctx.translate(hx, hy + sz * 0.15);

  switch(state.house) {
    case 1: // Tent
      ctx.fillStyle = '#e17055';
      ctx.beginPath();
      ctx.moveTo(0, -hs*0.7);
      ctx.lineTo(-hs*0.6, hs*0.3);
      ctx.lineTo(hs*0.6, hs*0.3);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#d63031';
      ctx.beginPath();
      ctx.moveTo(0, -hs*0.7);
      ctx.lineTo(0, hs*0.3);
      ctx.lineTo(-hs*0.6, hs*0.3);
      ctx.closePath();
      ctx.fill();
      // Door
      ctx.fillStyle = '#2d3436';
      ctx.beginPath();
      ctx.moveTo(0, hs*0.3);
      ctx.lineTo(-hs*0.15, hs*0.3);
      ctx.lineTo(-hs*0.08, hs*0.05);
      ctx.lineTo(hs*0.08, hs*0.05);
      ctx.lineTo(hs*0.15, hs*0.3);
      ctx.closePath();
      ctx.fill();
      // Flag
      ctx.strokeStyle = '#636e72';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(0, -hs*0.7); ctx.lineTo(0, -hs*0.9); ctx.stroke();
      ctx.fillStyle = '#ffd93d';
      ctx.beginPath();
      ctx.moveTo(0, -hs*0.9);
      ctx.lineTo(hs*0.12, -hs*0.82);
      ctx.lineTo(0, -hs*0.74);
      ctx.closePath();
      ctx.fill();
      break;

    case 2: // Cottage
      // Walls
      ctx.fillStyle = '#ffeaa7';
      ctx.fillRect(-hs*0.45, -hs*0.2, hs*0.9, hs*0.5);
      // Roof
      ctx.fillStyle = '#e17055';
      ctx.beginPath();
      ctx.moveTo(-hs*0.55, -hs*0.2);
      ctx.lineTo(0, -hs*0.65);
      ctx.lineTo(hs*0.55, -hs*0.2);
      ctx.closePath();
      ctx.fill();
      // Door
      ctx.fillStyle = '#6c5ce7';
      roundRectAt(-hs*0.08, hs*0.0, hs*0.16, hs*0.3, hs*0.03);
      // Windows
      ctx.fillStyle = '#74b9ff';
      ctx.fillRect(-hs*0.35, -hs*0.1, hs*0.15, hs*0.12);
      ctx.fillRect(hs*0.2, -hs*0.1, hs*0.15, hs*0.12);
      ctx.strokeStyle = '#dfe6e9';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(-hs*0.35, -hs*0.1, hs*0.15, hs*0.12);
      ctx.strokeRect(hs*0.2, -hs*0.1, hs*0.15, hs*0.12);
      // Chimney
      ctx.fillStyle = '#b2bec3';
      ctx.fillRect(hs*0.2, -hs*0.6, hs*0.12, hs*0.25);
      // Smoke
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#dfe6e9';
      const smokeY = Math.sin(t*0.002)*hs*0.05;
      ctx.beginPath(); ctx.arc(hs*0.26, -hs*0.7+smokeY, hs*0.06, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.3, -hs*0.82+smokeY, hs*0.04, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      break;

    case 3: // Cabin
      // Log walls
      ctx.fillStyle = '#8B6914';
      ctx.fillRect(-hs*0.45, -hs*0.25, hs*0.9, hs*0.55);
      // Log lines
      ctx.strokeStyle = '#6B4F12';
      ctx.lineWidth = 2;
      for (let i = 0; i < 5; i++) {
        const ly = -hs*0.2 + i * hs*0.1;
        ctx.beginPath(); ctx.moveTo(-hs*0.45, ly); ctx.lineTo(hs*0.45, ly); ctx.stroke();
      }
      // Roof
      ctx.fillStyle = '#636e72';
      ctx.beginPath();
      ctx.moveTo(-hs*0.55, -hs*0.25);
      ctx.lineTo(0, -hs*0.6);
      ctx.lineTo(hs*0.55, -hs*0.25);
      ctx.closePath();
      ctx.fill();
      // Door
      ctx.fillStyle = '#4a3510';
      roundRectAt(-hs*0.1, hs*0.0, hs*0.2, hs*0.3, hs*0.02);
      // Window
      ctx.fillStyle = '#ffeaa7';
      ctx.fillRect(hs*0.15, -hs*0.12, hs*0.15, hs*0.12);
      break;

    case 4: // Treehouse
      // Tree trunk
      ctx.fillStyle = '#6B4F12';
      ctx.fillRect(-hs*0.08, -hs*0.1, hs*0.16, hs*0.55);
      // Branches
      ctx.strokeStyle = '#6B4F12';
      ctx.lineWidth = hs*0.04;
      ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(-hs*0.02, -hs*0.3); ctx.lineTo(-hs*0.4, -hs*0.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hs*0.02, -hs*0.25); ctx.lineTo(hs*0.35, -hs*0.45); ctx.stroke();
      // Platform
      ctx.fillStyle = '#8B6914';
      ctx.fillRect(-hs*0.35, -hs*0.45, hs*0.7, hs*0.06);
      // House on platform
      ctx.fillStyle = '#e17055';
      ctx.fillRect(-hs*0.28, -hs*0.75, hs*0.56, hs*0.3);
      // Roof
      ctx.fillStyle = '#55efc4';
      ctx.beginPath();
      ctx.moveTo(-hs*0.35, -hs*0.75);
      ctx.lineTo(0, -hs*1.0);
      ctx.lineTo(hs*0.35, -hs*0.75);
      ctx.closePath();
      ctx.fill();
      // Window
      ctx.fillStyle = '#ffeaa7';
      ctx.beginPath(); ctx.arc(0, -hs*0.62, hs*0.08, 0, Math.PI*2); ctx.fill();
      // Leaves
      ctx.fillStyle = '#00b894';
      ctx.globalAlpha = 0.6;
      ctx.beginPath(); ctx.arc(-hs*0.4, -hs*0.55, hs*0.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.35, -hs*0.5, hs*0.18, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0, -hs*1.05, hs*0.15, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      break;

    case 5: // Castle
      // Main wall
      ctx.fillStyle = '#b2bec3';
      ctx.fillRect(-hs*0.35, -hs*0.3, hs*0.7, hs*0.6);
      // Towers
      ctx.fillStyle = '#636e72';
      ctx.fillRect(-hs*0.45, -hs*0.55, hs*0.18, hs*0.85);
      ctx.fillRect(hs*0.27, -hs*0.55, hs*0.18, hs*0.85);
      // Tower tops
      ctx.fillStyle = '#6c5ce7';
      ctx.beginPath();
      ctx.moveTo(-hs*0.48, -hs*0.55);
      ctx.lineTo(-hs*0.36, -hs*0.78);
      ctx.lineTo(-hs*0.24, -hs*0.55);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(hs*0.24, -hs*0.55);
      ctx.lineTo(hs*0.36, -hs*0.78);
      ctx.lineTo(hs*0.48, -hs*0.55);
      ctx.closePath();
      ctx.fill();
      // Battlement
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = '#b2bec3';
        ctx.fillRect(-hs*0.28 + i*hs*0.14, -hs*0.36, hs*0.08, hs*0.06);
      }
      // Gate
      ctx.fillStyle = '#2d3436';
      ctx.beginPath();
      ctx.moveTo(-hs*0.1, hs*0.3);
      ctx.lineTo(-hs*0.1, -hs*0.05);
      ctx.arc(0, -hs*0.05, hs*0.1, Math.PI, 0);
      ctx.lineTo(hs*0.1, hs*0.3);
      ctx.closePath();
      ctx.fill();
      // Flags
      ctx.fillStyle = '#ff6b6b';
      const fw = Math.sin(t*0.004)*hs*0.02;
      ctx.strokeStyle = '#636e72'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(-hs*0.36, -hs*0.78); ctx.lineTo(-hs*0.36, -hs*0.95); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hs*0.36, -hs*0.78); ctx.lineTo(hs*0.36, -hs*0.95); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-hs*0.36, -hs*0.95);
      ctx.lineTo(-hs*0.22+fw, -hs*0.88);
      ctx.lineTo(-hs*0.36, -hs*0.81);
      ctx.closePath();
      ctx.fill();
      break;

    case 6: // Igloo
      // Dome
      ctx.fillStyle = '#dfe6e9';
      ctx.beginPath();
      ctx.arc(0, hs*0.15, hs*0.5, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Ice block lines
      ctx.strokeStyle = 'rgba(178,190,195,0.5)';
      ctx.lineWidth = 1;
      for (let i = 1; i < 4; i++) {
        const ay = hs*0.15 - i*hs*0.12;
        ctx.beginPath();
        ctx.arc(0, hs*0.15, hs*0.5, Math.PI + i*0.25, -i*0.25);
        ctx.stroke();
      }
      // Entrance
      ctx.fillStyle = '#74b9ff';
      ctx.beginPath();
      ctx.arc(0, hs*0.15, hs*0.15, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Snow on top
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath(); ctx.arc(0, -hs*0.35, hs*0.1, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-hs*0.15, -hs*0.3, hs*0.07, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.12, -hs*0.32, hs*0.06, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      break;

    case 7: // Spaceship
      // Body
      const grd = ctx.createRadialGradient(0, -hs*0.15, hs*0.05, 0, -hs*0.15, hs*0.45);
      grd.addColorStop(0, '#b2bec3');
      grd.addColorStop(1, '#636e72');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(0, -hs*0.15, hs*0.55, hs*0.18, 0, 0, Math.PI*2);
      ctx.fill();
      // Dome
      ctx.fillStyle = 'rgba(116,185,255,0.5)';
      ctx.beginPath();
      ctx.arc(0, -hs*0.25, hs*0.2, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Lights
      const colors = ['#ff6b6b','#ffd93d','#55efc4','#74b9ff'];
      for (let i = 0; i < 4; i++) {
        const lx = -hs*0.35 + i*hs*0.23;
        const blink = Math.sin(t*0.005 + i*1.5) > 0 ? 1 : 0.3;
        ctx.globalAlpha = blink;
        ctx.fillStyle = colors[i];
        ctx.beginPath(); ctx.arc(lx, -hs*0.05, hs*0.04, 0, Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha = 1;
      // Landing legs
      ctx.strokeStyle = '#636e72';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-hs*0.3, hs*0.02); ctx.lineTo(-hs*0.4, hs*0.25); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hs*0.3, hs*0.02); ctx.lineTo(hs*0.4, hs*0.25); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, hs*0.03); ctx.lineTo(0, hs*0.25); ctx.stroke();
      break;

    case 8: // Mushroom
      // Stem
      ctx.fillStyle = '#ffeaa7';
      ctx.fillRect(-hs*0.12, -hs*0.15, hs*0.24, hs*0.5);
      // Cap
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(0, -hs*0.15, hs*0.45, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Spots
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(-hs*0.2, -hs*0.35, hs*0.08, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.15, -hs*0.4, hs*0.06, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.0, -hs*0.5, hs*0.07, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-hs*0.3, -hs*0.22, hs*0.05, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.28, -hs*0.25, hs*0.05, 0, Math.PI*2); ctx.fill();
      // Door
      ctx.fillStyle = '#6c5ce7';
      ctx.beginPath();
      ctx.arc(0, hs*0.15, hs*0.08, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Window
      ctx.fillStyle = '#74b9ff';
      ctx.beginPath(); ctx.arc(hs*0.0, hs*0.0, hs*0.05, 0, Math.PI*2); ctx.fill();
      break;

    case 9: // Cloud Palace
      // Cloud base
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.beginPath(); ctx.arc(-hs*0.2, hs*0.2, hs*0.25, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hs*0.15, hs*0.22, hs*0.22, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0, hs*0.15, hs*0.3, 0, Math.PI*2); ctx.fill();
      // Pillars
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(-hs*0.3, -hs*0.5, hs*0.06, hs*0.55);
      ctx.fillRect(hs*0.24, -hs*0.5, hs*0.06, hs*0.55);
      // Roof
      ctx.fillStyle = '#ffd93d';
      ctx.beginPath();
      ctx.moveTo(-hs*0.38, -hs*0.5);
      ctx.lineTo(0, -hs*0.8);
      ctx.lineTo(hs*0.38, -hs*0.5);
      ctx.closePath();
      ctx.fill();
      // Arch
      ctx.fillStyle = 'rgba(116,185,255,0.4)';
      ctx.beginPath();
      ctx.arc(0, -hs*0.05, hs*0.18, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Sparkles
      ctx.globalAlpha = 0.5 + Math.sin(t*0.003)*0.3;
      ctx.fillStyle = '#ffd93d';
      ctx.font = Math.round(hs*0.1) + 'px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚ú®', -hs*0.15, -hs*0.65);
      ctx.fillText('‚ú®', hs*0.2, -hs*0.7);
      ctx.textAlign = 'start';
      ctx.globalAlpha = 1;
      break;

    case 10: // Crystal
      // Main crystal
      ctx.fillStyle = 'rgba(162,155,254,0.6)';
      ctx.beginPath();
      ctx.moveTo(0, -hs*0.85);
      ctx.lineTo(-hs*0.2, -hs*0.15);
      ctx.lineTo(hs*0.2, -hs*0.15);
      ctx.closePath();
      ctx.fill();
      // Side crystals
      ctx.fillStyle = 'rgba(108,92,231,0.5)';
      ctx.beginPath();
      ctx.moveTo(-hs*0.25, -hs*0.55);
      ctx.lineTo(-hs*0.4, hs*0.05);
      ctx.lineTo(-hs*0.15, hs*0.05);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(hs*0.3, -hs*0.5);
      ctx.lineTo(hs*0.15, hs*0.05);
      ctx.lineTo(hs*0.42, hs*0.05);
      ctx.closePath();
      ctx.fill();
      // Small crystal
      ctx.fillStyle = 'rgba(253,121,168,0.5)';
      ctx.beginPath();
      ctx.moveTo(-hs*0.42, -hs*0.25);
      ctx.lineTo(-hs*0.5, hs*0.1);
      ctx.lineTo(-hs*0.35, hs*0.1);
      ctx.closePath();
      ctx.fill();
      // Glow
      ctx.globalAlpha = 0.15 + Math.sin(t*0.003)*0.1;
      const cGlow = ctx.createRadialGradient(0, -hs*0.3, 0, 0, -hs*0.3, hs*0.6);
      cGlow.addColorStop(0, 'rgba(162,155,254,0.4)');
      cGlow.addColorStop(1, 'rgba(162,155,254,0)');
      ctx.fillStyle = cGlow;
      ctx.beginPath(); ctx.arc(0, -hs*0.3, hs*0.6, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      // Shine lines
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(-hs*0.05, -hs*0.7); ctx.lineTo(-hs*0.12, -hs*0.4); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hs*0.08, -hs*0.6); ctx.lineTo(hs*0.1, -hs*0.35); ctx.stroke();
      break;
  }
  ctx.restore();
}

function roundRectAt(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
  ctx.fill();
}

// ============================================================
// LANDSCAPE BACKGROUNDS
// ============================================================
function drawLandscapeBackground(t, mood) {
  const w = vw(), h = vh();
  const landscapeId = (state && state.landscape) || 0;

  if (landscapeId === 0) {
    // Default Night Sky - use original mood-based background
    drawBackground(t, mood);
    return;
  }

  switch(landscapeId) {
    case 1: // Green Meadow
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#87CEEB');
        grad.addColorStop(0.5, '#B0E0E6');
        grad.addColorStop(0.7, '#90EE90');
        grad.addColorStop(1, '#228B22');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Sun
        ctx.fillStyle = 'rgba(255,255,100,0.3)';
        ctx.beginPath(); ctx.arc(w*0.85, h*0.1, 50, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,150,0.6)';
        ctx.beginPath(); ctx.arc(w*0.85, h*0.1, 35, 0, Math.PI*2); ctx.fill();
        // Clouds
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        drawCloud(w*0.2 + Math.sin(t*0.0003)*20, h*0.12, 40);
        drawCloud(w*0.6 + Math.sin(t*0.0002+1)*15, h*0.08, 30);
        drawCloud(w*0.85 + Math.sin(t*0.00025+2)*18, h*0.2, 25);
        // Ground
        const gy = h*0.68;
        ctx.fillStyle = '#3CB371';
        ctx.fillRect(0, gy, w, h-gy);
        // Grass tufts
        ctx.strokeStyle = '#2E8B57';
        ctx.lineWidth = 1.5;
        for (let gx = 0; gx < w; gx += 25) {
          const gh = 8 + Math.sin(gx*0.5)*3 + Math.sin(t*0.003+gx*0.1)*2;
          ctx.beginPath();
          ctx.moveTo(gx, gy);
          ctx.quadraticCurveTo(gx-3, gy-gh, gx+2, gy-gh-3);
          ctx.stroke();
        }
        // Flowers
        const flowerColors = ['#ff6b6b','#ffd93d','#fd79a8','#a29bfe','#fff'];
        for (let i = 0; i < 12; i++) {
          const fx = (i*w/12 + Math.sin(i*3)*20) % w;
          const fy = gy + 10 + Math.sin(i*7)*5;
          ctx.fillStyle = flowerColors[i%5];
          ctx.beginPath(); ctx.arc(fx, fy, 3, 0, Math.PI*2); ctx.fill();
        }
      }
      break;

    case 2: // Desert
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#FF8C00');
        grad.addColorStop(0.3, '#FFA500');
        grad.addColorStop(0.6, '#F4A460');
        grad.addColorStop(1, '#DEB887');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Sun (big and hot)
        ctx.fillStyle = 'rgba(255,200,0,0.2)';
        ctx.beginPath(); ctx.arc(w*0.5, h*0.08, 70, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,220,50,0.5)';
        ctx.beginPath(); ctx.arc(w*0.5, h*0.08, 40, 0, Math.PI*2); ctx.fill();
        // Dunes
        const gy = h*0.68;
        ctx.fillStyle = '#D2B48C';
        ctx.beginPath();
        ctx.moveTo(0, gy);
        for (let x = 0; x <= w; x += 10) {
          ctx.lineTo(x, gy + Math.sin(x*0.01)*20 + Math.sin(x*0.025)*8);
        }
        ctx.lineTo(w, h); ctx.lineTo(0, h);
        ctx.closePath();
        ctx.fill();
        // Cactus
        ctx.fillStyle = '#2E8B57';
        drawCactus(w*0.15, gy-5, 30);
        drawCactus(w*0.78, gy-10, 22);
        // Heat shimmer
        ctx.globalAlpha = 0.05;
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 8; i++) {
          const sx = (i*w/8 + Math.sin(t*0.002+i)*30) % w;
          ctx.fillRect(sx, h*0.4, 2, h*0.15);
        }
        ctx.globalAlpha = 1;
      }
      break;

    case 3: // Clouds
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#4FC3F7');
        grad.addColorStop(0.5, '#81D4FA');
        grad.addColorStop(1, '#B3E5FC');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Many clouds
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        for (let i = 0; i < 8; i++) {
          const cx = (i*w/5 + Math.sin(t*0.0002+i*2)*40 + t*0.01*(i%3+1)*0.3) % (w+200) - 100;
          const cy = h*0.1 + i*h*0.1 + Math.sin(i*5)*h*0.05;
          drawCloud(cx, cy, 25+i*5);
        }
        // Ground clouds
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        const gy = h*0.72;
        for (let x = -50; x < w+50; x += 40) {
          const cr = 25 + Math.sin(x*0.05)*10;
          ctx.beginPath(); ctx.arc(x, gy+10, cr, 0, Math.PI*2); ctx.fill();
        }
      }
      break;

    case 4: // Snow
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#708090');
        grad.addColorStop(0.4, '#B0C4DE');
        grad.addColorStop(0.7, '#E8E8E8');
        grad.addColorStop(1, '#FFFFFF');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Snow ground
        const gy = h*0.68;
        ctx.fillStyle = '#F0F8FF';
        ctx.beginPath();
        ctx.moveTo(0, gy);
        for (let x = 0; x <= w; x += 15) {
          ctx.lineTo(x, gy + Math.sin(x*0.02)*5 + Math.sin(x*0.05)*2);
        }
        ctx.lineTo(w, h); ctx.lineTo(0, h);
        ctx.closePath();
        ctx.fill();
        // Pine trees (background)
        ctx.fillStyle = '#2F4F4F';
        drawPineTree(w*0.1, gy, 35);
        drawPineTree(w*0.25, gy+3, 25);
        drawPineTree(w*0.8, gy-2, 30);
        drawPineTree(w*0.92, gy+5, 20);
        // Snowflakes
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 30; i++) {
          const sx = (i*w/15 + t*0.02*(i%3+1)*0.3) % w;
          const sy = (i*h/12 + t*0.03*(i%4+1)*0.2) % h;
          const ss = 1 + (i%3);
          ctx.globalAlpha = 0.4 + Math.sin(t*0.003+i)*0.2;
          ctx.beginPath(); ctx.arc(sx, sy, ss, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
      break;

    case 5: // Beach
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#00BFFF');
        grad.addColorStop(0.45, '#1E90FF');
        grad.addColorStop(0.55, '#4169E1');
        grad.addColorStop(0.62, '#F5DEB3');
        grad.addColorStop(1, '#DEB887');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Sun
        ctx.fillStyle = 'rgba(255,255,100,0.3)';
        ctx.beginPath(); ctx.arc(w*0.8, h*0.08, 50, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,150,0.6)';
        ctx.beginPath(); ctx.arc(w*0.8, h*0.08, 32, 0, Math.PI*2); ctx.fill();
        // Waves
        const waveY = h*0.55;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        for (let wl = 0; wl < 3; wl++) {
          ctx.beginPath();
          ctx.moveTo(0, waveY + wl*8);
          for (let x = 0; x <= w; x += 5) {
            ctx.lineTo(x, waveY + wl*8 + Math.sin(x*0.03 + t*0.003 + wl)*4);
          }
          ctx.stroke();
        }
        // Sand
        const sy = h*0.62;
        ctx.fillStyle = '#F5DEB3';
        ctx.fillRect(0, sy, w, h-sy);
        // Palm tree
        drawPalmTree(w*0.12, sy, 60);
        // Shells
        ctx.font = '10px sans-serif';
        ctx.fillText('üêö', w*0.4, sy+15);
        ctx.fillText('üêö', w*0.7, sy+20);
        ctx.fillText('‚≠ê', w*0.55, sy+12);
      }
      break;

    case 6: // Forest
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#1B3A1B');
        grad.addColorStop(0.3, '#2D5A2D');
        grad.addColorStop(0.6, '#1B4A1B');
        grad.addColorStop(1, '#0D2B0D');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Filtered light
        ctx.globalAlpha = 0.05;
        ctx.fillStyle = '#FFD700';
        for (let i = 0; i < 5; i++) {
          const lx = w*0.2 + i*w*0.15;
          ctx.beginPath();
          ctx.moveTo(lx, 0);
          ctx.lineTo(lx-30, h*0.7);
          ctx.lineTo(lx+30, h*0.7);
          ctx.closePath();
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        // Ground
        const gy = h*0.7;
        ctx.fillStyle = '#1a3a0a';
        ctx.fillRect(0, gy, w, h-gy);
        // Background trees
        ctx.fillStyle = '#0D3B0D';
        for (let i = 0; i < 6; i++) {
          const tx = i*w/5;
          drawForestTree(tx, gy, 50+Math.sin(i*3)*15, '#0D3B0D');
        }
        // Foreground trees
        for (let i = 0; i < 3; i++) {
          const tx = w*0.1 + i*w*0.35;
          drawForestTree(tx, gy, 40, '#1B5A1B');
        }
        // Fireflies
        for (let i = 0; i < 6; i++) {
          const fx = (w*0.15+i*w/6 + Math.sin(t*0.001+i*2)*20);
          const fy = h*0.3 + Math.sin(t*0.002+i*3)*h*0.15;
          ctx.globalAlpha = 0.3 + Math.sin(t*0.005+i)*0.3;
          ctx.fillStyle = '#ADFF2F';
          ctx.beginPath(); ctx.arc(fx, fy, 2, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
      break;

    case 7: // Space
      {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#0a001a');
        grad.addColorStop(0.5, '#120025');
        grad.addColorStop(1, '#0a001a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Nebula
        ctx.globalAlpha = 0.08;
        const nGrad = ctx.createRadialGradient(w*0.3, h*0.4, 0, w*0.3, h*0.4, w*0.4);
        nGrad.addColorStop(0, '#8B00FF');
        nGrad.addColorStop(0.5, '#FF1493');
        nGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = nGrad;
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
        // Stars
        drawStars(t);
        // Planet
        ctx.fillStyle = '#E17055';
        ctx.beginPath(); ctx.arc(w*0.82, h*0.25, 25, 0, Math.PI*2); ctx.fill();
        // Ring
        ctx.strokeStyle = 'rgba(255,200,150,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(w*0.82, h*0.25, 40, 8, -0.3, 0, Math.PI*2);
        ctx.stroke();
        // Small planet
        ctx.fillStyle = '#74b9ff';
        ctx.beginPath(); ctx.arc(w*0.15, h*0.15, 12, 0, Math.PI*2); ctx.fill();
        // Ground (space platform)
        const gy = h*0.72;
        ctx.fillStyle = '#1a1a3e';
        ctx.fillRect(0, gy, w, h-gy);
        ctx.strokeStyle = 'rgba(100,100,200,0.2)';
        ctx.lineWidth = 1;
        for (let x = 0; x < w; x += 30) {
          ctx.beginPath(); ctx.moveTo(x, gy); ctx.lineTo(x, h); ctx.stroke();
        }
        for (let y = gy; y < h; y += 15) {
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
        }
      }
      break;
  }
}

// Landscape helper functions
function drawCloud(x, y, size) {
  ctx.beginPath();
  ctx.arc(x, y, size, 0, Math.PI*2);
  ctx.arc(x+size*0.8, y-size*0.2, size*0.7, 0, Math.PI*2);
  ctx.arc(x+size*1.4, y, size*0.6, 0, Math.PI*2);
  ctx.arc(x-size*0.6, y+size*0.1, size*0.5, 0, Math.PI*2);
  ctx.fill();
}

function drawCactus(x, y, size) {
  ctx.fillRect(x-size*0.1, y-size, size*0.2, size);
  // Arms
  ctx.fillRect(x-size*0.35, y-size*0.7, size*0.25, size*0.1);
  ctx.fillRect(x-size*0.35, y-size*0.7, size*0.1, size*0.35);
  ctx.fillRect(x+size*0.1, y-size*0.5, size*0.25, size*0.1);
  ctx.fillRect(x+size*0.25, y-size*0.5, size*0.1, size*0.3);
}

function drawPineTree(x, y, size) {
  ctx.save();
  // Trunk
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(x-size*0.06, y-size*0.2, size*0.12, size*0.25);
  // Layers
  ctx.fillStyle = '#2E7D32';
  for (let i = 0; i < 3; i++) {
    const ly = y - size*0.2 - i*size*0.3;
    const lw = size*0.4 - i*size*0.08;
    ctx.beginPath();
    ctx.moveTo(x-lw, ly);
    ctx.lineTo(x, ly-size*0.35);
    ctx.lineTo(x+lw, ly);
    ctx.closePath();
    ctx.fill();
  }
  // Snow caps
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  for (let i = 0; i < 3; i++) {
    const ly = y - size*0.2 - i*size*0.3;
    ctx.beginPath();
    ctx.moveTo(x-size*0.1, ly-size*0.25);
    ctx.lineTo(x, ly-size*0.35);
    ctx.lineTo(x+size*0.1, ly-size*0.25);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawPalmTree(x, y, size) {
  // Trunk
  ctx.fillStyle = '#8B6914';
  ctx.lineWidth = size*0.08;
  ctx.strokeStyle = '#6B4F12';
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.quadraticCurveTo(x+size*0.15, y-size*0.5, x+size*0.05, y-size*0.8);
  ctx.lineWidth = size*0.1;
  ctx.stroke();
  // Leaves
  ctx.fillStyle = '#228B22';
  const lx = x+size*0.05, ly = y-size*0.8;
  for (let i = 0; i < 5; i++) {
    const angle = -Math.PI/2 + (i-2)*0.5;
    ctx.save();
    ctx.translate(lx, ly);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.ellipse(0, -size*0.25, size*0.06, size*0.3, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  // Coconuts
  ctx.fillStyle = '#8B4513';
  ctx.beginPath(); ctx.arc(lx+3, ly+5, 4, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(lx-4, ly+6, 4, 0, Math.PI*2); ctx.fill();
}

function drawForestTree(x, y, size, color) {
  ctx.fillStyle = '#3E2723';
  ctx.fillRect(x-size*0.06, y-size*0.3, size*0.12, size*0.35);
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x, y-size*0.45, size*0.35, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x-size*0.2, y-size*0.3, size*0.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x+size*0.2, y-size*0.35, size*0.22, 0, Math.PI*2); ctx.fill();
}

// ============================================================
// GARDEN DRAWING
// ============================================================

// Garden bed themes per landscape
const GARDEN_BED_THEMES = {
  0: { // Night Sky - Moonlit garden
    bedColor: '#2a1f4e', bedBorder: '#4a3a7e', soilColor: '#1a1535',
    fenceColor: '#3d2d6d', fenceTop: '#5a4a8d', pathColor: '#251a40',
    accent: '#7B68EE', glowColor: 'rgba(123,104,238,0.3)'
  },
  1: { // Green Meadow - Classic garden
    bedColor: '#3d5c3d', bedBorder: '#5a7a5a', soilColor: '#4a3528',
    fenceColor: '#8B6914', fenceTop: '#a88932', pathColor: '#6b5a48',
    accent: '#7cb342', glowColor: 'rgba(124,179,66,0.2)'
  },
  2: { // Desert - Succulent garden
    bedColor: '#c4a574', bedBorder: '#d4b584', soilColor: '#a08060',
    fenceColor: '#8B7355', fenceTop: '#a89070', pathColor: '#b89868',
    accent: '#66bb6a', glowColor: 'rgba(102,187,106,0.2)'
  },
  3: { // Clouds - Sky garden
    bedColor: '#b8d4e8', bedBorder: '#d0e8f8', soilColor: '#a0c4d8',
    fenceColor: '#ffffff', fenceTop: '#f0f8ff', pathColor: '#c8e0f0',
    accent: '#81d4fa', glowColor: 'rgba(129,212,250,0.3)'
  },
  4: { // Snow - Ice garden
    bedColor: '#d8e8f0', bedBorder: '#e8f4fa', soilColor: '#c0d8e8',
    fenceColor: '#a8c8d8', fenceTop: '#c8e0f0', pathColor: '#e0f0f8',
    accent: '#80deea', glowColor: 'rgba(128,222,234,0.3)'
  },
  5: { // Beach - Tropical garden
    bedColor: '#f5deb3', bedBorder: '#ffe4b5', soilColor: '#deb887',
    fenceColor: '#8B4513', fenceTop: '#a0522d', pathColor: '#d2b48c',
    accent: '#4dd0e1', glowColor: 'rgba(77,208,225,0.2)'
  },
  6: { // Forest - Fairy garden
    bedColor: '#2d4a2d', bedBorder: '#3d5a3d', soilColor: '#3a2818',
    fenceColor: '#5d4037', fenceTop: '#795548', pathColor: '#4a3a28',
    accent: '#aed581', glowColor: 'rgba(174,213,129,0.2)'
  },
  7: { // Space - Alien garden
    bedColor: '#1a1a3e', bedBorder: '#2a2a5e', soilColor: '#0f0f2a',
    fenceColor: '#4a4a8e', fenceTop: '#6a6aae', pathColor: '#151535',
    accent: '#00ff88', glowColor: 'rgba(0,255,136,0.3)'
  }
};

// Draw the main garden bed area
function drawGardenBed(t, landscapeId) {
  const w = vw(), h = vh();
  const theme = GARDEN_BED_THEMES[landscapeId] || GARDEN_BED_THEMES[0];
  
  // Garden bed dimensions - positioned on the right side
  const bedX = w * 0.55;
  const bedY = h * 0.65;
  const bedW = w * 0.38;
  const bedH = h * 0.18;
  
  // Draw garden path leading to bed
  ctx.fillStyle = theme.pathColor;
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.moveTo(w * 0.5, h * 0.75);
  ctx.quadraticCurveTo(w * 0.6, h * 0.73, bedX + bedW * 0.3, bedY + bedH);
  ctx.lineTo(bedX + bedW * 0.5, bedY + bedH);
  ctx.quadraticCurveTo(w * 0.58, h * 0.73, w * 0.5, h * 0.78);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  // Draw fence posts behind the garden bed
  const fenceY = bedY - 8;
  const postCount = 7;
  const postSpacing = bedW / (postCount - 1);
  
  for (let i = 0; i < postCount; i++) {
    const px = bedX + i * postSpacing;
    const postHeight = 20 + Math.sin(t * 0.001 + i) * 2;
    
    // Fence post
    ctx.fillStyle = theme.fenceColor;
    ctx.fillRect(px - 3, fenceY - postHeight, 6, postHeight + 5);
    
    // Post top
    ctx.fillStyle = theme.fenceTop;
    ctx.beginPath();
    ctx.arc(px, fenceY - postHeight, 5, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Horizontal fence rails
  ctx.fillStyle = theme.fenceColor;
  ctx.fillRect(bedX - 3, fenceY - 15, bedW + 6, 4);
  ctx.fillRect(bedX - 3, fenceY - 8, bedW + 6, 3);
  
  // Garden bed shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(bedX + bedW/2, bedY + bedH + 5, bedW/2 + 5, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Garden bed main area (raised bed look)
  ctx.fillStyle = theme.bedBorder;
  ctx.beginPath();
  ctx.roundRect(bedX - 4, bedY - 4, bedW + 8, bedH + 12, 8);
  ctx.fill();
  
  ctx.fillStyle = theme.bedColor;
  ctx.beginPath();
  ctx.roundRect(bedX, bedY, bedW, bedH, 6);
  ctx.fill();
  
  // Soil texture
  ctx.fillStyle = theme.soilColor;
  const rowCount = 4;
  const rowHeight = bedH / rowCount;
  for (let r = 0; r < rowCount; r++) {
    const ry = bedY + r * rowHeight + rowHeight * 0.5;
    ctx.beginPath();
    ctx.moveTo(bedX + 10, ry);
    // Wavy soil row
    for (let sx = 0; sx < bedW - 20; sx += 15) {
      const waveY = ry + Math.sin(sx * 0.1 + r * 2) * 3;
      ctx.lineTo(bedX + 10 + sx, waveY);
    }
    ctx.lineTo(bedX + bedW - 10, ry);
    ctx.lineTo(bedX + bedW - 10, ry + 6);
    ctx.lineTo(bedX + 10, ry + 6);
    ctx.closePath();
    ctx.fill();
  }
  
  // Ambient glow effect
  const glowPulse = 0.5 + 0.3 * Math.sin(t * 0.002);
  ctx.globalAlpha = glowPulse * 0.4;
  ctx.fillStyle = theme.glowColor;
  ctx.beginPath();
  ctx.ellipse(bedX + bedW/2, bedY + bedH/2, bedW/2, bedH/2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  return { x: bedX, y: bedY, w: bedW, h: bedH };
}

// Draw a secondary garden area on the left
function drawSecondaryGarden(t, landscapeId) {
  const w = vw(), h = vh();
  const theme = GARDEN_BED_THEMES[landscapeId] || GARDEN_BED_THEMES[0];
  
  // Smaller garden on the left
  const bedX = w * 0.05;
  const bedY = h * 0.68;
  const bedW = w * 0.25;
  const bedH = h * 0.12;
  
  // Small decorative pots/planters
  const potCount = 3;
  const potSpacing = bedW / (potCount + 1);
  
  for (let i = 0; i < potCount; i++) {
    const px = bedX + (i + 1) * potSpacing;
    const py = bedY + bedH * 0.3;
    const potSize = 18 + Math.sin(i * 1.5) * 4;
    
    // Pot shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(px, py + potSize * 0.8, potSize * 0.7, potSize * 0.2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Pot body
    ctx.fillStyle = theme.bedBorder;
    ctx.beginPath();
    ctx.moveTo(px - potSize * 0.5, py);
    ctx.lineTo(px - potSize * 0.35, py + potSize * 0.7);
    ctx.lineTo(px + potSize * 0.35, py + potSize * 0.7);
    ctx.lineTo(px + potSize * 0.5, py);
    ctx.closePath();
    ctx.fill();
    
    // Pot rim
    ctx.fillStyle = theme.bedColor;
    ctx.beginPath();
    ctx.ellipse(px, py, potSize * 0.5, potSize * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Soil in pot
    ctx.fillStyle = theme.soilColor;
    ctx.beginPath();
    ctx.ellipse(px, py + 2, potSize * 0.4, potSize * 0.12, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Small garden patch
  ctx.fillStyle = theme.soilColor;
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.ellipse(bedX + bedW * 0.5, bedY + bedH, bedW * 0.4, bedH * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  // Decorative stones/border
  ctx.fillStyle = theme.fenceColor;
  const stoneCount = 8;
  for (let i = 0; i < stoneCount; i++) {
    const angle = (i / stoneCount) * Math.PI;
    const sx = bedX + bedW * 0.5 + Math.cos(angle) * bedW * 0.45;
    const sy = bedY + bedH + Math.sin(angle) * bedH * 0.35;
    const stoneSize = 5 + Math.sin(i * 2) * 2;
    ctx.beginPath();
    ctx.ellipse(sx, sy, stoneSize, stoneSize * 0.6, angle * 0.3, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawGarden(t, landscapeId) {
  const w = vw(), h = vh();
  
  // Draw the main garden beds first (background)
  drawSecondaryGarden(t, landscapeId);
  const mainBed = drawGardenBed(t, landscapeId);
  
  // Now draw the garden elements on top
  const gy = h * 0.72; // ground line
  const elements = GARDEN_ELEMENTS[landscapeId] || GARDEN_ELEMENTS[0];
  const emojiSize = Math.round(Math.min(w, h) * 0.045);

  for (let i = 0; i < elements.length; i++) {
    const el = elements[i];
    const ex = el.x * w;
    // Position elements in the garden bed area
    const inMainBed = ex > mainBed.x && ex < mainBed.x + mainBed.w;
    const ey = inMainBed ? mainBed.y + mainBed.h * 0.4 : gy + 10 + Math.sin(ex * 0.01) * 4;

    // Glow effect for bioluminescent/moonlit items
    if (el.glow) {
      const pulse = 0.4 + 0.3 * Math.sin(t * 0.003 + i * 1.5);
      ctx.globalAlpha = pulse;
      ctx.fillStyle = el.glow;
      ctx.beginPath();
      ctx.arc(ex, ey - emojiSize * 0.2, emojiSize * 1.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Small bob animation
    const bob = Math.sin(t * 0.002 + i * 2) * 3;

    // Draw emoji (larger now)
    ctx.font = emojiSize + 'px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(el.emoji, ex, ey + bob);

    // Small soil/pot base for items not in main bed
    if (!inMainBed) {
      ctx.fillStyle = 'rgba(80,60,40,0.4)';
      ctx.beginPath();
      ctx.ellipse(ex, ey + 8, emojiSize * 0.5, emojiSize * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.textAlign = 'start';
}

// ============================================================
// GARDEN ENHANCED DRAWING (Balloon, Plants, Companion)
// ============================================================

// Draw floating balloon
function drawBalloon(t) {
  if (!gardenBalloon.active) return;
  
  const w = vw(), h = vh();
  const bx = gardenBalloon.x;
  const by = gardenBalloon.y;
  const bobOffset = Math.sin(t * 0.003) * 3;
  
  // Shadow on ground
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(bx, h * 0.73, 12, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  // String
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(bx, by + 20 + bobOffset);
  // Wavy string
  const stringLen = h * 0.73 - (by + 20);
  for (let i = 0; i <= 10; i++) {
    const sy = by + 20 + bobOffset + (stringLen * i / 10);
    const sx = bx + Math.sin(i * 0.8 + t * 0.002) * 3;
    ctx.lineTo(sx, sy);
  }
  ctx.stroke();
  
  // Balloon body (oval)
  const balloonW = 18;
  const balloonH = 22;
  
  // Glow effect
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = gardenBalloon.color;
  ctx.beginPath();
  ctx.ellipse(bx, by + bobOffset, balloonW + 5, balloonH + 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  // Main balloon
  ctx.fillStyle = gardenBalloon.color;
  ctx.beginPath();
  ctx.ellipse(bx, by + bobOffset, balloonW, balloonH, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.beginPath();
  ctx.ellipse(bx - 5, by - 5 + bobOffset, 5, 7, -0.4, 0, Math.PI * 2);
  ctx.fill();
  
  // Knot
  ctx.fillStyle = gardenBalloon.color;
  ctx.beginPath();
  ctx.moveTo(bx - 4, by + balloonH + bobOffset);
  ctx.lineTo(bx + 4, by + balloonH + bobOffset);
  ctx.lineTo(bx, by + balloonH + 6 + bobOffset);
  ctx.closePath();
  ctx.fill();
}

// Draw planted garden plants
function drawGardenPlants(t) {
  if (!state || !state.gardenPlants || state.gardenPlants.length === 0) return;
  
  const w = vw(), h = vh();
  const gy = h * 0.70; // slightly above main garden elements
  const emojiSize = Math.round(Math.min(w, h) * 0.035);
  
  ctx.font = emojiSize + 'px sans-serif';
  ctx.textAlign = 'center';
  
  for (let i = 0; i < state.gardenPlants.length; i++) {
    const plant = state.gardenPlants[i];
    const px = plant.x * w;
    const py = gy + (plant.stage * -3); // taller plants grow upward
    
    // Growth-based size
    const sizeMultiplier = 0.7 + (plant.stage * 0.15);
    ctx.font = Math.round(emojiSize * sizeMultiplier) + 'px sans-serif';
    
    // Gentle sway animation
    const sway = Math.sin(t * 0.0015 + i * 2) * (2 + plant.stage);
    
    // Glow for fully grown plants
    if (plant.stage >= 3) {
      ctx.globalAlpha = 0.3 + Math.sin(t * 0.003 + i) * 0.15;
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.arc(px, py, emojiSize * 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    // Draw plant emoji based on stage
    const emoji = PLANT_STAGES[Math.min(plant.stage, PLANT_STAGES.length - 1)];
    ctx.fillText(emoji, px + sway, py);
    
    // Small dirt mound
    ctx.fillStyle = 'rgba(101,67,33,0.4)';
    ctx.beginPath();
    ctx.ellipse(px, gy + 8, emojiSize * 0.4, emojiSize * 0.12, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.textAlign = 'start';
}

// Draw companion pet
function drawCompanion(t) {
  if (!state || !state.companion) return;
  
  const companion = COMPANION_TYPES[state.companion.type];
  if (!companion) return;
  
  const h = vh();
  const baseY = h * 0.62;
  const y = baseY + companionBounce;
  
  // Calculate size (40% of pet size)
  const size = petSize() * 0.4;
  
  // Shadow
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(companionX, baseY + size * 0.4, size * 0.4, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  // Bounce animation
  const bounce = Math.sin(t * 0.006) * 3;
  
  // Draw companion emoji
  ctx.font = Math.round(size) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(companion.emoji, companionX, y + bounce);
  
  // Heart particle during play
  if (gardenActivity === 'playingWithFriend' && Math.random() < 0.01) {
    spawnParticle(companionX + (Math.random() - 0.5) * 20, y - 10, 'üíï');
  }
  
  ctx.textAlign = 'start';
}

// Draw poop on screen
function drawPoops(t) {
  if (!state || state.poopCount <= 0 || state.stage === 'EGG') return;
  const sz = petSize() * 0.3;
  ctx.font = Math.round(sz) + 'px sans-serif';
  for (let i = 0; i < state.poopCount; i++) {
    const px = petX() + petSize() * 0.6 + i * sz * 0.8;
    const py = petY() + petSize() * 0.3 + Math.sin(t * 0.003 + i) * 3;
    ctx.fillText('üí©', px, py);
    // Stink
    ctx.globalAlpha = 0.3 + Math.sin(t*0.005+i)*0.15;
    ctx.font = Math.round(sz*0.4) + 'px sans-serif';
    ctx.fillText('~', px + sz*0.5, py - sz*0.5 - Math.sin(t*0.008+i)*5);
    ctx.globalAlpha = 1;
    ctx.font = Math.round(sz) + 'px sans-serif';
  }
}

// Dead pet
function drawDeadPet() {
  const sz = petSize();
  ctx.font = Math.round(sz * 0.8) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('üëª', petX(), petY());
  ctx.font = '18px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('Your pet has passed away...', petX(), petY() + sz * 0.6);
  ctx.font = '14px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillText('Tap anywhere for a new egg', petX(), petY() + sz * 0.6 + 24);
  ctx.textAlign = 'start';
}

// Evolution animation
let evolveAnim = null;
function drawEvolveAnim(t) {
  if (!evolveAnim) return false;
  const elapsed = t - evolveAnim.start;
  if (elapsed > 3500) { evolveAnim = null; return false; }

  // Flash overlay
  const flash = elapsed < 1500 ? Math.sin(elapsed * 0.015) * 0.5 + 0.5 : 0;
  if (flash > 0) {
    ctx.fillStyle = `rgba(255,255,255,${flash * 0.6})`;
    ctx.fillRect(0, 0, vw(), vh());
  }

  // Text
  if (elapsed > 1200) {
    ctx.textAlign = 'center';
    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = `rgba(255,255,255,${Math.min(1, (elapsed-1200)/500)})`;
    ctx.fillText('Evolved to ' + state.stage + '!', vw()/2, vh() * 0.25);
    ctx.textAlign = 'start';
  }

  // Sparkles
  if (elapsed < 2500 && Math.random() < 0.3) {
    spawnParticle(petX() + (Math.random()-0.5)*petSize(), petY() + (Math.random()-0.5)*petSize(), '‚ú®');
  }

  return true;
}

// ============================================================
// GARDEN AUTONOMOUS BEHAVIOR
// ============================================================
let gardenMode = false;
let gardenActivity = 'idle'; // 'idle','walking','watering','planting','picking','digging','sniffing'
let gardenTargetX = 0; // target X position (absolute)
let gardenTargetIdx = -1; // index into GARDEN_ELEMENTS for current target
let gardenActivityTimer = 0; // ms remaining on current activity
let gardenWalkSpeed = 0; // pixels per ms
let lastInteraction = Date.now();
const IDLE_THRESHOLD = 8000; // ms before pet starts gardening
const GARDEN_WALK_SPEED = 0.12; // pixels per ms
const GARDEN_ACTIVITY_DURATION = 3500; // ms per activity
const GARDEN_ACTIVITIES = ['watering','planting','picking','digging','sniffing'];
const GARDEN_ACTIVITY_EMOJIS = { watering:'üíß', planting:'üå±', picking:'‚úÇÔ∏è', digging:'üï≥Ô∏è', sniffing:'üëÉ', chasingBalloon:'üéà', playingWithFriend:'üíï' };

// Balloon constants
const BALLOON_SPAWN_CHANCE = 0.10; // 10% chance per activity completion
const BALLOON_COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181', '#aa96da'];
const BALLOON_SPEED = 0.04; // pixels per ms horizontal drift

// Companion constants
const COMPANION_TYPES = [
  { emoji: 'üê¶', name: 'bird' },
  { emoji: 'ü¶ã', name: 'butterfly' },
  { emoji: 'üê∞', name: 'bunny' },
  { emoji: 'üêøÔ∏è', name: 'squirrel' },
  { emoji: 'üê∏', name: 'frog' }
];
const COMPANION_UNLOCK_CARE_SCORE = 70;
const COMPANION_UNLOCK_TIME_MS = 60 * 60 * 1000; // 1 hour

// Plant growth stages
const PLANT_STAGES = ['üå±', 'üåø', 'üå∏', 'üå∫'];
const PLANT_GROWTH_TIME = 120000; // 2 minutes per stage
const MAX_GARDEN_PLANTS = 6;

// Weighted garden activities
const GARDEN_ACTIVITIES_WEIGHTED = [
  { activity: 'watering', weight: 2 },
  { activity: 'planting', weight: 2 },
  { activity: 'picking', weight: 1 },
  { activity: 'digging', weight: 1 },
  { activity: 'sniffing', weight: 1 },
  { activity: 'playingWithFriend', weight: 3, requiresCompanion: true },
  { activity: 'chasingBalloon', weight: 0, triggeredByBalloon: true }
];

// Balloon state
let gardenBalloon = { x: 0, y: 0, vx: 0, vy: 0, active: false, color: '#ff6b6b', baseY: 0, time: 0 };

// Companion state (runtime)
let companionX = 0;
let companionTargetX = 0;
let companionBounce = 0;

function resetGardenMode() {
  gardenMode = false;
  gardenActivity = 'idle';
  gardenTargetIdx = -1;
  gardenActivityTimer = 0;
  gardenBalloon.active = false;
}

function pickGardenTarget() {
  const landscapeId = (state && state.landscape) || 0;
  const elements = GARDEN_ELEMENTS[landscapeId] || GARDEN_ELEMENTS[0];
  let idx;
  do { idx = Math.floor(Math.random() * elements.length); } while (idx === gardenTargetIdx && elements.length > 1);
  gardenTargetIdx = idx;
  gardenTargetX = elements[idx].x * vw() - vw() / 2; // offset from center
  gardenActivity = 'walking';
}

// ---- BALLOON SYSTEM ----
function spawnBalloon() {
  const w = vw(), h = vh();
  gardenBalloon.x = Math.random() * w * 0.6 + w * 0.2; // spawn in middle 60%
  gardenBalloon.baseY = h * 0.35; // float above pet
  gardenBalloon.y = gardenBalloon.baseY;
  gardenBalloon.vx = (Math.random() - 0.5) * BALLOON_SPEED * 2;
  gardenBalloon.vy = 0;
  gardenBalloon.color = BALLOON_COLORS[Math.floor(Math.random() * BALLOON_COLORS.length)];
  gardenBalloon.active = true;
  gardenBalloon.time = 0;
}

function updateBalloon(dt) {
  if (!gardenBalloon.active) return;
  
  const w = vw();
  gardenBalloon.time += dt;
  
  // Gentle sine-wave bobbing
  gardenBalloon.y = gardenBalloon.baseY + Math.sin(gardenBalloon.time * 0.002) * 15;
  
  // Horizontal drift with random direction changes
  gardenBalloon.x += gardenBalloon.vx * dt;
  if (Math.random() < dt * 0.0005) {
    gardenBalloon.vx = (Math.random() - 0.5) * BALLOON_SPEED * 2;
  }
  
  // Bounce off screen edges
  if (gardenBalloon.x < w * 0.1) {
    gardenBalloon.x = w * 0.1;
    gardenBalloon.vx = Math.abs(gardenBalloon.vx);
  } else if (gardenBalloon.x > w * 0.9) {
    gardenBalloon.x = w * 0.9;
    gardenBalloon.vx = -Math.abs(gardenBalloon.vx);
  }
}

function catchBalloon() {
  if (!gardenBalloon.active) return;
  
  // Celebration particles
  for (let i = 0; i < 5; i++) {
    spawnParticle(gardenBalloon.x + (Math.random() - 0.5) * 30, gardenBalloon.y + (Math.random() - 0.5) * 30, 'üéà');
  }
  spawnParticle(gardenBalloon.x, gardenBalloon.y, 'üí•');
  
  // Small happiness boost
  if (state) {
    state.happiness = Math.min(100, state.happiness + 2);
    save();
  }
  
  gardenBalloon.active = false;
}

// ---- PLANTING SYSTEM ----
function updateGardenPlants(dt) {
  if (!state || !state.gardenPlants) return;
  
  const now = Date.now();
  for (let plant of state.gardenPlants) {
    const age = now - plant.plantedAt;
    const newStage = Math.min(3, Math.floor(age / PLANT_GROWTH_TIME));
    if (newStage !== plant.stage) {
      plant.stage = newStage;
      save();
    }
  }
}

function addGardenPlant() {
  if (!state || !state.gardenPlants) return;
  if (state.gardenPlants.length >= MAX_GARDEN_PLANTS) return;
  
  // Find a spot that isn't too close to existing plants
  const w = vw();
  let x, attempts = 0;
  do {
    x = 0.15 + Math.random() * 0.7; // 15% to 85% of screen
    attempts++;
  } while (attempts < 20 && state.gardenPlants.some(p => Math.abs(p.x - x) < 0.1));
  
  const plant = {
    x: x,
    type: Math.floor(Math.random() * 4),
    plantedAt: Date.now(),
    stage: 0
  };
  
  state.gardenPlants.push(plant);
  spawnParticle(x * w, vh() * 0.7, 'üå±');
  save();
}

function harvestPlant() {
  if (!state || !state.gardenPlants) return false;
  
  // Find a fully grown plant
  const idx = state.gardenPlants.findIndex(p => p.stage >= 3);
  if (idx === -1) return false;
  
  const plant = state.gardenPlants[idx];
  const w = vw();
  
  // Remove and give reward
  state.gardenPlants.splice(idx, 1);
  state.happiness = Math.min(100, state.happiness + 3);
  
  // Celebration
  spawnParticle(plant.x * w, vh() * 0.68, 'üå∫');
  spawnParticle(plant.x * w, vh() * 0.68, '‚ú®');
  save();
  
  return true;
}

// ---- COMPANION SYSTEM ----
function checkCompanionUnlock() {
  if (!state || state.companion) return; // Already unlocked
  
  if (state.careScore >= COMPANION_UNLOCK_CARE_SCORE && state.totalTime >= COMPANION_UNLOCK_TIME_MS) {
    // Unlock companion!
    state.companion = {
      type: Math.floor(Math.random() * COMPANION_TYPES.length),
      unlockedAt: Date.now()
    };
    
    // Initialize companion position
    companionX = petX() - 60;
    companionTargetX = companionX;
    
    // Notification and celebration
    const companion = COMPANION_TYPES[state.companion.type];
    notify(`${companion.emoji} Your pet made a friend!`);
    for (let i = 0; i < 3; i++) {
      spawnParticle(petX() - 40 + Math.random() * 20, petY() - 20 + Math.random() * 20, 'üíï');
    }
    sfxConfirm();
    save();
  }
}

function updateCompanion(dt) {
  if (!state || !state.companion) return;
  
  // Companion follows pet at a distance
  const targetOffset = gardenMode ? -50 : -40;
  companionTargetX = petX() + targetOffset;
  
  // Smooth follow
  companionX += (companionTargetX - companionX) * Math.min(1, dt * 0.004);
  
  // Bounce animation during play
  if (gardenActivity === 'playingWithFriend') {
    companionBounce = Math.sin(Date.now() * 0.008) * 8;
  } else {
    companionBounce *= 0.95;
  }
}

// ---- WEIGHTED ACTIVITY SELECTION ----
function pickWeightedActivity() {
  const hasCompanion = state && state.companion;
  
  // Filter activities by requirements
  const available = GARDEN_ACTIVITIES_WEIGHTED.filter(a => {
    if (a.requiresCompanion && !hasCompanion) return false;
    if (a.triggeredByBalloon) return false; // Balloon chasing is triggered separately
    return true;
  });
  
  // Calculate total weight
  const totalWeight = available.reduce((sum, a) => sum + a.weight, 0);
  let random = Math.random() * totalWeight;
  
  for (const a of available) {
    random -= a.weight;
    if (random <= 0) return a.activity;
  }
  
  return 'sniffing'; // Fallback
}

function updateGarden(dt) {
  if (!state || !state.alive || state.stage === 'EGG' || state.sleeping) {
    if (gardenMode) resetGardenMode();
    gardenPetOffsetX += (0 - gardenPetOffsetX) * Math.min(1, dt * 0.008);
    if (Math.abs(gardenPetOffsetX) < 0.5) gardenPetOffsetX = 0;
    return;
  }

  const now = Date.now();
  
  // Update subsystems
  updateBalloon(dt);
  updateGardenPlants(dt);
  updateCompanion(dt);
  checkCompanionUnlock();

  if (!gardenMode) {
    // Check if idle long enough OR tab is hidden
    if (now - lastInteraction > IDLE_THRESHOLD || document.hidden) {
      gardenMode = true;
      pickGardenTarget();
    } else {
      // Smoothly return to center
      gardenPetOffsetX += (0 - gardenPetOffsetX) * Math.min(1, dt * 0.008);
      if (Math.abs(gardenPetOffsetX) < 0.5) gardenPetOffsetX = 0;
    }
    return;
  }

  // Garden mode active
  if (gardenActivity === 'walking') {
    const diff = gardenTargetX - gardenPetOffsetX;
    if (Math.abs(diff) < 3) {
      gardenPetOffsetX = gardenTargetX;
      
      // If balloon is active, chase it instead
      if (gardenBalloon.active) {
        gardenActivity = 'chasingBalloon';
        gardenActivityTimer = GARDEN_ACTIVITY_DURATION;
      } else {
        // Pick weighted activity
        gardenActivity = pickWeightedActivity();
        gardenActivityTimer = GARDEN_ACTIVITY_DURATION;
      }
    } else {
      gardenPetOffsetX += Math.sign(diff) * Math.min(Math.abs(diff), GARDEN_WALK_SPEED * dt);
    }
  } else if (gardenActivity === 'chasingBalloon') {
    // Chase the balloon
    if (!gardenBalloon.active) {
      pickGardenTarget();
      return;
    }
    
    const balloonOffsetX = gardenBalloon.x - vw() / 2;
    const diff = balloonOffsetX - gardenPetOffsetX;
    
    if (Math.abs(diff) < 25) {
      // Caught it!
      catchBalloon();
      pickGardenTarget();
    } else {
      gardenPetOffsetX += Math.sign(diff) * Math.min(Math.abs(diff), GARDEN_WALK_SPEED * 1.3 * dt);
      
      // Spawn excited particles
      if (Math.random() < dt * 0.002) {
        spawnParticle(petX() + (Math.random() - 0.5) * 20, petY() - petSize() * 0.3, '‚ú®');
      }
    }
    
    gardenActivityTimer -= dt;
    if (gardenActivityTimer <= 0) {
      // Balloon escaped, move on
      gardenBalloon.active = false;
      pickGardenTarget();
    }
  } else if (gardenActivity === 'playingWithFriend') {
    // Playing with companion
    gardenActivityTimer -= dt;
    
    // Spawn heart particles
    if (Math.random() < dt * 0.004) {
      spawnParticle(petX() - 25 + Math.random() * 50, petY() - petSize() * 0.5, 'üíï');
    }
    
    if (gardenActivityTimer <= 0) {
      // Chance to spawn balloon after activity
      if (Math.random() < BALLOON_SPAWN_CHANCE && !gardenBalloon.active) {
        spawnBalloon();
      }
      pickGardenTarget();
    }
  } else if (gardenActivity === 'planting') {
    // Planting activity - may add a plant
    gardenActivityTimer -= dt;
    
    if (Math.random() < dt * 0.003) {
      const emoji = GARDEN_ACTIVITY_EMOJIS[gardenActivity] || '‚ú®';
      spawnParticle(petX() + (Math.random() - 0.5) * 30, petY() - petSize() * 0.5, emoji);
    }
    
    if (gardenActivityTimer <= 0) {
      // 40% chance to actually plant something
      if (Math.random() < 0.4 && state.gardenPlants.length < MAX_GARDEN_PLANTS) {
        addGardenPlant();
      }
      
      // Chance to spawn balloon after activity
      if (Math.random() < BALLOON_SPAWN_CHANCE && !gardenBalloon.active) {
        spawnBalloon();
      }
      pickGardenTarget();
    }
  } else if (gardenActivity === 'picking') {
    // Picking activity - may harvest a plant
    gardenActivityTimer -= dt;
    
    if (Math.random() < dt * 0.003) {
      const emoji = GARDEN_ACTIVITY_EMOJIS[gardenActivity] || '‚ú®';
      spawnParticle(petX() + (Math.random() - 0.5) * 30, petY() - petSize() * 0.5, emoji);
    }
    
    if (gardenActivityTimer <= 0) {
      // Try to harvest a fully grown plant
      harvestPlant();
      
      // Chance to spawn balloon after activity
      if (Math.random() < BALLOON_SPAWN_CHANCE && !gardenBalloon.active) {
        spawnBalloon();
      }
      pickGardenTarget();
    }
  } else if (gardenActivity !== 'idle') {
    // Other activities (watering, digging, sniffing)
    gardenActivityTimer -= dt;
    
    // Spawn activity particles occasionally
    if (Math.random() < dt * 0.003) {
      const emoji = GARDEN_ACTIVITY_EMOJIS[gardenActivity] || '‚ú®';
      spawnParticle(petX() + (Math.random() - 0.5) * 30, petY() - petSize() * 0.5, emoji);
    }
    
    if (gardenActivityTimer <= 0) {
      // Chance to spawn balloon after activity
      if (Math.random() < BALLOON_SPAWN_CHANCE && !gardenBalloon.active) {
        spawnBalloon();
      }
      pickGardenTarget();
    }
  }
}

function onUserInteraction() {
  lastInteraction = Date.now();
  if (gardenMode) {
    resetGardenMode();
    // gardenPetOffsetX will lerp back to 0 in updateGarden
  }
}

// ============================================================
// GAME STATE
// ============================================================
let state = null;

function newState() {
  return {
    stage:'EGG', variant:0, stageTime:0, totalTime:0,
    hunger:80, happiness:80, energy:100, hygiene:100, health:100,
    careScore:50, feedCount:0, playCount:0, missedCare:0,
    happinessSum:0, happinessSamples:0,
    poopCount:0, poopTimer:0,
    sleeping:false, alive:true, accessory:0,
    unlockedAccessories:[],
    house:0, landscape:0, unlockedHouses:[],
    gardenPlants:[], // {x, type, plantedAt, stage: 0-3}
    companion:null, // {type: 0-4, unlockedAt: timestamp}
    lastUpdate:Date.now(), created:Date.now()
  };
}

function save() { try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); } catch(e){} }
function load() { 
  try { 
    const d=localStorage.getItem(SAVE_KEY); 
    if(d){
      state=JSON.parse(d);
      // Migration: add missing fields
      if(!state.unlockedAccessories) state.unlockedAccessories=[];
      if(!state.unlockedHouses) state.unlockedHouses=[];
      if(state.house===undefined) state.house=0;
      if(state.landscape===undefined) state.landscape=0;
      // Garden autonomous life migrations
      if(!state.gardenPlants) state.gardenPlants=[];
      if(state.companion===undefined) state.companion=null;
      // Validate gardenPlants array structure
      if(Array.isArray(state.gardenPlants)) {
        state.gardenPlants = state.gardenPlants.filter(p => 
          p && typeof p.x === 'number' && typeof p.plantedAt === 'number'
        );
        // Update plant stages based on elapsed time
        const now = Date.now();
        for(let plant of state.gardenPlants) {
          if(plant.stage === undefined) plant.stage = 0;
          const age = now - plant.plantedAt;
          plant.stage = Math.min(3, Math.floor(age / PLANT_GROWTH_TIME));
        }
      }
      return true;
    } 
  } catch(e){} 
  return false; 
}

function applyOfflineDecay() {
  if (!state||!state.alive||state.stage==='EGG') return;
  const now=Date.now();
  let elapsed=Math.min(now-state.lastUpdate, MAX_OFFLINE_MS);
  if (elapsed<1000) return;
  const secs=elapsed/1000, sm=state.sleeping?0.3:1;
  state.hunger=Math.max(0,state.hunger-DECAY.hunger*secs*sm);
  state.happiness=Math.max(0,state.happiness-DECAY.happiness*secs*sm);
  state.energy=state.sleeping?Math.min(100,state.energy+0.05*secs):Math.max(0,state.energy-DECAY.energy*secs);
  state.hygiene=Math.max(0,state.hygiene-DECAY.hygiene*secs*sm);
  if (state.hunger<10||state.hygiene<10) state.health=Math.max(0,state.health-DECAY.health*secs*2);
  state.poopTimer+=elapsed;
  while(state.poopTimer>60000&&state.poopCount<5){state.poopTimer-=60000;state.poopCount++;state.hygiene=Math.max(0,state.hygiene-10);}
  state.stageTime+=elapsed; state.totalTime+=elapsed;
  if(state.health<=0) state.alive=false;
  state.lastUpdate=now;
}

function getMood() {
  if(!state||!state.alive) return 'dead';
  if(state.stage==='EGG') return 'neutral';
  if(state.sleeping) return 'sleepy';
  if(state.health<20) return 'sick';
  if(state.hunger<20) return 'hungry';
  if(state.hygiene<20) return 'dirty';
  if(state.energy<15) return 'sleepy';
  const avg=(state.hunger+state.happiness+state.energy+state.hygiene+state.health)/5;
  if(avg>85) return 'ecstatic';
  if(avg>60) return 'happy';
  if(state.happiness<30) return 'sad';
  return 'neutral';
}

function getStageIndex(s){ return ['EGG','BABY','CHILD','TEEN','ADULT'].indexOf(s); }

function updateCareScore() {
  if(state.happinessSamples>0){
    const avg=state.happinessSum/state.happinessSamples;
    state.careScore=Math.max(0,Math.min(100, avg*0.4+Math.min(state.feedCount,50)*0.6+Math.min(state.playCount,30)*0.8-state.missedCare*2));
  }
}

function checkEvolution() {
  if(!state.alive||state.stage==='ADULT') return;
  if(state.stageTime>=STAGES[state.stage].dur*1000) evolve();
}

function evolve() {
  updateCareScore();
  const cs=state.careScore;
  if(state.stage==='EGG') state.stage='BABY';
  else if(state.stage==='BABY'){state.stage='CHILD';state.variant=cs>=50?0:1;}
  else if(state.stage==='CHILD'){state.stage='TEEN';state.variant=cs>=75?0:cs>=50?1:cs>=25?2:3;}
  else if(state.stage==='TEEN'){state.stage='ADULT';state.variant=cs>=85?0:cs>=70?1:cs>=55?3:cs>=40?5:cs>=20?4:2;}
  state.stageTime=0;
  evolveAnim={start:performance.now()};
  sfxEvolve();
  save();
  updateHUD();
  buildDressPanel();
  // Notify chat system of evolution
  if(typeof clearChatOnEvolve === 'function') clearChatOnEvolve();
  if(typeof updateChatUI === 'function') updateChatUI();
}

// ============================================================
// SOUND
// ============================================================
let audioCtx=null;
function getAudioCtx(){if(!audioCtx)audioCtx=new(window.AudioContext||window.webkitAudioContext)();return audioCtx;}
function beep(f,d,type){try{const ctx=getAudioCtx();const o=ctx.createOscillator(),g=ctx.createGain();o.type=type||'square';o.frequency.value=f;g.gain.value=0.04;g.gain.exponentialRampToValueAtTime(0.001,ctx.currentTime+(d||0.1));o.connect(g);g.connect(ctx.destination);o.start();o.stop(ctx.currentTime+(d||0.1));}catch(e){}}
function sfxSelect(){beep(880,0.05);}
function sfxConfirm(){beep(660,0.05);setTimeout(()=>beep(880,0.08),60);}
function sfxDeny(){beep(220,0.15);}
function sfxEvolve(){beep(440,0.1);setTimeout(()=>beep(550,0.1),100);setTimeout(()=>beep(660,0.1),200);setTimeout(()=>beep(880,0.15),300);}

// Cute pet sounds
function playNote(freq, duration, type='sine', volume=0.08, delay=0) {
  try {
    const ctx = getAudioCtx();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, ctx.currentTime + delay);
    gain.gain.setValueAtTime(volume, ctx.currentTime + delay);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + duration);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(ctx.currentTime + delay);
    osc.stop(ctx.currentTime + delay + duration);
  } catch(e) {}
}

// Baby giggle sound
function sfxBabyGiggle() {
  const notes = [600, 800, 700, 900, 750, 850];
  notes.forEach((n, i) => {
    playNote(n + Math.random()*50, 0.08, 'sine', 0.06, i * 0.07);
  });
}

// Baby coo sound
function sfxBabyCoo() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.linearRampToValueAtTime(600, ctx.currentTime + 0.15);
  osc.frequency.linearRampToValueAtTime(500, ctx.currentTime + 0.3);
  gain.gain.setValueAtTime(0.08, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.35);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.35);
}

// Child happy sound
function sfxChildHappy() {
  playNote(523, 0.12, 'sine', 0.07, 0);      // C
  playNote(659, 0.12, 'sine', 0.07, 0.1);    // E
  playNote(784, 0.15, 'sine', 0.07, 0.2);    // G
}

// Child curious sound
function sfxChildCurious() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.linearRampToValueAtTime(700, ctx.currentTime + 0.25);
  gain.gain.setValueAtTime(0.07, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.3);
}

// Teen sound (more chill)
function sfxTeenSound() {
  playNote(350, 0.15, 'triangle', 0.06, 0);
  playNote(400, 0.2, 'triangle', 0.05, 0.12);
}

// Adult wise sound (warm chord)
function sfxAdultSound() {
  playNote(262, 0.3, 'sine', 0.04, 0);  // C
  playNote(330, 0.3, 'sine', 0.04, 0);  // E
  playNote(392, 0.3, 'sine', 0.04, 0);  // G
  playNote(523, 0.25, 'sine', 0.03, 0.15); // High C
}

// Play appropriate sound based on stage and mood
function sfxPetSpeak(stage, mood) {
  const isHappy = mood === 'happy' || mood === 'ecstatic';
  
  switch(stage) {
    case 'BABY':
      if (isHappy) sfxBabyGiggle();
      else sfxBabyCoo();
      break;
    case 'CHILD':
      if (isHappy) sfxChildHappy();
      else sfxChildCurious();
      break;
    case 'TEEN':
      sfxTeenSound();
      break;
    case 'ADULT':
      sfxAdultSound();
      break;
    default:
      sfxSelect();
  }
}

// ============================================================
// TEXT-TO-SPEECH
// ============================================================
let ttsEnabled = true;
let ttsVoices = {}; // Stage-specific voices

// Initialize TTS voices (different voices for different stages)
function initTTS() {
  if (!('speechSynthesis' in window)) {
    console.log('Text-to-speech not supported');
    ttsEnabled = false;
    return;
  }
  
  const loadVoices = () => {
    const voices = speechSynthesis.getVoices();
    if (voices.length === 0) return;
    
    // Helper to find voice by name
    const findVoice = (names) => {
      for (const name of names) {
        const found = voices.find(v => v.name.toLowerCase().includes(name.toLowerCase()));
        if (found) return found;
      }
      return null;
    };
    
    // Child-like voices for BABY and CHILD stages (cute, high-pitched)
    // These are actual child voices or voices that sound young
    const childVoices = [
      'Junior',           // macOS - young boy voice, very cute
      'Bubbles',          // macOS - playful bubbly voice  
      'Whisper',          // macOS - soft whispery voice
      'Princess',         // Some systems
      'Zarvox',           // macOS - unique, can sound cute with high pitch
      'Bells',            // macOS - bell-like, childish
      'Trinoids',         // macOS - unique character voice
      'Good News',        // macOS - cheerful
      'Kathy',            // macOS - can sound younger
      'Sandy',            // Some systems - young female
    ];
    
    // Teen/young adult voices
    const teenVoices = ['Samantha', 'Nicky', 'Tessa', 'Ava', 'Allison', 'Kate'];
    
    // Adult voices 
    const adultVoices = ['Samantha', 'Victoria', 'Karen', 'Moira', 'Fiona', 'Daniel', 'Alex'];
    
    // Fallback English voice
    const fallback = voices.find(v => v.lang.startsWith('en')) || voices[0];
    
    // Assign voices by stage
    ttsVoices.BABY = findVoice(childVoices) || fallback;
    ttsVoices.CHILD = findVoice(childVoices) || findVoice(teenVoices) || fallback;
    ttsVoices.TEEN = findVoice(teenVoices) || fallback;
    ttsVoices.ADULT = findVoice(adultVoices) || fallback;
    ttsVoices.EGG = findVoice(childVoices) || fallback;
    
    console.log('TTS Voices loaded:', Object.keys(ttsVoices).map(k => `${k}: ${ttsVoices[k]?.name}`));
  };
  
  loadVoices();
  if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = loadVoices;
  }
}

// Speak text with stage-appropriate voice settings
function speakText(text, stage) {
  if (!ttsEnabled || !('speechSynthesis' in window)) return;
  
  // Cancel any ongoing speech
  speechSynthesis.cancel();
  
  // Remove emojis for cleaner speech
  const cleanText = text.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F600}-\u{1F64F}]|[\u{1F680}-\u{1F6FF}]/gu, '').trim();
  if (!cleanText) return;
  
  const utterance = new SpeechSynthesisUtterance(cleanText);
  
  // Set stage-appropriate voice
  const voice = ttsVoices[stage] || ttsVoices.BABY;
  if (voice) utterance.voice = voice;
  utterance.lang = 'en-US';
  
  // Adjust pitch and rate based on stage for maximum cuteness
  switch(stage) {
    case 'BABY':
      // Maximum cuteness for baby - very high pitch, slightly faster for energetic feel
      utterance.pitch = 2.0;  // Maximum pitch for super cute baby voice
      utterance.rate = 1.1;   // Slightly faster - energetic toddler
      break;
    case 'CHILD':
      // Cute child voice - still high pitch
      utterance.pitch = 1.8;  // High pitch for child
      utterance.rate = 1.15;  // Energetic child pace
      break;
    case 'TEEN':
      utterance.pitch = 1.3;  // Slightly higher
      utterance.rate = 1.05;  // Slightly faster
      break;
    case 'ADULT':
      utterance.pitch = 1.1;  // Near normal
      utterance.rate = 0.95;  // Calm pace
      break;
    default:
      // Default to cute baby settings
      utterance.pitch = 2.0;
      utterance.rate = 1.1;
  }
  
  utterance.volume = 0.9;
  
  speechSynthesis.speak(utterance);
}

// Toggle TTS on/off
function toggleTTS() {
  ttsEnabled = !ttsEnabled;
  if (!ttsEnabled) speechSynthesis.cancel();
  const btn = document.getElementById('tts-toggle');
  if (btn) {
    btn.textContent = ttsEnabled ? 'üîä' : 'üîá';
    btn.classList.toggle('muted', !ttsEnabled);
  }
  notify(ttsEnabled ? 'üîä Voice enabled' : 'üîá Voice disabled');
  sfxSelect();
}
window.toggleTTS = toggleTTS;

// ============================================================
// NOTIFICATION
// ============================================================
const notifEl=document.getElementById('notif');
let notifTimer=null;
function notify(msg){notifEl.textContent=msg;notifEl.classList.add('show');clearTimeout(notifTimer);notifTimer=setTimeout(()=>notifEl.classList.remove('show'),2500);}

// ============================================================
// HUD UPDATE
// ============================================================
function updateHUD() {
  if(!state) return;
  const mood=getMood();
  const moodEmojis={ecstatic:'üòç',happy:'üòä',neutral:'üòê',sad:'üò¢',hungry:'üçΩÔ∏è',sleepy:'üò¥',dirty:'ü§¢',sick:'ü§í',dead:'üíÄ'};
  document.getElementById('mood-badge').textContent=(moodEmojis[mood]||'')+ ' ' + mood.charAt(0).toUpperCase()+mood.slice(1);
  document.getElementById('stage-badge').textContent=state.stage + (state.stage==='ADULT'?' ‚òÖ':'');
  document.getElementById('age-badge').textContent=formatTime(state.totalTime);

  document.getElementById('bar-hunger').style.width=Math.round(state.hunger)+'%';
  document.getElementById('bar-happy').style.width=Math.round(state.happiness)+'%';
  document.getElementById('bar-energy').style.width=Math.round(state.energy)+'%';
  document.getElementById('bar-hygiene').style.width=Math.round(state.hygiene)+'%';
  document.getElementById('bar-health').style.width=Math.round(state.health)+'%';

  // Disable buttons for egg
  const isEgg=state.stage==='EGG';
  document.querySelectorAll('.action-btn').forEach(b=>{
    const a=b.dataset.action;
    if(a==='stats'||a==='home') b.classList.toggle('disabled',false);
    else b.classList.toggle('disabled',isEgg||(!state.alive));
  });

  // Update sleep button text
  const sleepBtn=document.querySelector('[data-action="sleep"]');
  if(sleepBtn){
    sleepBtn.querySelector('.label').textContent=state.sleeping?'Wake':'Sleep';
    sleepBtn.querySelector('.icon').textContent=state.sleeping?'‚òÄÔ∏è':'üí§';
  }
  
  // Update chat UI if function exists
  if(typeof updateChatUI === 'function') updateChatUI();
}

function formatTime(ms){
  const s=Math.floor(ms/1000),m=Math.floor(s/60),h=Math.floor(m/60);
  if(h>0) return h+'h '+( m%60)+'m';
  return m+'m '+(s%60)+'s';
}

// ============================================================
// PANELS
// ============================================================
function openPanel(name){
  document.getElementById(name+'-panel').classList.add('open');
  sfxSelect();
}
function closePanel(name){
  document.getElementById(name+'-panel').classList.remove('open');
}
// expose globally for onclick
window.closePanel=closePanel;

function buildFeedPanel(){
  const grid=document.getElementById('food-grid');
  grid.innerHTML='';
  FOODS.forEach((f,i)=>{
    const card=document.createElement('div');
    card.className='food-card';
    const statLine=(k,v)=>`<span class="${v>=0?'pos':'neg'}">${v>=0?'+':''}${v} ${k}</span>`;
    card.innerHTML=`<div class="food-icon">${f.emoji}</div><div class="food-name">${f.name}</div><div class="food-stat">${statLine('hun',f.hunger)}<br>${statLine('hap',f.happiness)}<br>${statLine('hp',f.health)}</div>`;
    card.onclick=()=>{feedPet(i);closePanel('feed');};
    grid.appendChild(card);
  });
}

function buildDressPanel(){
  const grid=document.getElementById('acc-grid');
  grid.innerHTML='';
  const si=getStageIndex(state.stage);
  ACCESSORIES.forEach(a=>{
    const card=document.createElement('div');
    
    // Check lock type
    const isStageLocked = a.stage !== undefined && a.stage > si;
    const isMathLocked = a.mathLevel !== undefined && !state.unlockedAccessories.includes(a.id);
    const isUnlocked = !isStageLocked && !isMathLocked;
    
    // Set classes
    let className = 'acc-card';
    if (isStageLocked) className += ' locked';
    else if (isMathLocked) className += ' math-locked';
    if (state.accessory === a.id) className += ' active-acc';
    card.className = className;
    
    // Set content
    if (isStageLocked) {
      card.innerHTML = `<div class="acc-icon">üîí</div><div class="acc-name">Locked</div>`;
    } else if (isMathLocked) {
      const levelNames = ['', 'Easy', 'Medium', 'Tricky', 'Challenge'];
      card.innerHTML = `<div class="acc-icon">üß©</div><div class="acc-name">${a.name}</div><div class="acc-level">Lv${a.mathLevel} ${levelNames[a.mathLevel]}</div>`;
      card.onclick = () => openMathRiddle(a, 'acc');
    } else {
      card.innerHTML = `<div class="acc-icon">${a.emoji}</div><div class="acc-name">${a.name}</div>`;
      card.onclick = () => {
        state.accessory = a.id;
        notify('Wearing: ' + a.name);
        sfxConfirm();
        closePanel('dress');
        save();
        buildDressPanel();
      };
    }
    
    grid.appendChild(card);
  });
}

// ============================================================
// MATH RIDDLE SYSTEM
// ============================================================
const MATH_DIFFICULTY = {
  1: { ops: ['+', '-'], max: 10, name: 'Easy' },
  2: { ops: ['+', '-'], max: 20, name: 'Medium' },
  3: { ops: ['+', '-', '√ó'], max: 12, name: 'Tricky' },
  4: { ops: ['+', '-', '√ó', '√∑'], max: 12, name: 'Challenge' }
};

let currentMathAcc = null;
let currentMathType = 'acc'; // 'acc' or 'house'
let currentMathProblem = null;

function generateMathProblem(level) {
  const config = MATH_DIFFICULTY[level];
  const op = config.ops[Math.floor(Math.random() * config.ops.length)];
  let a, b, answer;
  
  if (op === '+') {
    a = Math.floor(Math.random() * config.max) + 1;
    b = Math.floor(Math.random() * (config.max - a)) + 1;
    answer = a + b;
  } else if (op === '-') {
    a = Math.floor(Math.random() * config.max) + 1;
    b = Math.floor(Math.random() * a) + 1;
    answer = a - b;
  } else if (op === '√ó') {
    a = Math.floor(Math.random() * config.max) + 1;
    b = Math.floor(Math.random() * config.max) + 1;
    answer = a * b;
  } else if (op === '√∑') {
    // Ensure clean division
    b = Math.floor(Math.random() * (config.max - 1)) + 2;
    answer = Math.floor(Math.random() * config.max) + 1;
    a = b * answer;
  }
  
  const question = `${a} ${op} ${b} = ?`;
  
  // Generate 4 choices including the correct answer
  const choices = new Set([answer]);
  while (choices.size < 4) {
    let wrong = answer + Math.floor(Math.random() * 11) - 5;
    if (wrong !== answer && wrong >= 0) choices.add(wrong);
  }
  
  // Shuffle choices
  const shuffled = Array.from(choices).sort(() => Math.random() - 0.5);
  
  return { question, answer, choices: shuffled };
}

function openMathRiddle(acc, type) {
  currentMathAcc = acc;
  currentMathType = type || 'acc';
  currentMathProblem = generateMathProblem(acc.mathLevel);

  document.getElementById('math-prize-emoji').textContent = acc.emoji;
  document.getElementById('math-prize-name').textContent = acc.name;
  document.getElementById('math-difficulty').textContent = `Level ${acc.mathLevel} - ${MATH_DIFFICULTY[acc.mathLevel].name}`;
  document.getElementById('math-question').textContent = currentMathProblem.question;
  document.getElementById('math-feedback').textContent = '';
  document.getElementById('math-feedback').className = 'feedback';

  const choicesDiv = document.getElementById('math-choices');
  choicesDiv.innerHTML = '';
  currentMathProblem.choices.forEach(choice => {
    const btn = document.createElement('button');
    btn.className = 'choice-btn';
    btn.textContent = choice;
    btn.onclick = () => handleMathAnswer(btn, choice);
    choicesDiv.appendChild(btn);
  });

  document.getElementById('math-modal').classList.add('open');
  if (currentMathType === 'house') closePanel('home');
  else closePanel('dress');
  sfxSelect();
}

function handleMathAnswer(btn, chosen) {
  const correct = currentMathProblem.answer;
  const allBtns = document.querySelectorAll('#math-choices .choice-btn');
  const feedback = document.getElementById('math-feedback');
  
  // Disable all buttons
  allBtns.forEach(b => b.disabled = true);
  
  if (chosen === correct) {
    // Correct answer!
    btn.classList.add('correct');
    feedback.textContent = 'üéâ Correct! Accessory unlocked!';
    feedback.className = 'feedback success';
    
    // Unlock item
    if (currentMathType === 'house') {
      state.unlockedHouses.push(currentMathAcc.id);
      state.house = currentMathAcc.id;
    } else {
      state.unlockedAccessories.push(currentMathAcc.id);
      state.accessory = currentMathAcc.id;
    }
    save();
    
    // Celebration
    sfxEvolve();
    for (let i = 0; i < 8; i++) {
      setTimeout(() => {
        spawnParticle(
          vw()/2 + (Math.random()-0.5)*150, 
          vh()/2 + (Math.random()-0.5)*100, 
          ['‚ú®','üéâ','‚≠ê','üí´'][Math.floor(Math.random()*4)]
        );
      }, i * 80);
    }
    
    // Close after delay
    setTimeout(() => {
      closeMathModal();
      notify('üéâ Unlocked: ' + currentMathAcc.name + '!');
    }, 1500);
    
  } else {
    // Wrong answer
    btn.classList.add('wrong');
    // Highlight correct answer
    allBtns.forEach(b => {
      if (parseInt(b.textContent) === correct) b.classList.add('correct');
    });
    feedback.textContent = `The answer was ${correct}. Try again!`;
    feedback.className = 'feedback error';
    sfxDeny();
    
    // Generate new problem after delay
    setTimeout(() => {
      currentMathProblem = generateMathProblem(currentMathAcc.mathLevel);
      document.getElementById('math-question').textContent = currentMathProblem.question;
      feedback.textContent = '';
      feedback.className = 'feedback';
      
      const choicesDiv = document.getElementById('math-choices');
      choicesDiv.innerHTML = '';
      currentMathProblem.choices.forEach(choice => {
        const newBtn = document.createElement('button');
        newBtn.className = 'choice-btn';
        newBtn.textContent = choice;
        newBtn.onclick = () => handleMathAnswer(newBtn, choice);
        choicesDiv.appendChild(newBtn);
      });
    }, 2000);
  }
}

function closeMathModal() {
  document.getElementById('math-modal').classList.remove('open');
  const wasHouse = currentMathType === 'house';
  currentMathAcc = null;
  currentMathProblem = null;
  if (wasHouse) buildHousePanel();
  else buildDressPanel();
}
window.closeMathModal = closeMathModal;

function switchHomeTab(tab) {
  const tabs = ['houses','landscape','friends'];
  document.querySelectorAll('.home-tab').forEach((t,i) => {
    t.classList.toggle('active', tab===tabs[i]);
  });
  tabs.forEach(id => {
    document.getElementById(id+'-section').classList.toggle('active', tab===id);
  });
  if (tab === 'friends') buildFriendsSection();
}
window.switchHomeTab = switchHomeTab;

// ============================================================
// FRIEND PET VISITS - Share Code System
// ============================================================
let visitor = null; // {stage, variant, accessory, house, landscape}

const STAGE_NAMES = ['EGG','BABY','CHILD','TEEN','ADULT'];

function encodePetCode() {
  if (!state) return 'PET-0000';
  const si = getStageIndex(state.stage);
  const v = state.variant || 0;
  const a = state.accessory || 0;
  const h = state.house || 0;
  const l = state.landscape || 0;
  // stage:0-4, variant:0-5, accessory:0-19, house:0-10, landscape:0-7
  const value = si * (6*20*11*8) + v * (20*11*8) + a * (11*8) + h * 8 + l;
  const code = value.toString(36).toUpperCase().padStart(4, '0');
  return 'PET-' + code;
}

function decodePetCode(code) {
  if (!code || !code.startsWith('PET-') || code.length !== 8) return null;
  const hex = code.slice(4);
  const value = parseInt(hex, 36);
  if (isNaN(value) || value < 0) return null;
  const l = value % 8;
  const rem1 = Math.floor(value / 8);
  const h = rem1 % 11;
  const rem2 = Math.floor(rem1 / 11);
  const a = rem2 % 20;
  const rem3 = Math.floor(rem2 / 20);
  const v = rem3 % 6;
  const si = Math.floor(rem3 / 6);
  if (si < 0 || si > 4) return null;
  return { stage: STAGE_NAMES[si], variant: v, accessory: a, house: h, landscape: l };
}

function buildFriendsSection() {
  document.getElementById('my-pet-code').textContent = encodePetCode();
  const container = document.getElementById('visitor-card-container');
  if (visitor) {
    const stageName = visitor.stage;
    const acc = ACCESSORIES.find(a => a.id === visitor.accessory);
    const accName = acc ? acc.name : 'None';
    container.innerHTML = '<div class="friend-label" style="margin-top:16px">Current Visitor</div>' +
      '<div class="visitor-card">' +
      '<div class="visitor-info"><strong>' + stageName + ' Pet</strong><br>Accessory: ' + accName + '</div>' +
      '<button class="dismiss-btn" onclick="dismissVisitor()">Dismiss</button>' +
      '</div>';
  } else {
    container.innerHTML = '';
  }
}

function copyPetCode() {
  const code = encodePetCode();
  navigator.clipboard.writeText(code).then(() => {
    notify('üìã Code copied: ' + code);
  }).catch(() => {
    notify('Code: ' + code);
  });
}
window.copyPetCode = copyPetCode;

function addVisitorFromCode() {
  const input = document.getElementById('friend-code-input');
  const code = (input.value || '').trim().toUpperCase();
  const data = decodePetCode(code);
  if (!data) {
    notify('‚ùå Invalid code! Use format PET-XXXX');
    return;
  }
  visitor = data;
  input.value = '';
  closePanel('home');
  notify('üë´ Visitor pet arrived!');
}
window.addVisitorFromCode = addVisitorFromCode;

function dismissVisitor() {
  visitor = null;
  notify('üëã Visitor dismissed');
  buildFriendsSection();
}
window.dismissVisitor = dismissVisitor;

function buildHousePanel() {
  // Build houses grid
  const grid = document.getElementById('house-grid');
  grid.innerHTML = '';
  HOUSES.forEach(h => {
    const card = document.createElement('div');
    const isMathLocked = h.mathLevel !== undefined && !state.unlockedHouses.includes(h.id);
    const isUnlocked = !isMathLocked;

    let className = 'house-card';
    if (isMathLocked) className += ' math-locked';
    if (state.house === h.id) className += ' active-house';
    card.className = className;

    if (isMathLocked) {
      const levelNames = ['', 'Easy', 'Medium', 'Tricky', 'Challenge'];
      card.innerHTML = `<div class="house-icon">üß©</div><div class="house-name">${h.name}</div><div class="house-level">Lv${h.mathLevel} ${levelNames[h.mathLevel]}</div>`;
      card.onclick = () => openMathRiddle(h, 'house');
    } else {
      card.innerHTML = `<div class="house-icon">${h.emoji}</div><div class="house-name">${h.name}</div>`;
      card.onclick = () => {
        state.house = h.id;
        notify(h.id === 0 ? 'House removed' : 'Living in: ' + h.name);
        sfxConfirm();
        save();
        buildHousePanel();
      };
    }
    grid.appendChild(card);
  });

  // Build landscape grid
  const landGrid = document.getElementById('land-grid');
  landGrid.innerHTML = '';
  LANDSCAPES.forEach(l => {
    const card = document.createElement('div');
    let className = 'land-card';
    if (state.landscape === l.id) className += ' active-land';
    card.className = className;
    card.innerHTML = `<div class="land-icon">${l.emoji}</div><div class="land-name">${l.name}</div>`;
    card.onclick = () => {
      state.landscape = l.id;
      notify('Landscape: ' + l.name);
      sfxConfirm();
      save();
      buildHousePanel();
    };
    landGrid.appendChild(card);
  });
}

function buildStatsPanel(){
  const grid=document.getElementById('stats-grid');
  const si=STAGES[state.stage];
  const evoPct=si.dur<Infinity?Math.min(100,Math.round(state.stageTime/si.dur*100)):100;
  grid.innerHTML=`
    <div class="stat-card"><div class="stat-val">${Math.round(state.hunger)}%</div><div class="stat-lbl">Hunger</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.happiness)}%</div><div class="stat-lbl">Happiness</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.energy)}%</div><div class="stat-lbl">Energy</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.hygiene)}%</div><div class="stat-lbl">Hygiene</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.health)}%</div><div class="stat-lbl">Health</div></div>
    <div class="stat-card"><div class="stat-val">${Math.round(state.careScore)}</div><div class="stat-lbl">Care Score</div></div>
    <div class="stat-card"><div class="stat-val">${state.feedCount}</div><div class="stat-lbl">Meals</div></div>
    <div class="stat-card"><div class="stat-val">${state.playCount}</div><div class="stat-lbl">Games Played</div></div>
    <div class="stat-card wide"><div class="stat-val">${state.stage}${state.stage==='ADULT'?' (Final Form!)':''}</div><div class="stat-lbl">Stage${si.dur<Infinity?' - '+evoPct+'% to next':''}</div>${si.dur<Infinity?`<div class="evo-bar"><div class="evo-fill" style="width:${evoPct}%"></div></div>`:''}</div>
    <div class="stat-card wide"><div class="stat-val">${formatTime(state.totalTime)}</div><div class="stat-lbl">Age</div></div>
  `;
}

// ============================================================
// ACTIONS
// ============================================================
function feedPet(i){
  const f=FOODS[i];
  state.hunger=Math.min(100,state.hunger+f.hunger);
  state.happiness=Math.min(100,Math.max(0,state.happiness+f.happiness));
  state.health=Math.min(100,Math.max(0,state.health+f.health));
  state.energy=Math.min(100,state.energy+f.energy);
  state.feedCount++;
  state.careScore=Math.min(100,state.careScore+1);
  notify(f.emoji+' '+f.name+'! Yum!');
  sfxConfirm();
  // Food particles
  for(let j=0;j<5;j++) spawnParticle(petX()+(Math.random()-0.5)*60, petY()-20, f.emoji);
  save();
  updateHUD();
}

function doClean(){
  if(state.poopCount>0){
    state.poopCount=0;state.hygiene=100;state.careScore=Math.min(100,state.careScore+3);
    notify('‚ú® All clean!');sfxConfirm();
    for(let j=0;j<6;j++) spawnParticle(petX()+(Math.random()-0.5)*80, petY()+(Math.random()-0.5)*40, '‚ú®');
  } else {
    state.hygiene=Math.min(100,state.hygiene+20);
    notify('Already clean!');sfxSelect();
    for(let j=0;j<3;j++) spawnParticle(petX()+(Math.random()-0.5)*60, petY(), 'ü´ß');
  }
  save();updateHUD();
}

function toggleSleep(){
  state.sleeping=!state.sleeping;
  if(state.sleeping){notify('üí§ Good night...');}
  else{notify('‚òÄÔ∏è Good morning!');if(state.energy>80) state.careScore=Math.min(100,state.careScore+2);}
  sfxConfirm();save();updateHUD();
}

function petPat(){
  if(!state||!state.alive||state.stage==='EGG') return;
  if(state.sleeping) return;
  state.happiness=Math.min(100,state.happiness+2);
  state.careScore=Math.min(100,state.careScore+0.3);
  for(let j=0;j<3;j++) spawnParticle(petX()+(Math.random()-0.5)*40, petY()-petSize()*0.3, '‚ù§Ô∏è');
  sfxSelect();
  // Hide hint after first pat
  document.getElementById('pet-hint').style.opacity='0';
}

// ============================================================
// ACTION BAR
// ============================================================
document.querySelectorAll('.action-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const a=btn.dataset.action;
    if(!state||!state.alive) return;
    if(state.stage==='EGG'&&a!=='stats'&&a!=='home'){notify('Egg is not ready yet!');sfxDeny();return;}
    if(state.sleeping&&a!=='sleep'&&a!=='stats'&&a!=='home'){notify('Pet is sleeping!');sfxDeny();return;}
    sfxSelect();
    if(a==='feed'){buildFeedPanel();openPanel('feed');}
    else if(a==='play'){
      if(state.energy<10){notify('Too tired to play!');sfxDeny();return;}
      openPanel('play');
    }
    else if(a==='clean') doClean();
    else if(a==='dress'){buildDressPanel();openPanel('dress');}
    else if(a==='home'){buildHousePanel();openPanel('home');}
    else if(a==='sleep') toggleSleep();
    else if(a==='stats'){buildStatsPanel();openPanel('stats');}
  });
});

// ============================================================
// CANVAS CLICK -> PET / POOP / DEAD
// ============================================================
canvas.addEventListener('click', e=>{
  if(!state) return;

  // Dead -> new pet
  if(!state.alive){
    state=newState();save();notify('ü•ö A new egg!');updateHUD();return;
  }

  const cx=e.clientX, cy=e.clientY;
  const dx=cx-petX(), dy=cy-petY();
  const dist=Math.sqrt(dx*dx+dy*dy);

  // Tap poop to clean
  if(state.poopCount>0){
    const poopX=petX()+petSize()*0.6;
    const poopY=petY()+petSize()*0.3;
    if(cx>poopX-30 && cx<poopX+state.poopCount*30+30 && cy>poopY-40 && cy<poopY+30){
      doClean();return;
    }
  }

  // Tap pet to pat
  if(dist<petSize()*0.7){
    petPat();
  }
});

// ============================================================
// GARDEN INTERACTION LISTENERS
// ============================================================
document.addEventListener('mousedown', onUserInteraction);
document.addEventListener('touchstart', onUserInteraction);
document.querySelectorAll('.action-btn').forEach(btn => btn.addEventListener('click', onUserInteraction));

// Visibility change - activate garden mode when tab is hidden
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Activate garden mode immediately when tab is hidden
    if (state && state.alive && state.stage !== 'EGG' && !state.sleeping) {
      gardenMode = true;
      pickGardenTarget();
    }
  }
});

// ============================================================
// MINI-GAMES (rendered on mg-canvas)
// ============================================================
const mgCanvas=document.getElementById('mg-canvas');
const mgCtx=mgCanvas.getContext('2d');
mgCtx.imageSmoothingEnabled=false;
const MGW=240, MGH=200;
let miniGame=null;

function startGame(type){
  if(state.energy<10){notify('Too tired!');sfxDeny();return;}
  closePanel('play');
  if(type==='guess') startGuessGame();
  else if(type==='memory') startMemoryGame();
  else if(type==='dodge') startDodgeGame();
  document.getElementById('minigame-overlay').classList.add('open');
}
window.startGame=startGame;

function quitMiniGame(){
  endMiniGame(miniGame?miniGame.score||0:0);
}
window.quitMiniGame=quitMiniGame;

function endMiniGame(score){
  const reward=Math.min(30, score*3);
  state.happiness=Math.min(100,state.happiness+reward);
  state.energy=Math.max(0,state.energy-10);
  state.playCount++;
  state.careScore=Math.min(100,state.careScore+2);
  miniGame=null;
  document.getElementById('minigame-overlay').classList.remove('open');
  notify('üéÆ Fun! +'+reward+' happiness');
  sfxConfirm();save();updateHUD();
}

// Guess Direction
function startGuessGame(){
  miniGame={type:'guess',phase:'show',direction:['LEFT','RIGHT','UP','DOWN'][Math.floor(Math.random()*4)],timer:90,score:0,rounds:0,maxRounds:5};
}

// Memory Match
function startMemoryGame(){
  const syms=['üåü','üéà','üçï','üåà'];
  let cards=[];
  for(let i=0;i<4;i++) cards.push(syms[i],syms[i]);
  for(let i=cards.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[cards[i],cards[j]]=[cards[j],cards[i]];}
  miniGame={type:'memory',cards,revealed:new Array(8).fill(false),matched:new Array(8).fill(false),first:-1,second:-1,phase:'pick',timer:0,cursor:0,pairs:0,moves:0,score:0};
}

// Dodge
function startDodgeGame(){
  miniGame={type:'dodge',px:MGW/2,obstacles:[],spawnTimer:0,score:0,timer:600,hit:false,phase:'play'};
}

// MG keyboard
document.addEventListener('keydown',e=>{
  if(!miniGame) return;
  if(e.key==='Escape'){quitMiniGame();return;}
  if(miniGame.type==='guess') guessInput(e.key);
  else if(miniGame.type==='memory') memoryInput(e.key);
  else if(miniGame.type==='dodge') dodgeInput(e.key);
});

// MG canvas click for memory
mgCanvas.addEventListener('click',e=>{
  if(!miniGame||miniGame.type!=='memory'||miniGame.phase!=='pick') return;
  const rect=mgCanvas.getBoundingClientRect();
  const sx=MGW/rect.width, sy=MGH/rect.height;
  const mx=(e.clientX-rect.left)*sx, my=(e.clientY-rect.top)*sy;
  for(let i=0;i<8;i++){
    const col=i%4, row=Math.floor(i/4);
    const cx=16+col*55, cy=50+row*70;
    if(mx>=cx&&mx<=cx+45&&my>=cy&&my<=cy+55){
      memorySelect(i);
      break;
    }
  }
});

// MG canvas touch for dodge
let dodgeTouchX=null;
mgCanvas.addEventListener('touchstart',e=>{
  if(!miniGame||miniGame.type!=='dodge') return;
  dodgeTouchX=e.touches[0].clientX;
},{passive:true});
mgCanvas.addEventListener('touchmove',e=>{
  if(!miniGame||miniGame.type!=='dodge'||dodgeTouchX===null) return;
  const dx=e.touches[0].clientX-dodgeTouchX;
  dodgeTouchX=e.touches[0].clientX;
  miniGame.px=Math.max(10,Math.min(MGW-20,miniGame.px+dx*1.5));
},{passive:true});

// Guess game click on arrows
mgCanvas.addEventListener('click',e=>{
  if(!miniGame||miniGame.type!=='guess'||miniGame.phase!=='input') return;
  const rect=mgCanvas.getBoundingClientRect();
  const sx=MGW/rect.width;
  const mx=(e.clientX-rect.left)*sx, my=(e.clientY-rect.top)*sx;
  if(mx<MGW*0.33) guessAnswer('LEFT');
  else if(mx>MGW*0.66) guessAnswer('RIGHT');
  else if(my<MGH*0.4) guessAnswer('UP');
  else guessAnswer('DOWN');
});

function guessInput(key){
  if(miniGame.phase!=='input') return;
  if(key==='ArrowLeft') guessAnswer('LEFT');
  else if(key==='ArrowRight') guessAnswer('RIGHT');
  else if(key==='ArrowUp') guessAnswer('UP');
  else if(key==='ArrowDown') guessAnswer('DOWN');
}

function guessAnswer(dir){
  if(miniGame.phase!=='input') return;
  if(dir===miniGame.direction) miniGame.score++;
  miniGame.phase='result';
  miniGame.answer=dir;
  miniGame.timer=45;
}

function memoryInput(key){
  if(miniGame.phase!=='pick') return;
  if(key==='ArrowLeft') miniGame.cursor=(miniGame.cursor-1+8)%8;
  else if(key==='ArrowRight') miniGame.cursor=(miniGame.cursor+1)%8;
  else if(key==='ArrowUp') miniGame.cursor=(miniGame.cursor-4+8)%8;
  else if(key==='ArrowDown') miniGame.cursor=(miniGame.cursor+4)%8;
  else if(key==='Enter'||key===' ') memorySelect(miniGame.cursor);
}

function memorySelect(idx){
  if(miniGame.phase!=='pick'||miniGame.matched[idx]||miniGame.revealed[idx]) return;
  miniGame.revealed[idx]=true;
  miniGame.moves++;
  if(miniGame.first===-1){miniGame.first=idx;}
  else{miniGame.second=idx;miniGame.phase='compare';miniGame.timer=30;}
}

function dodgeInput(key){
  if(miniGame.phase!=='play') return;
  if(key==='ArrowLeft') miniGame.px=Math.max(10,miniGame.px-12);
  if(key==='ArrowRight') miniGame.px=Math.min(MGW-20,miniGame.px+12);
}

// MG update + draw
function updateMiniGame(){
  if(!miniGame) return;
  const mg=miniGame;

  if(mg.type==='guess'){
    mg.timer--;
    if(mg.phase==='show'&&mg.timer<=0){mg.phase='input';mg.timer=120;}
    else if(mg.phase==='input'&&mg.timer<=0){mg.phase='result';mg.answer=null;mg.timer=45;}
    else if(mg.phase==='result'&&mg.timer<=0){
      mg.rounds++;
      if(mg.rounds>=mg.maxRounds){endMiniGame(mg.score);return;}
      mg.direction=['LEFT','RIGHT','UP','DOWN'][Math.floor(Math.random()*4)];
      mg.phase='show';mg.timer=90;mg.answer=null;
    }
  } else if(mg.type==='memory'){
    if(mg.phase==='compare'){
      mg.timer--;
      if(mg.timer<=0){
        if(mg.cards[mg.first]===mg.cards[mg.second]){mg.matched[mg.first]=true;mg.matched[mg.second]=true;mg.pairs++;mg.score+=2;
          if(mg.pairs>=4){endMiniGame(mg.score+Math.max(0,20-mg.moves));return;}}
        mg.revealed[mg.first]=false;mg.revealed[mg.second]=false;mg.first=-1;mg.second=-1;mg.phase='pick';
      }
    }
  } else if(mg.type==='dodge'){
    if(mg.phase==='play'){
      mg.spawnTimer--;
      if(mg.spawnTimer<=0){mg.obstacles.push({x:Math.random()*(MGW-20),y:-10,w:10+Math.random()*20,speed:1.5+Math.random()*2});mg.spawnTimer=12+Math.random()*18;}
      for(let i=mg.obstacles.length-1;i>=0;i--){
        mg.obstacles[i].y+=mg.obstacles[i].speed;
        if(mg.obstacles[i].y+8>MGH-30&&mg.obstacles[i].y<MGH-15&&mg.obstacles[i].x+mg.obstacles[i].w>mg.px-5&&mg.obstacles[i].x<mg.px+15){mg.hit=true;mg.phase='end';mg.timer=60;return;}
        if(mg.obstacles[i].y>MGH){mg.obstacles.splice(i,1);mg.score++;}
      }
      mg.timer--;
      if(mg.timer<=0){mg.phase='end';mg.timer=60;}
    } else if(mg.phase==='end'){
      mg.timer--;
      if(mg.timer<=0) endMiniGame(mg.score);
    }
  }

  document.getElementById('mg-score').textContent='Score: '+(mg.score||0);
}

function drawMiniGame(){
  if(!miniGame) return;
  const mg=miniGame;
  mgCtx.fillStyle='#1a1a2e';
  mgCtx.fillRect(0,0,MGW,MGH);

  if(mg.type==='guess'){
    mgCtx.textAlign='center';
    mgCtx.fillStyle='#fff';
    mgCtx.font='bold 16px sans-serif';
    mgCtx.fillText('Guess Direction',MGW/2,25);
    mgCtx.font='12px sans-serif';
    mgCtx.fillStyle='rgba(255,255,255,0.5)';
    mgCtx.fillText(`Round ${mg.rounds+1}/${mg.maxRounds}`,MGW/2,42);

    if(mg.phase==='show'){
      // Draw big arrow
      mgCtx.font='48px sans-serif';
      const arrows={LEFT:'‚¨ÖÔ∏è',RIGHT:'‚û°Ô∏è',UP:'‚¨ÜÔ∏è',DOWN:'‚¨áÔ∏è'};
      mgCtx.fillText(arrows[mg.direction],MGW/2,120);
      mgCtx.font='14px sans-serif';
      mgCtx.fillStyle='rgba(255,255,255,0.6)';
      mgCtx.fillText('Remember this!',MGW/2,160);
    } else if(mg.phase==='input'){
      mgCtx.font='14px sans-serif';
      mgCtx.fillStyle='#fff';
      mgCtx.fillText('Which way was it?',MGW/2,70);
      // Draw clickable zones
      mgCtx.font='32px sans-serif';
      mgCtx.fillText('‚¨ÖÔ∏è',50,125);
      mgCtx.fillText('‚¨ÜÔ∏è',MGW/2,85);
      mgCtx.fillText('‚¨áÔ∏è',MGW/2,165);
      mgCtx.fillText('‚û°Ô∏è',MGW-50,125);
      // Timer bar
      mgCtx.fillStyle='rgba(255,255,255,0.1)';
      mgCtx.fillRect(20,180,200,6);
      mgCtx.fillStyle='#74b9ff';
      mgCtx.fillRect(20,180,200*mg.timer/120,6);
    } else {
      const correct=mg.answer===mg.direction;
      mgCtx.font='bold 20px sans-serif';
      mgCtx.fillStyle=correct?'#55efc4':'#ff7675';
      mgCtx.fillText(correct?'Correct! ‚úì':'Wrong ‚úó',MGW/2,100);
      mgCtx.font='14px sans-serif';
      mgCtx.fillStyle='rgba(255,255,255,0.5)';
      mgCtx.fillText('Answer: '+mg.direction,MGW/2,130);
    }
    mgCtx.textAlign='start';
  } else if(mg.type==='memory'){
    mgCtx.textAlign='center';
    mgCtx.fillStyle='#fff';
    mgCtx.font='bold 16px sans-serif';
    mgCtx.fillText('Memory Match',MGW/2,25);
    mgCtx.font='11px sans-serif';
    mgCtx.fillStyle='rgba(255,255,255,0.4)';
    mgCtx.fillText('Moves: '+mg.moves,MGW/2,40);
    mgCtx.textAlign='start';

    for(let i=0;i<8;i++){
      const col=i%4, row=Math.floor(i/4);
      const cx=16+col*55, cy=50+row*70;
      if(mg.matched[i]){
        mgCtx.fillStyle='rgba(85,239,196,0.15)';
        mgCtx.fillRect(cx,cy,45,55);
        mgCtx.font='24px sans-serif';
        mgCtx.textAlign='center';
        mgCtx.fillText(mg.cards[i],cx+22,cy+38);
        mgCtx.textAlign='start';
      } else if(mg.revealed[i]){
        mgCtx.fillStyle='rgba(116,185,255,0.2)';
        mgCtx.fillRect(cx,cy,45,55);
        mgCtx.font='24px sans-serif';
        mgCtx.textAlign='center';
        mgCtx.fillText(mg.cards[i],cx+22,cy+38);
        mgCtx.textAlign='start';
      } else {
        mgCtx.fillStyle='rgba(255,255,255,0.08)';
        mgCtx.fillRect(cx,cy,45,55);
        mgCtx.font='20px sans-serif';
        mgCtx.textAlign='center';
        mgCtx.fillStyle='rgba(255,255,255,0.2)';
        mgCtx.fillText('?',cx+22,cy+36);
        mgCtx.textAlign='start';
      }
      // Keyboard cursor
      if(i===mg.cursor&&mg.phase==='pick'){
        mgCtx.strokeStyle='rgba(255,255,255,0.5)';
        mgCtx.lineWidth=2;
        mgCtx.strokeRect(cx-1,cy-1,47,57);
      }
    }
  } else if(mg.type==='dodge'){
    mgCtx.textAlign='center';
    mgCtx.fillStyle='#fff';
    mgCtx.font='bold 14px sans-serif';
    mgCtx.fillText('Dodge!',MGW/2,20);
    mgCtx.textAlign='start';

    // Player
    mgCtx.fillStyle='#74b9ff';
    mgCtx.beginPath();
    mgCtx.moveTo(mg.px,MGH-30);
    mgCtx.lineTo(mg.px-8,MGH-15);
    mgCtx.lineTo(mg.px+8,MGH-15);
    mgCtx.closePath();
    mgCtx.fill();

    // Obstacles
    mgCtx.fillStyle='#ff7675';
    for(const ob of mg.obstacles){
      mgCtx.fillRect(Math.round(ob.x),Math.round(ob.y),Math.round(ob.w),8);
    }

    // Timer
    mgCtx.fillStyle='rgba(255,255,255,0.1)';
    mgCtx.fillRect(20,MGH-8,200,4);
    mgCtx.fillStyle='#ffd93d';
    mgCtx.fillRect(20,MGH-8,200*mg.timer/600,4);

    if(mg.phase==='end'){
      mgCtx.fillStyle='rgba(0,0,0,0.6)';
      mgCtx.fillRect(0,0,MGW,MGH);
      mgCtx.textAlign='center';
      mgCtx.fillStyle='#fff';
      mgCtx.font='bold 20px sans-serif';
      mgCtx.fillText(mg.hit?'Hit!':'Time Up!',MGW/2,85);
      mgCtx.font='16px sans-serif';
      mgCtx.fillText('Score: '+mg.score,MGW/2,115);
      mgCtx.textAlign='start';
    }
  }
}

// ============================================================
// GAME LOOP
// ============================================================
let lastTime=performance.now();
let decayAccum=0, saveAccum=0, hudAccum=0, warnAccum=0;

function gameLoop(now){
  const dt=Math.min(now-lastTime,100);
  lastTime=now;

  if(state&&state.alive&&state.stage!=='EGG'){
    decayAccum+=dt;
    while(decayAccum>=500){
      decayAccum-=500;
      const s=0.5, sm=state.sleeping?0.3:1;
      state.hunger=Math.max(0,state.hunger-DECAY.hunger*s*sm);
      state.happiness=Math.max(0,state.happiness-DECAY.happiness*s*sm);
      state.energy=state.sleeping?Math.min(100,state.energy+0.05*s):Math.max(0,state.energy-DECAY.energy*s);
      state.hygiene=Math.max(0,state.hygiene-DECAY.hygiene*s*sm);
      if(state.hunger<10||state.hygiene<10) state.health=Math.max(0,state.health-DECAY.health*s*2);
      state.poopTimer+=500;
      if(state.poopTimer>=60000&&state.poopCount<5){state.poopTimer-=60000;state.poopCount++;state.hygiene=Math.max(0,state.hygiene-10);}
      state.happinessSum+=state.happiness;state.happinessSamples++;
      if(state.health<=0) state.alive=false;
    }
    state.stageTime+=dt;state.totalTime+=dt;state.lastUpdate=Date.now();
  } else if(state&&state.stage==='EGG'){
    state.stageTime+=dt;state.totalTime+=dt;state.lastUpdate=Date.now();
  }

  // Save
  saveAccum+=dt;
  if(saveAccum>=AUTO_SAVE_MS){saveAccum=0;save();}

  // HUD update
  hudAccum+=dt;
  if(hudAccum>=500){hudAccum=0;updateHUD();}

  // Warnings
  warnAccum+=dt;
  if(warnAccum>=8000&&state&&state.alive&&state.stage!=='EGG'){
    warnAccum=0;
    if(state.hunger<15){notify('üçΩÔ∏è Pet is hungry!');state.missedCare++;}
    else if(state.hygiene<15){notify('ü§¢ Pet is dirty!');state.missedCare++;}
    else if(state.energy<10&&!state.sleeping) notify('üò¥ Pet is tired!');
    else if(state.health<25){notify('ü§í Pet is sick!');state.missedCare++;}
  }

  // Evolution
  if(state&&state.alive&&!evolveAnim) checkEvolution();

  // Particles
  updateParticles(dt);

  // Mini-game
  if(miniGame) updateMiniGame();

  // Garden autonomous behavior
  updateGarden(dt);

  // ---- DRAW ----
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(devicePixelRatio,devicePixelRatio);
  const mood=getMood();
  // Use landscape background if set, otherwise default
  if (state && state.landscape && state.landscape > 0) {
    drawLandscapeBackground(now, mood);
  } else {
    drawBackground(now, mood);
  }

  // Draw garden elements (after background, before pet)
  if (state && state.alive && state.stage !== 'EGG') {
    drawGarden(now, (state && state.landscape) || 0);
    drawGardenPlants(now); // Draw planted garden plants
  }

  // Draw floating balloon (behind pet)
  if (state && state.alive && gardenMode) {
    drawBalloon(now);
  }

  if(state&&state.alive){
    drawHouse(now);
    // Draw companion pet (before main pet for layering)
    if (state.companion) {
      drawCompanion(now);
    }
    drawPet(now, mood, state.stage, state.variant, state.sleeping, state.accessory);
    if (visitor) drawVisitorPet(now);
    drawPoops(now);
  } else if(state){
    drawDeadPet();
  }

  drawParticles();
  if(evolveAnim) drawEvolveAnim(now);

  // Mini-game
  if(miniGame) drawMiniGame();

  requestAnimationFrame(gameLoop);
}

// ============================================================
// CHAT SYSTEM - Speech Bubble
// ============================================================
const chatToggle = document.getElementById('chat-toggle');
const speechBubbleContainer = document.getElementById('speech-bubble-container');
const speechBubble = document.getElementById('speech-bubble');
const bubbleText = document.querySelector('#speech-bubble .bubble-text');
const bubbleClose = document.getElementById('bubble-close');
const chatInputBar = document.getElementById('chat-input-bar');
const chatInput = document.getElementById('chat-input');
const chatSend = document.getElementById('chat-send');
let chatOpen = false;
let conversationHistory = [];
let isSending = false;
let bubbleTimeout = null;

// API base URL - uses same origin when served from the server
const API_BASE = '';

function toggleChat() {
  if (!state || state.stage === 'EGG') {
    notify('ü•ö Your pet can\'t talk yet!');
    sfxDeny();
    return;
  }
  chatOpen = !chatOpen;
  chatInputBar.classList.toggle('visible', chatOpen);
  if (chatOpen) {
    chatInput.focus();
    // Show a greeting bubble if not already showing
    if (!speechBubbleContainer.classList.contains('visible')) {
      showBubble(getGreeting());
    }
  } else {
    hideBubble();
  }
}

function closeChat() {
  chatOpen = false;
  chatInputBar.classList.remove('visible');
  hideBubble();
}

function getGreeting() {
  const mood = getMood();
  const greetings = {
    BABY: {
      happy: ['Hewwo! üíï', 'Yay! You here! üéâ', 'Me wuv you! üíñ'],
      hungry: ['Hungwy... üçº', 'Want nummies! üò¢'],
      sleepy: ['*yawns* Sweepy... üí§', 'Me tired... üò¥'],
      default: ['Hi hi! ‚ú®', 'Goo goo! üíï']
    },
    CHILD: {
      happy: ['Hi!! What are we doing today? üåü', 'Yay you\'re here! üéà', 'Let\'s play!! üéÆ'],
      hungry: ['My tummy is rumbling... üçï', 'Can we eat something? ü•∫'],
      sleepy: ['*yawns* I\'m getting sleepy... üò¥', 'Maybe nap time? üí§'],
      default: ['Hey hey! ‚ú®', 'What\'s up? üòä']
    },
    TEEN: {
      happy: ['Oh hey! üëã', 'What\'s good? ‚úåÔ∏è', 'Finally some company üòé'],
      hungry: ['Ugh I\'m starving... üçî', 'Can we get food? üò§'],
      sleepy: ['*yawns* So tired rn... üò¥', 'Need sleep tbh üí§'],
      default: ['Sup üëã', 'Hey there üòè']
    },
    ADULT: {
      happy: ['Hello, dear friend! üí´', 'Wonderful to see you! ‚ú®', 'What a lovely moment üå∏'],
      hungry: ['I could use a nice meal... üçΩÔ∏è', 'Feeling a bit peckish üòä'],
      sleepy: ['Feeling peaceful and drowsy... üåô', 'Perhaps some rest would be nice üí§'],
      default: ['Hello there üíï', 'Good to see you ‚ú®']
    }
  };
  
  const stageGreetings = greetings[state.stage] || greetings.BABY;
  let pool = stageGreetings.default;
  
  if (mood === 'hungry' && stageGreetings.hungry) pool = stageGreetings.hungry;
  else if (mood === 'sleepy' && stageGreetings.sleepy) pool = stageGreetings.sleepy;
  else if ((mood === 'happy' || mood === 'ecstatic') && stageGreetings.happy) pool = stageGreetings.happy;
  
  return pool[Math.floor(Math.random() * pool.length)];
}

function showBubble(text, duration = 0) {
  clearTimeout(bubbleTimeout);
  bubbleText.classList.remove('typing');
  bubbleText.textContent = text;
  speechBubbleContainer.classList.add('visible');
  
  // Re-trigger animation
  speechBubble.style.animation = 'none';
  speechBubble.offsetHeight; // Trigger reflow
  speechBubble.style.animation = 'bubblePop 0.3s ease-out';
  
  // Auto-hide after duration (if set)
  if (duration > 0) {
    bubbleTimeout = setTimeout(() => {
      if (!chatOpen) hideBubble();
    }, duration);
  }
}

function hideBubble() {
  clearTimeout(bubbleTimeout);
  speechBubbleContainer.classList.remove('visible');
}

function showTypingBubble() {
  bubbleText.textContent = 'Thinking';
  bubbleText.classList.add('typing');
  speechBubbleContainer.classList.add('visible');
}

function updateChatUI() {
  if (!state) return;
  const canChat = state.alive && state.stage !== 'EGG';
  
  chatToggle.classList.toggle('disabled', !canChat);
  chatInput.disabled = !canChat || isSending;
  chatSend.disabled = !canChat || isSending;
  
  if (!canChat && chatOpen) {
    closeChat();
  }
}

async function sendChatMessage() {
  const message = chatInput.value.trim();
  if (!message || isSending || !state || state.stage === 'EGG') return;
  
  chatInput.value = '';
  
  // Add to conversation history
  conversationHistory.push({ role: 'user', content: message });
  
  isSending = true;
  updateChatUI();
  showTypingBubble();
  
  try {
    // Add timeout for fetch request (30 seconds)
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);
    
    const response = await fetch(`${API_BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      signal: controller.signal,
      body: JSON.stringify({
        message,
        petState: {
          stage: state.stage,
          mood: getMood(),
          hunger: state.hunger,
          happiness: state.happiness,
          energy: state.energy,
          hygiene: state.hygiene,
          health: state.health,
          variant: state.variant,
          accessory: state.accessory,
          totalTime: state.totalTime,
          sleeping: state.sleeping
        },
        conversationHistory: conversationHistory.slice(-10)
      })
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      let errorMsg = `Server error: ${response.status}`;
      try {
        const error = await response.json();
        errorMsg = error.error || error.details || errorMsg;
      } catch (e) {
        // Response wasn't JSON, use status text
        errorMsg = response.statusText || errorMsg;
      }
      throw new Error(errorMsg);
    }
    
    const data = await response.json();
    
    // Show pet response in bubble
    showBubble(data.response);
    
    // Add to conversation history
    conversationHistory.push({ role: 'assistant', content: data.response });
    
    // Small happiness boost for chatting
    state.happiness = Math.min(100, state.happiness + 1);
    
    // Spawn heart particles
    for(let j=0;j<2;j++) spawnParticle(petX()+(Math.random()-0.5)*40, petY()-petSize()*0.5, 'üíï');
    
    // Speak the response (text-to-speech)
    speakText(data.response, state.stage);
    
    // Play cute pet sound based on stage and mood
    sfxPetSpeak(state.stage, getMood());
    
  } catch (error) {
    console.error('Chat error:', error);
    console.error('Chat error details:', {
      message: error.message,
      name: error.name,
      stack: error.stack
    });
    
    // Determine user-friendly error message
    let errorDescription = error.message;
    if (error.name === 'AbortError') {
      errorDescription = 'Request timed out - server may be slow';
    } else if (error.message === 'Failed to fetch' || error.message.includes('NetworkError')) {
      errorDescription = 'Cannot reach server - is it running?';
    }
    
    // Fallback responses based on stage with error hint in dev
    const fallbacks = {
      BABY: 'Me sleepy... hehe!',
      CHILD: 'Hmm, I got confused! Can you say that again?',
      TEEN: 'Ugh, something went wrong... whatever',
      ADULT: 'I apologize, I seem to be having trouble thinking clearly right now'
    };
    const fallbackMsg = fallbacks[state.stage] || 'Hmm...';
    showBubble(fallbackMsg);
    speakText(fallbackMsg, state.stage);
    
    // Show notification with actual error in development
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      notify(`Chat error: ${errorDescription}`, 5000);
    }
  }
  
  isSending = false;
  updateChatUI();
  chatInput.focus();
}

// Chat event listeners
chatToggle.addEventListener('click', toggleChat);
bubbleClose.addEventListener('click', closeChat);
chatSend.addEventListener('click', sendChatMessage);
chatInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendChatMessage();
  }
});
chatInput.addEventListener('focus', onUserInteraction);

// Clear chat history on evolution
function clearChatOnEvolve() {
  conversationHistory = [];
  // Show evolution celebration bubble
  if (state.stage !== 'EGG') {
    const evolveMessages = {
      BABY: 'I hatched!! Hi hi! üê£üíï',
      CHILD: 'Wow I grew up! Look at me! üåü',
      TEEN: 'Whoa... I feel different! üòé‚ú®',
      ADULT: 'I have reached my final form! Thank you for everything üí´üå∏'
    };
    setTimeout(() => showBubble(evolveMessages[state.stage] || 'I evolved! ‚ú®', 5000), 1500);
  }
}

// ============================================================
// INIT
// ============================================================
function init(){
  if(!load()) state=newState();
  else applyOfflineDecay();
  updateHUD();
  updateChatUI();
  buildFeedPanel();
  buildDressPanel();
  initTTS();

  document.addEventListener('visibilitychange',()=>{if(document.hidden) save();});
  window.addEventListener('beforeunload',save);

  requestAnimationFrame(gameLoop);
}

init();

})();
</script>
</body>
</html>
